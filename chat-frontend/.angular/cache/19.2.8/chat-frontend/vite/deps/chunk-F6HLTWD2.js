import {
  animate,
  sequence,
  state,
  style,
  transition,
  trigger
} from "./chunk-RIHOY4BZ.js";
import {
  ActivatedRoute,
  NavigationEnd,
  Router,
  RouterLink,
  RouterLinkActive,
  RouterModule,
  RouterOutlet
} from "./chunk-L2LRJJ7D.js";
import {
  DomSanitizer
} from "./chunk-LR7TLK6Z.js";
import {
  AsyncPipe,
  CommonModule,
  DatePipe,
  FormStyle,
  FormatWidth,
  Location,
  NgClass,
  NgForOf,
  NgIf,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet,
  TranslationWidth,
  getDOM,
  getLocaleDayNames,
  getLocaleFirstDayOfWeek,
  getLocaleMonthNames,
  getLocaleTimeFormat
} from "./chunk-WDOQFQCE.js";
import {
  DOCUMENT,
  isPlatformBrowser
} from "./chunk-ZHU264VY.js";
import {
  ANIMATION_MODULE_TYPE,
  APP_ID,
  ApplicationRef,
  Attribute,
  BehaviorSubject,
  CSP_NONCE,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ConnectableObservable,
  ContentChild,
  ContentChildren,
  Directive,
  EMPTY,
  ElementRef,
  EnvironmentInjector,
  EventEmitter,
  Host,
  HostAttributeToken,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  LOCALE_ID,
  NgModule,
  NgModuleRef$1,
  NgZone,
  Observable,
  Optional,
  Output,
  PLATFORM_ID,
  Pipe,
  QueryList,
  Renderer2,
  RendererFactory2,
  ReplaySubject,
  RuntimeError,
  Self,
  SimpleChange,
  SkipSelf,
  Subject,
  Subscription,
  TemplateRef,
  Type,
  VERSION,
  Version,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation,
  afterNextRender,
  afterRender,
  animationFrameScheduler,
  asapScheduler,
  auditTime,
  booleanAttribute,
  combineLatest,
  computed,
  concat,
  createComponent,
  debounceTime,
  delay,
  distinctUntilChanged,
  effect,
  filter,
  finalize,
  forkJoin,
  forwardRef,
  from,
  fromEvent,
  inject,
  interval,
  isDevMode,
  isObservable,
  isPromise,
  isSignal,
  isSubscribable,
  map,
  merge,
  observeOn,
  of,
  pairwise,
  publish,
  refCount,
  repeat,
  setClassMetadata,
  share,
  shareReplay,
  signal,
  skip,
  startWith,
  switchMap,
  take,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  timer,
  untracked,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpureFunction1,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵstyleProp,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-4P7I4DUV.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-TXDUYLVM.js";

// node_modules/@angular/forms/fesm2022/forms.mjs
var BaseControlValueAccessor = class _BaseControlValueAccessor {
  _renderer;
  _elementRef;
  /**
   * The registered callback function called when a change or input event occurs on the input
   * element.
   * @nodoc
   */
  onChange = (_) => {
  };
  /**
   * The registered callback function called when a blur event occurs on the input element.
   * @nodoc
   */
  onTouched = () => {
  };
  constructor(_renderer, _elementRef) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
  }
  /**
   * Helper method that sets a property on a target element using the current Renderer
   * implementation.
   * @nodoc
   */
  setProperty(key, value) {
    this._renderer.setProperty(this._elementRef.nativeElement, key, value);
  }
  /**
   * Registers a function called when the control is touched.
   * @nodoc
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * Sets the "disabled" property on the range input element.
   * @nodoc
   */
  setDisabledState(isDisabled) {
    this.setProperty("disabled", isDisabled);
  }
  static ɵfac = function BaseControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseControlValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseControlValueAccessor
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
var BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵBuiltInControlValueAccessor_BaseFactory;
    return function BuiltInControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵBuiltInControlValueAccessor_BaseFactory || (ɵBuiltInControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_BuiltInControlValueAccessor)))(__ngFactoryType__ || _BuiltInControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _BuiltInControlValueAccessor,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
    type: Directive
  }], null, null);
})();
var NG_VALUE_ACCESSOR = new InjectionToken(ngDevMode ? "NgValueAccessor" : "");
var CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CheckboxControlValueAccessor),
  multi: true
};
var CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "checked" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("checked", value);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCheckboxControlValueAccessor_BaseFactory;
    return function CheckboxControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵCheckboxControlValueAccessor_BaseFactory || (ɵCheckboxControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_CheckboxControlValueAccessor)))(__ngFactoryType__ || _CheckboxControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _CheckboxControlValueAccessor,
    selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
    hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.checked);
        })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
      host: {
        "(change)": "onChange($event.target.checked)",
        "(blur)": "onTouched()"
      },
      providers: [CHECKBOX_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DefaultValueAccessor),
  multi: true
};
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
var COMPOSITION_BUFFER_MODE = new InjectionToken(ngDevMode ? "CompositionEventMode" : "");
var DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
  _compositionMode;
  /** Whether the user is creating a composition string (IME events). */
  _composing = false;
  constructor(renderer, elementRef, _compositionMode) {
    super(renderer, elementRef);
    this._compositionMode = _compositionMode;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /** @internal */
  _handleInput(value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this.onChange(value);
    }
  }
  /** @internal */
  _compositionStart() {
    this._composing = true;
  }
  /** @internal */
  _compositionEnd(value) {
    this._composing = false;
    this._compositionMode && this.onChange(value);
  }
  static ɵfac = function DefaultValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(COMPOSITION_BUFFER_MODE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DefaultValueAccessor,
    selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
    hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
          return ctx._handleInput($event.target.value);
        })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
          return ctx._compositionStart();
        })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
          return ctx._compositionEnd($event.target.value);
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([DEFAULT_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
      // TODO: vsavkin replace the above selector with the one below it once
      // https://github.com/angular/angular/issues/3011 is implemented
      // selector: '[ngModel],[formControl],[formControlName]',
      host: {
        "(input)": "$any(this)._handleInput($event.target.value)",
        "(blur)": "onTouched()",
        "(compositionstart)": "$any(this)._compositionStart()",
        "(compositionend)": "$any(this)._compositionEnd($event.target.value)"
      },
      providers: [DEFAULT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [COMPOSITION_BUFFER_MODE]
    }]
  }], null);
})();
function isEmptyInputValue(value) {
  return value == null || lengthOrSize(value) === 0;
}
function lengthOrSize(value) {
  if (value == null) {
    return null;
  } else if (Array.isArray(value) || typeof value === "string") {
    return value.length;
  } else if (value instanceof Set) {
    return value.size;
  }
  return null;
}
var NG_VALIDATORS = new InjectionToken(ngDevMode ? "NgValidators" : "");
var NG_ASYNC_VALIDATORS = new InjectionToken(ngDevMode ? "NgAsyncValidators" : "");
var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var Validators = class {
  /**
   * @description
   * Validator that requires the control's value to be greater than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a minimum of 3
   *
   * ```ts
   * const control = new FormControl(2, Validators.min(3));
   *
   * console.log(control.errors); // {min: {min: 3, actual: 2}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `min` property if the validation check fails, otherwise `null`.
   *
   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}
   *
   */
  static min(min) {
    return minValidator(min);
  }
  /**
   * @description
   * Validator that requires the control's value to be less than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a maximum of 15
   *
   * ```ts
   * const control = new FormControl(16, Validators.max(15));
   *
   * console.log(control.errors); // {max: {max: 15, actual: 16}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `max` property if the validation check fails, otherwise `null`.
   *
   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}
   *
   */
  static max(max) {
    return maxValidator(max);
  }
  /**
   * @description
   * Validator that requires the control have a non-empty value.
   *
   * @usageNotes
   *
   * ### Validate that the field is non-empty
   *
   * ```ts
   * const control = new FormControl('', Validators.required);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map with the `required` property
   * if the validation check fails, otherwise `null`.
   *
   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}
   *
   */
  static required(control) {
    return requiredValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value be true. This validator is commonly
   * used for required checkboxes.
   *
   * @usageNotes
   *
   * ### Validate that the field value is true
   *
   * ```ts
   * const control = new FormControl('some value', Validators.requiredTrue);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map that contains the `required` property
   * set to `true` if the validation check fails, otherwise `null`.
   *
   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}
   *
   */
  static requiredTrue(control) {
    return requiredTrueValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value pass an email validation test.
   *
   * Tests the value using a [regular
   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
   * pattern suitable for common use cases. The pattern is based on the definition of a valid email
   * address in the [WHATWG HTML
   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
   * lengths of different parts of the address).
   *
   * The differences from the WHATWG version include:
   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).
   * - Disallow `local-part` to be longer than 64 characters.
   * - Disallow the whole address to be longer than 254 characters.
   *
   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to
   * validate the value against a different pattern.
   *
   * @usageNotes
   *
   * ### Validate that the field matches a valid email pattern
   *
   * ```ts
   * const control = new FormControl('bad@', Validators.email);
   *
   * console.log(control.errors); // {email: true}
   * ```
   *
   * @returns An error map with the `email` property
   * if the validation check fails, otherwise `null`.
   *
   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}
   *
   */
  static email(control) {
    return emailValidator(control);
  }
  /**
   * @description
   * Validator that requires the number of items in the control's value to be greater than or equal
   * to the provided minimum length. This validator is also provided by default if you use
   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used
   * only for types that have a numeric `length` or `size` property, such as strings, arrays or
   * sets. The `minLength` validator logic is also not invoked for values when their `length` or
   * `size` property is 0 (for example in case of an empty string or an empty array), to support
   * optional controls. You can use the standard `required` validator if empty values should not be
   * considered valid.
   *
   * @usageNotes
   *
   * ### Validate that the field has a minimum of 3 characters
   *
   * ```ts
   * const control = new FormControl('ng', Validators.minLength(3));
   *
   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}
   * ```
   *
   * ```html
   * <input minlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `minlength` property if the validation check fails, otherwise `null`.
   *
   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}
   *
   */
  static minLength(minLength) {
    return minLengthValidator(minLength);
  }
  /**
   * @description
   * Validator that requires the number of items in the control's value to be less than or equal
   * to the provided maximum length. This validator is also provided by default if you use
   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used
   * only for types that have a numeric `length` or `size` property, such as strings, arrays or
   * sets.
   *
   * @usageNotes
   *
   * ### Validate that the field has maximum of 5 characters
   *
   * ```ts
   * const control = new FormControl('Angular', Validators.maxLength(5));
   *
   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}
   * ```
   *
   * ```html
   * <input maxlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `maxlength` property if the validation check fails, otherwise `null`.
   *
   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}
   *
   */
  static maxLength(maxLength) {
    return maxLengthValidator(maxLength);
  }
  /**
   * @description
   * Validator that requires the control's value to match a regex pattern. This validator is also
   * provided by default if you use the HTML5 `pattern` attribute.
   *
   * @usageNotes
   *
   * ### Validate that the field only contains letters or spaces
   *
   * ```ts
   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));
   *
   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}
   * ```
   *
   * ```html
   * <input pattern="[a-zA-Z ]*">
   * ```
   *
   * ### Pattern matching with the global or sticky flag
   *
   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`
   * can produce different results on the same input when validations are run consecutively. This is
   * due to how the behavior of `RegExp.prototype.test` is
   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)
   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).
   * Due to this behavior, it is recommended that when using
   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky
   * flag enabled.
   *
   * ```ts
   * // Not recommended (since the `g` flag is used)
   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));
   *
   * // Good
   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));
   * ```
   *
   * @param pattern A regular expression to be used as is to test the values, or a string.
   * If a string is passed, the `^` character is prepended and the `$` character is
   * appended to the provided string (if not already present), and the resulting regular
   * expression is used to test the values.
   *
   * @returns A validator function that returns an error map with the
   * `pattern` property if the validation check fails, otherwise `null`.
   *
   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}
   *
   */
  static pattern(pattern) {
    return patternValidator(pattern);
  }
  /**
   * @description
   * Validator that performs no operation.
   *
   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}
   *
   */
  static nullValidator(control) {
    return nullValidator();
  }
  static compose(validators) {
    return compose(validators);
  }
  /**
   * @description
   * Compose multiple async validators into a single function that returns the union
   * of the individual error objects for the provided control.
   *
   * @returns A validator function that returns an error map with the
   * merged error objects of the async validators if the validation check fails, otherwise `null`.
   *
   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}
   *
   */
  static composeAsync(validators) {
    return composeAsync(validators);
  }
};
function minValidator(min) {
  return (control) => {
    if (control.value == null || min == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min ? {
      "min": {
        "min": min,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max) {
  return (control) => {
    if (control.value == null || max == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max ? {
      "max": {
        "max": max,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length === null || length === 0) {
      return null;
    }
    return length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length !== null && length > maxLength) {
      return {
        "maxlength": {
          "requiredLength": maxLength,
          "actualLength": length
        }
      };
    }
    return null;
  };
}
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^") regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$") regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(value) {
  const obs = isPromise(value) ? from(value) : value;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
var AbstractControlDirective = class {
  /**
   * @description
   * Reports the value of the control if it is present, otherwise null.
   */
  get value() {
    return this.control ? this.control.value : null;
  }
  /**
   * @description
   * Reports whether the control is valid. A control is considered valid if no
   * validation errors exist with the current value.
   * If the control is not present, null is returned.
   */
  get valid() {
    return this.control ? this.control.valid : null;
  }
  /**
   * @description
   * Reports whether the control is invalid, meaning that an error exists in the input value.
   * If the control is not present, null is returned.
   */
  get invalid() {
    return this.control ? this.control.invalid : null;
  }
  /**
   * @description
   * Reports whether a control is pending, meaning that async validation is occurring and
   * errors are not yet available for the input value. If the control is not present, null is
   * returned.
   */
  get pending() {
    return this.control ? this.control.pending : null;
  }
  /**
   * @description
   * Reports whether the control is disabled, meaning that the control is disabled
   * in the UI and is exempt from validation checks and excluded from aggregate
   * values of ancestor controls. If the control is not present, null is returned.
   */
  get disabled() {
    return this.control ? this.control.disabled : null;
  }
  /**
   * @description
   * Reports whether the control is enabled, meaning that the control is included in ancestor
   * calculations of validity or value. If the control is not present, null is returned.
   */
  get enabled() {
    return this.control ? this.control.enabled : null;
  }
  /**
   * @description
   * Reports the control's validation errors. If the control is not present, null is returned.
   */
  get errors() {
    return this.control ? this.control.errors : null;
  }
  /**
   * @description
   * Reports whether the control is pristine, meaning that the user has not yet changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get pristine() {
    return this.control ? this.control.pristine : null;
  }
  /**
   * @description
   * Reports whether the control is dirty, meaning that the user has changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get dirty() {
    return this.control ? this.control.dirty : null;
  }
  /**
   * @description
   * Reports whether the control is touched, meaning that the user has triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get touched() {
    return this.control ? this.control.touched : null;
  }
  /**
   * @description
   * Reports the validation status of the control. Possible values include:
   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
   * If the control is not present, null is returned.
   */
  get status() {
    return this.control ? this.control.status : null;
  }
  /**
   * @description
   * Reports whether the control is untouched, meaning that the user has not yet triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get untouched() {
    return this.control ? this.control.untouched : null;
  }
  /**
   * @description
   * Returns a multicasting observable that emits a validation status whenever it is
   * calculated for the control. If the control is not present, null is returned.
   */
  get statusChanges() {
    return this.control ? this.control.statusChanges : null;
  }
  /**
   * @description
   * Returns a multicasting observable of value changes for the control that emits every time the
   * value of the control changes in the UI or programmatically.
   * If the control is not present, null is returned.
   */
  get valueChanges() {
    return this.control ? this.control.valueChanges : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return null;
  }
  /**
   * Contains the result of merging synchronous validators into a single validator function
   * (combined using `Validators.compose`).
   */
  _composedValidatorFn;
  /**
   * Contains the result of merging asynchronous validators into a single validator function
   * (combined using `Validators.composeAsync`).
   */
  _composedAsyncValidatorFn;
  /**
   * Set of synchronous validators as they were provided while calling `setValidators` function.
   * @internal
   */
  _rawValidators = [];
  /**
   * Set of asynchronous validators as they were provided while calling `setAsyncValidators`
   * function.
   * @internal
   */
  _rawAsyncValidators = [];
  /**
   * Sets synchronous validators for this directive.
   * @internal
   */
  _setValidators(validators) {
    this._rawValidators = validators || [];
    this._composedValidatorFn = composeValidators(this._rawValidators);
  }
  /**
   * Sets asynchronous validators for this directive.
   * @internal
   */
  _setAsyncValidators(validators) {
    this._rawAsyncValidators = validators || [];
    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
  }
  /**
   * @description
   * Synchronous validator function composed of all the synchronous validators registered with this
   * directive.
   */
  get validator() {
    return this._composedValidatorFn || null;
  }
  /**
   * @description
   * Asynchronous validator function composed of all the asynchronous validators registered with
   * this directive.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null;
  }
  /*
   * The set of callbacks to be invoked when directive instance is being destroyed.
   */
  _onDestroyCallbacks = [];
  /**
   * Internal function to register callbacks that should be invoked
   * when directive instance is being destroyed.
   * @internal
   */
  _registerOnDestroy(fn) {
    this._onDestroyCallbacks.push(fn);
  }
  /**
   * Internal function to invoke all registered "on destroy" callbacks.
   * Note: calling this function also clears the list of callbacks.
   * @internal
   */
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach((fn) => fn());
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Resets the control with the provided value if the control is present.
   */
  reset(value = void 0) {
    if (this.control) this.control.reset(value);
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return this.control ? this.control.hasError(errorCode, path) : false;
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    return this.control ? this.control.getError(errorCode, path) : null;
  }
};
var ControlContainer = class extends AbstractControlDirective {
  /**
   * @description
   * The name for the control
   */
  name;
  /**
   * @description
   * The top-level form directive for the control.
   */
  get formDirective() {
    return null;
  }
  /**
   * @description
   * The path to this group.
   */
  get path() {
    return null;
  }
};
var NgControl = class extends AbstractControlDirective {
  /**
   * @description
   * The parent form for the control.
   *
   * @internal
   */
  _parent = null;
  /**
   * @description
   * The name for the control
   */
  name = null;
  /**
   * @description
   * The value accessor for the control
   */
  valueAccessor = null;
};
var AbstractControlStatus = class {
  _cd;
  constructor(cd) {
    this._cd = cd;
  }
  get isTouched() {
    this._cd?.control?._touched?.();
    return !!this._cd?.control?.touched;
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched;
  }
  get isPristine() {
    this._cd?.control?._pristine?.();
    return !!this._cd?.control?.pristine;
  }
  get isDirty() {
    return !!this._cd?.control?.dirty;
  }
  get isValid() {
    this._cd?.control?._status?.();
    return !!this._cd?.control?.valid;
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid;
  }
  get isPending() {
    return !!this._cd?.control?.pending;
  }
  get isSubmitted() {
    this._cd?._submitted?.();
    return !!this._cd?.submitted;
  }
};
var ngControlStatusHost = {
  "[class.ng-untouched]": "isUntouched",
  "[class.ng-touched]": "isTouched",
  "[class.ng-pristine]": "isPristine",
  "[class.ng-dirty]": "isDirty",
  "[class.ng-valid]": "isValid",
  "[class.ng-invalid]": "isInvalid",
  "[class.ng-pending]": "isPending"
};
var ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {
  "[class.ng-submitted]": "isSubmitted"
});
var NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static ɵfac = function NgControlStatus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatus)(ɵɵdirectiveInject(NgControl, 2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgControlStatus,
    selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
    hostVars: 14,
    hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
    type: Directive,
    args: [{
      selector: "[formControlName],[ngModel],[formControl]",
      host: ngControlStatusHost,
      standalone: false
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: Self
    }]
  }], null);
})();
var NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static ɵfac = function NgControlStatusGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatusGroup)(ɵɵdirectiveInject(ControlContainer, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgControlStatusGroup,
    selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
    hostVars: 16,
    hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
    type: Directive,
    args: [{
      selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
      host: ngGroupStatusHost,
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }], null);
})();
var formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
var formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
var formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
var ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
var ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
function controlParentException(nameOrIndex) {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive. You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      ${describeFormControl(nameOrIndex)}

    Example:

    ${formControlNameExample}`);
}
function describeFormControl(nameOrIndex) {
  if (nameOrIndex == null || nameOrIndex === "") {
    return "";
  }
  const valueType = typeof nameOrIndex === "string" ? "name" : "index";
  return `Affected Form Control ${valueType}: "${nameOrIndex}"`;
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
var disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
var asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
var VALID = "VALID";
var INVALID = "INVALID";
var PENDING = "PENDING";
var DISABLED = "DISABLED";
var ControlEvent = class {
};
var ValueChangeEvent = class extends ControlEvent {
  value;
  source;
  constructor(value, source) {
    super();
    this.value = value;
    this.source = source;
  }
};
var PristineChangeEvent = class extends ControlEvent {
  pristine;
  source;
  constructor(pristine, source) {
    super();
    this.pristine = pristine;
    this.source = source;
  }
};
var TouchedChangeEvent = class extends ControlEvent {
  touched;
  source;
  constructor(touched, source) {
    super();
    this.touched = touched;
    this.source = source;
  }
};
var StatusChangeEvent = class extends ControlEvent {
  status;
  source;
  constructor(status, source) {
    super();
    this.status = status;
    this.source = source;
  }
};
var FormSubmittedEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
var FormResetEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
var AbstractControl = class {
  /** @internal */
  _pendingDirty = false;
  /**
   * Indicates that a control has its own pending asynchronous validation in progress.
   * It also stores if the control should emit events when the validation status changes.
   *
   * @internal
   */
  _hasOwnPendingAsyncValidator = null;
  /** @internal */
  _pendingTouched = false;
  /** @internal */
  _onCollectionChange = () => {
  };
  /** @internal */
  _updateOn;
  _parent = null;
  _asyncValidationSubscription;
  /**
   * Contains the result of merging synchronous validators into a single validator function
   * (combined using `Validators.compose`).
   *
   * @internal
   */
  _composedValidatorFn;
  /**
   * Contains the result of merging asynchronous validators into a single validator function
   * (combined using `Validators.composeAsync`).
   *
   * @internal
   */
  _composedAsyncValidatorFn;
  /**
   * Synchronous validators as they were provided:
   *  - in `AbstractControl` constructor
   *  - as an argument while calling `setValidators` function
   *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)
   *
   * @internal
   */
  _rawValidators;
  /**
   * Asynchronous validators as they were provided:
   *  - in `AbstractControl` constructor
   *  - as an argument while calling `setAsyncValidators` function
   *  - while calling the setter on the `asyncValidator` field (e.g. `control.asyncValidator =
   * asyncValidatorFn`)
   *
   * @internal
   */
  _rawAsyncValidators;
  /**
   * The current value of the control.
   *
   * * For a `FormControl`, the current value.
   * * For an enabled `FormGroup`, the values of enabled controls as an object
   * with a key-value pair for each member of the group.
   * * For a disabled `FormGroup`, the values of all controls as an object
   * with a key-value pair for each member of the group.
   * * For a `FormArray`, the values of enabled controls as an array.
   *
   */
  value;
  /**
   * Initialize the AbstractControl instance.
   *
   * @param validators The function or array of functions that is used to determine the validity of
   *     this control synchronously.
   * @param asyncValidators The function or array of functions that is used to determine validity of
   *     this control asynchronously.
   */
  constructor(validators, asyncValidators) {
    this._assignValidators(validators);
    this._assignAsyncValidators(asyncValidators);
  }
  /**
   * Returns the function that is used to determine the validity of this control synchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  /**
   * Returns the function that is used to determine the validity of this control asynchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  /**
   * The parent control.
   */
  get parent() {
    return this._parent;
  }
  /**
   * The validation status of the control.
   *
   * @see {@link FormControlStatus}
   *
   * These status values are mutually exclusive, so a control cannot be
   * both valid AND invalid or invalid AND disabled.
   */
  get status() {
    return untracked(this.statusReactive);
  }
  set status(v) {
    untracked(() => this.statusReactive.set(v));
  }
  /** @internal */
  _status = computed(() => this.statusReactive());
  statusReactive = signal(void 0);
  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid() {
    return this.status === VALID;
  }
  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid() {
    return this.status === INVALID;
  }
  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending() {
    return this.status == PENDING;
  }
  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled() {
    return this.status === DISABLED;
  }
  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   * @see {@link AbstractControl.status}
   *
   */
  get enabled() {
    return this.status !== DISABLED;
  }
  /**
   * An object containing any errors generated by failing validation,
   * or null if there are no errors.
   */
  errors;
  /**
   * A control is `pristine` if the user has not yet changed
   * the value in the UI.
   *
   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get pristine() {
    return untracked(this.pristineReactive);
  }
  set pristine(v) {
    untracked(() => this.pristineReactive.set(v));
  }
  /** @internal */
  _pristine = computed(() => this.pristineReactive());
  pristineReactive = signal(true);
  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty() {
    return !this.pristine;
  }
  /**
   * True if the control is marked as `touched`.
   *
   * A control is marked `touched` once the user has triggered
   * a `blur` event on it.
   */
  get touched() {
    return untracked(this.touchedReactive);
  }
  set touched(v) {
    untracked(() => this.touchedReactive.set(v));
  }
  /** @internal */
  _touched = computed(() => this.touchedReactive());
  touchedReactive = signal(false);
  /**
   * True if the control has not been marked as touched
   *
   * A control is `untouched` if the user has not yet triggered
   * a `blur` event on it.
   */
  get untouched() {
    return !this.touched;
  }
  /**
   * Exposed as observable, see below.
   *
   * @internal
   */
  _events = new Subject();
  /**
   * A multicasting observable that emits an event every time the state of the control changes.
   * It emits for value, status, pristine or touched changes.
   *
   * **Note**: On value change, the emit happens right after a value of this control is updated. The
   * value of a parent control (for example if this FormControl is a part of a FormGroup) is updated
   * later, so accessing a value of a parent control (using the `value` property) from the callback
   * of this event might result in getting a value that has not been updated yet. Subscribe to the
   * `events` of the parent control instead.
   * For other event types, the events are emitted after the parent control has been updated.
   *
   */
  events = this._events.asObservable();
  /**
   * A multicasting observable that emits an event every time the value of the control changes, in
   * the UI or programmatically. It also emits an event each time you call enable() or disable()
   * without passing along {emitEvent: false} as a function argument.
   *
   * **Note**: the emit happens right after a value of this control is updated. The value of a
   * parent control (for example if this FormControl is a part of a FormGroup) is updated later, so
   * accessing a value of a parent control (using the `value` property) from the callback of this
   * event might result in getting a value that has not been updated yet. Subscribe to the
   * `valueChanges` event of the parent control instead.
   */
  valueChanges;
  /**
   * A multicasting observable that emits an event every time the validation `status` of the control
   * recalculates.
   *
   * @see {@link FormControlStatus}
   * @see {@link AbstractControl.status}
   */
  statusChanges;
  /**
   * Reports the update strategy of the `AbstractControl` (meaning
   * the event on which the control updates itself).
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
  }
  /**
   * Sets the synchronous validators that are active on this control.  Calling
   * this overwrites any existing synchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addValidators()` method instead.
   */
  setValidators(validators) {
    this._assignValidators(validators);
  }
  /**
   * Sets the asynchronous validators that are active on this control. Calling this
   * overwrites any existing asynchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addAsyncValidators()` method instead.
   */
  setAsyncValidators(validators) {
    this._assignAsyncValidators(validators);
  }
  /**
   * Add a synchronous validator or validators to this control, without affecting other validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect. If duplicate validator functions
   * are present in the `validators` array, only the first instance would be added to a form
   * control.
   *
   * @param validators The new validator function or functions to add to this control.
   */
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  /**
   * Add an asynchronous validator or validators to this control, without affecting other
   * validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect.
   *
   * @param validators The new asynchronous validator function or functions to add to this control.
   */
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Remove a synchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found,
   * it is ignored.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<string | null>('', Validators.required);
   * ctrl.removeValidators(Validators.required);
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<string | null>('', minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   *
   * ctrl.removeValidators(minValidator);
   * ```
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The validator or validators to remove.
   */
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  /**
   * Remove an asynchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found, it
   * is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The asynchronous validator or validators to remove.
   */
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Check whether a synchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<number | null>(0, Validators.required);
   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<number | null>(0, minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   * ```
   *
   * @param validator The validator to check for presence. Compared by function reference.
   * @returns Whether the provided validator was found on this control.
   */
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  /**
   * Check whether an asynchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The asynchronous validator to check for presence. Compared by function
   *     reference.
   * @returns Whether the provided asynchronous validator was found on this control.
   */
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  /**
   * Empties out the synchronous validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearValidators() {
    this.validator = null;
  }
  /**
   * Empties out the async validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  markAsTouched(opts = {}) {
    const changed = this.touched === false;
    this.touched = true;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(true, sourceControl));
    }
  }
  /**
   * Marks the control and all its descendant controls as `touched`.
   * @see {@link markAsTouched()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `emitEvent`: When true or not supplied (the default), the `events`
   * observable emits a `TouchedChangeEvent` with the `touched` property being `true`.
   * When false, no events are emitted.
   */
  markAllAsTouched(opts = {}) {
    this.markAsTouched({
      onlySelf: true,
      emitEvent: opts.emitEvent,
      sourceControl: this
    });
    this._forEachChild((control) => control.markAllAsTouched(opts));
  }
  markAsUntouched(opts = {}) {
    const changed = this.touched === true;
    this.touched = false;
    this._pendingTouched = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsUntouched({
        onlySelf: true,
        emitEvent: opts.emitEvent,
        sourceControl
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(false, sourceControl));
    }
  }
  markAsDirty(opts = {}) {
    const changed = this.pristine === true;
    this.pristine = false;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(false, sourceControl));
    }
  }
  markAsPristine(opts = {}) {
    const changed = this.pristine === false;
    this.pristine = true;
    this._pendingDirty = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsPristine({
        onlySelf: true,
        emitEvent: opts.emitEvent
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(true, sourceControl));
    }
  }
  markAsPending(opts = {}) {
    this.status = PENDING;
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  disable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild((control) => {
      control.disable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(true));
  }
  /**
   * Enables the control. This means the control is included in validation checks and
   * the aggregate value of its parent. Its status recalculates based on its value and
   * its validators.
   *
   * By default, if the control has children, all children are enabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configure options that control how the control propagates changes and
   * emits events when marked as untouched
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,
   * `valueChanges` and `events`
   * observables emit events with the latest status and value when the control is enabled.
   * When false, no events are emitted.
   */
  enable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild((control) => {
      control.enable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(false));
  }
  _updateAncestors(opts, sourceControl) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine({}, sourceControl);
      }
      this._parent._updateTouched({}, sourceControl);
    }
  }
  /**
   * Sets the parent of the control
   *
   * @param parent The new parent.
   */
  setParent(parent) {
    this._parent = parent;
  }
  /**
   * The raw value of this control. For most control implementations, the raw value will include
   * disabled children.
   */
  getRawValue() {
    return this.value;
  }
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      const shouldHaveEmitted = this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);
      }
    }
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  /** @internal */
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(shouldHaveEmitted, emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = {
        emitEvent: emitEvent !== false
      };
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe((errors) => {
        this._hasOwnPendingAsyncValidator = null;
        this.setErrors(errors, {
          emitEvent,
          shouldHaveEmitted
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      const shouldHaveEmitted = this._hasOwnPendingAsyncValidator?.emitEvent ?? false;
      this._hasOwnPendingAsyncValidator = null;
      return shouldHaveEmitted;
    }
    return false;
  }
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);
  }
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control. If a string is provided, passing it as a string literal will result in improved type
   * information. Likewise, if an array is provided, passing it `as const` will cause improved type
   * information to be available.
   *
   * @usageNotes
   * ### Retrieve a nested control
   *
   * For example, to get a `name` control nested within a `person` sub-group:
   *
   * * `this.form.get('person.name');`
   *
   * -OR-
   *
   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
   *
   * ### Retrieve a control in a FormArray
   *
   * When accessing an element inside a FormArray, you can use an element index.
   * For example, to get a `price` control from the first element in an `items` array you can use:
   *
   * * `this.form.get('items.0.price');`
   *
   * -OR-
   *
   * * `this.form.get(['items', 0, 'price']);`
   */
  get(path) {
    let currPath = path;
    if (currPath == null) return null;
    if (!Array.isArray(currPath)) currPath = currPath.split(".");
    if (currPath.length === 0) return null;
    return currPath.reduce((control, name) => control && control._find(name), this);
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root() {
    let x = this;
    while (x._parent) {
      x = x._parent;
    }
    return x;
  }
  /** @internal */
  _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (emitEvent || shouldHaveEmitted) {
      this._events.next(new StatusChangeEvent(this.status, changedControl));
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);
    }
  }
  /** @internal */
  _initObservables() {
    this.valueChanges = new EventEmitter();
    this.statusChanges = new EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled()) return DISABLED;
    if (this.errors) return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
    if (this._anyControlsHaveStatus(INVALID)) return INVALID;
    return VALID;
  }
  /** @internal */
  _anyControlsHaveStatus(status) {
    return this._anyControls((control) => control.status === status);
  }
  /** @internal */
  _anyControlsDirty() {
    return this._anyControls((control) => control.dirty);
  }
  /** @internal */
  _anyControlsTouched() {
    return this._anyControls((control) => control.touched);
  }
  /** @internal */
  _updatePristine(opts, changedControl) {
    const newPristine = !this._anyControlsDirty();
    const changed = this.pristine !== newPristine;
    this.pristine = newPristine;
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, changedControl);
    }
    if (changed) {
      this._events.next(new PristineChangeEvent(this.pristine, changedControl));
    }
  }
  /** @internal */
  _updateTouched(opts = {}, changedControl) {
    this.touched = this._anyControlsTouched();
    this._events.next(new TouchedChangeEvent(this.touched, changedControl));
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, changedControl);
    }
  }
  /** @internal */
  _onDisabledChange = [];
  /** @internal */
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  /** @internal */
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  /**
   * Check to see if parent has been marked artificially dirty.
   *
   * @internal
   */
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
  /** @internal */
  _find(name) {
    return null;
  }
  /**
   * Internal implementation of the `setValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignValidators(validators) {
    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
  }
  /**
   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignAsyncValidators(validators) {
    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
};
var FormGroup = class extends AbstractControl {
  /**
   * Creates a new `FormGroup` instance.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
      // so we set `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  registerControl(name, control) {
    if (this.controls[name]) return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Remove a control from this group. In a strongly-typed group, required controls cannot be
   * removed.
   *
   * This method also updates the value and validity of the control.
   *
   * @param name The control name to remove from the collection
   * @param options Specifies whether this FormGroup instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeControl(name, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  setControl(name, control, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    if (control) this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  /**
   * Sets the value of the `FormGroup`. It accepts an object that matches
   * the structure of the group, with control names as keys.
   *
   * @usageNotes
   * ### Set the complete value for the form group
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl(),
   *   last: new FormControl()
   * });
   *
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.setValue({first: 'Nancy', last: 'Drew'});
   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
   * ```
   *
   * @throws When strict checks fail, such as setting the value of a control
   * that doesn't exist or if you exclude a value of a control that does exist.
   *
   * @param value The new value for the control that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, true, value);
    Object.keys(value).forEach((name) => {
      assertControlPresent(this, true, name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormGroup`. It accepts an object with control
   * names as keys, and does its best to match the values to the correct controls
   * in the group.
   *
   * It accepts both super-sets and sub-sets of the group without throwing an error.
   *
   * @usageNotes
   * ### Patch the value for a form group
   *
   * ```ts
   * const form = new FormGroup({
   *    first: new FormControl(),
   *    last: new FormControl()
   * });
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.patchValue({first: 'Nancy'});
   * console.log(form.value);   // {first: 'Nancy', last: null}
   * ```
   *
   * @param value The object that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes and
   * emits events after the value is patched.
   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
   * true.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null) return;
    Object.keys(value).forEach((name) => {
      const control = this.controls[name];
      if (control) {
        control.patchValue(
          /* Guaranteed to be present, due to the outer forEach. */
          value[name],
          {
            onlySelf: true,
            emitEvent: options.emitEvent
          }
        );
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
   * the value of all descendants to their default values, or null if no defaults were provided.
   *
   * You reset to a specific form state by passing in a map of states
   * that matches the structure of your form, with control names as keys. The state
   * is a standalone value or a form state object with both a value and a disabled
   * status.
   *
   * @param value Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the group is reset.
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * @usageNotes
   *
   * ### Reset the form group values
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * console.log(form.value);  // {first: 'first name', last: 'last name'}
   *
   * form.reset({ first: 'name', last: 'last name' });
   *
   * console.log(form.value);  // {first: 'name', last: 'last name'}
   * ```
   *
   * ### Reset the form group values and disabled status
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * form.reset({
   *   first: {value: 'name', disabled: true},
   *   last: 'last'
   * });
   *
   * console.log(form.value);  // {last: 'last'}
   * console.log(form.get('first').status);  // 'DISABLED'
   * ```
   */
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value ? value[name] : null, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the `FormGroup`, including any disabled controls.
   *
   * Retrieves all values regardless of disabled status.
   */
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control.getRawValue();
      return acc;
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    Object.keys(this.controls).forEach((key) => {
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this._reduceValue();
  }
  /** @internal */
  _anyControls(condition) {
    for (const [controlName, control] of Object.entries(this.controls)) {
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  /** @internal */
  _reduceValue() {
    let acc = {};
    return this._reduceChildren(acc, (acc2, control, name) => {
      if (control.enabled || this.disabled) {
        acc2[name] = control.value;
      }
      return acc2;
    });
  }
  /** @internal */
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  /** @internal */
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  /** @internal */
  _find(name) {
    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
  }
};
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
var FormRecord = class extends FormGroup {
};
var CALL_SET_DISABLED_STATE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "CallSetDisabledState" : "", {
  providedIn: "root",
  factory: () => setDisabledStateDefault
});
var setDisabledStateDefault = "always";
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control) _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop);
    dir.valueAccessor.registerOnTouched(noop);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop);
  registerOnValidatorChange(dir._rawAsyncValidators, noop);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change") updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== "submit") control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1) return `path: '${path.join(" -> ")}'`;
  if (path?.[0]) return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model")) return false;
  const change = changes["model"];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode)) _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === "never") return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
var formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgForm)
};
var resolvedPromise$1 = (() => Promise.resolve())();
var NgForm = class _NgForm extends ControlContainer {
  callSetDisabledState;
  /**
   * @description
   * Returns whether the form submission has been triggered.
   */
  get submitted() {
    return untracked(this.submittedReactive);
  }
  /** @internal */
  _submitted = computed(() => this.submittedReactive());
  submittedReactive = signal(false);
  _directives = /* @__PURE__ */ new Set();
  /**
   * @description
   * The `FormGroup` instance created for this form.
   */
  form;
  /**
   * @description
   * Event emitter for the "ngSubmit" event
   */
  ngSubmit = new EventEmitter();
  /**
   * @description
   * Tracks options for the `NgForm` instance.
   *
   * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it
   * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.
   * Possible values: `'change'` | `'blur'` | `'submit'`.
   *
   */
  options;
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
  }
  /** @nodoc */
  ngAfterViewInit() {
    this._setUpdateStrategy();
  }
  /**
   * @description
   * The directive instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * The internal `FormGroup` instance.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it is always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Returns a map of the controls in this group.
   */
  get controls() {
    return this.form.controls;
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `NgModel` directive instance.
   */
  addControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      dir.control = container.registerControl(dir.name, dir.control);
      setUpControl(dir.control, dir, this.callSetDisabledState);
      dir.control.updateValueAndValidity({
        emitEvent: false
      });
      this._directives.add(dir);
    });
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `NgModel` directive.
   *
   * @param dir The `NgModel` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `NgModel` instance from the internal list of directives
   *
   * @param dir The `NgModel` directive instance.
   */
  removeControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
      this._directives.delete(dir);
    });
  }
  /**
   * @description
   * Adds a new `NgModelGroup` directive instance to the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  addFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      const group2 = new FormGroup({});
      setUpFormContainer(group2, dir);
      container.registerControl(dir.name, group2);
      group2.updateValueAndValidity({
        emitEvent: false
      });
    });
  }
  /**
   * @description
   * Removes the `NgModelGroup` directive instance from the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  removeFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
    });
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `NgControl` directive.
   *
   * @param dir The `NgControl` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    resolvedPromise$1.then(() => {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    });
  }
  /**
   * @description
   * Sets the value for this `FormGroup`.
   *
   * @param value The new value
   */
  setValue(value) {
    this.control.setValue(value);
  }
  /**
   * @description
   * Method called when the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submittedReactive.set(true);
    syncPendingControls(this.form, this._directives);
    this.ngSubmit.emit($event);
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submittedReactive.set(false);
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.form._updateOn = this.options.updateOn;
    }
  }
  _findContainer(path) {
    path.pop();
    return path.length ? this.form.get(path) : this.form;
  }
  static ɵfac = function NgForm_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgForm)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgForm,
    selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
    hostBindings: function NgForm_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("submit", function NgForm_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function NgForm_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      options: [0, "ngFormOptions", "options"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formDirectiveProvider$1]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
      providers: [formDirectiveProvider$1],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      outputs: ["ngSubmit"],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    options: [{
      type: Input,
      args: ["ngFormOptions"]
    }]
  });
})();
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
var FormControl = class FormControl2 extends AbstractControl {
  /** @publicApi */
  defaultValue = null;
  /** @internal */
  _onChange = [];
  /** @internal */
  _pendingValue;
  /** @internal */
  _pendingChange = false;
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set
      // `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
      if (isFormControlState(formState)) {
        this.defaultValue = formState.value;
      } else {
        this.defaultValue = formState;
      }
    }
  }
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  reset(formState = this.defaultValue, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    this._pendingChange = false;
  }
  /**  @internal */
  _updateValue() {
  }
  /**  @internal */
  _anyControls(condition) {
    return false;
  }
  /**  @internal */
  _allControlsDisabled() {
    return this.disabled;
  }
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  /** @internal */
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  /** @internal */
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  /** @internal */
  _forEachChild(cb) {
  }
  /** @internal */
  _syncPendingControls() {
    if (this.updateOn === "submit") {
      if (this._pendingDirty) this.markAsDirty();
      if (this._pendingTouched) this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (isFormControlState(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
};
var isFormControl = (control) => control instanceof FormControl;
var AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
  /**
   * @description
   * The parent control for the group
   *
   * @internal
   */
  _parent;
  /** @nodoc */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormGroup(this);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormGroup(this);
    }
  }
  /**
   * @description
   * The `FormGroup` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormGroup(this);
  }
  /**
   * @description
   * The path to this group from the top-level directive.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /** @internal */
  _checkParentType() {
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵAbstractFormGroupDirective_BaseFactory;
    return function AbstractFormGroupDirective_Factory(__ngFactoryType__) {
      return (ɵAbstractFormGroupDirective_BaseFactory || (ɵAbstractFormGroupDirective_BaseFactory = ɵɵgetInheritedFactory(_AbstractFormGroupDirective)))(__ngFactoryType__ || _AbstractFormGroupDirective);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _AbstractFormGroupDirective,
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
    type: Directive,
    args: [{
      standalone: false
    }]
  }], null, null);
})();
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
var modelGroupProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgModelGroup)
};
var NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
  /**
   * @description
   * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds
   * to a key in the parent `NgForm`.
   */
  name = "";
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw modelGroupParentException();
    }
  }
  static ɵfac = function NgModelGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModelGroup)(ɵɵdirectiveInject(ControlContainer, 5), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgModelGroup,
    selectors: [["", "ngModelGroup", ""]],
    inputs: {
      name: [0, "ngModelGroup", "name"]
    },
    exportAs: ["ngModelGroup"],
    standalone: false,
    features: [ɵɵProvidersFeature([modelGroupProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
    type: Directive,
    args: [{
      selector: "[ngModelGroup]",
      providers: [modelGroupProvider],
      exportAs: "ngModelGroup",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["ngModelGroup"]
    }]
  });
})();
var formControlBinding$1 = {
  provide: NgControl,
  useExisting: forwardRef(() => NgModel)
};
var resolvedPromise = (() => Promise.resolve())();
var NgModel = class _NgModel extends NgControl {
  _changeDetectorRef;
  callSetDisabledState;
  control = new FormControl();
  // At runtime we coerce arbitrary values assigned to the "disabled" input to a "boolean".
  // This is not reflected in the type of the property because outside of templates, consumers
  // should only deal with booleans. In templates, a string is allowed for convenience and to
  // match the native "disabled attribute" semantics which can be observed on input elements.
  // This static member tells the compiler that values of type "string" can also be assigned
  // to the input in a template.
  /** @nodoc */
  static ngAcceptInputType_isDisabled;
  /** @internal */
  _registered = false;
  /**
   * Internal reference to the view model value.
   * @nodoc
   */
  viewModel;
  /**
   * @description
   * Tracks the name bound to the directive. If a parent form exists, it
   * uses this name as a key to retrieve this control's value.
   */
  name = "";
  /**
   * @description
   * Tracks whether the control is disabled.
   */
  isDisabled;
  /**
   * @description
   * Tracks the value bound to this directive.
   */
  model;
  /**
   * @description
   * Tracks the configuration options for this `ngModel` instance.
   *
   * **name**: An alternative to setting the name attribute on the form control element. See
   * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`
   * as a standalone control.
   *
   * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,
   * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option
   * has no effect.
   *
   * **updateOn**: Defines the event upon which the form control value and validity update.
   * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.
   *
   */
  options;
  /**
   * @description
   * Event emitter for producing the `ngModelChange` event after
   * the view model updates.
   */
  update = new EventEmitter();
  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
    super();
    this._changeDetectorRef = _changeDetectorRef;
    this.callSetDisabledState = callSetDisabledState;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkForErrors();
    if (!this._registered || "name" in changes) {
      if (this._registered) {
        this._checkName();
        if (this.formDirective) {
          const oldName = changes["name"].previousValue;
          this.formDirective.removeControl({
            name: oldName,
            path: this._getPath(oldName)
          });
        }
      }
      this._setUpControl();
    }
    if ("isDisabled" in changes) {
      this._updateDisabled(changes);
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      this._updateValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this.formDirective && this.formDirective.removeControl(this);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return this._getPath(this.name);
  }
  /**
   * @description
   * The top-level directive for this control if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value emitted by `ngModelChange`.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _setUpControl() {
    this._setUpdateStrategy();
    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
    this._registered = true;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.control._updateOn = this.options.updateOn;
    }
  }
  _isStandalone() {
    return !this._parent || !!(this.options && this.options.standalone);
  }
  _setUpStandalone() {
    setUpControl(this.control, this, this.callSetDisabledState);
    this.control.updateValueAndValidity({
      emitEvent: false
    });
  }
  _checkForErrors() {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._isStandalone()) {
      checkParentType$1(this._parent);
    }
    this._checkName();
  }
  _checkName() {
    if (this.options && this.options.name) this.name = this.options.name;
    if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingNameException();
    }
  }
  _updateValue(value) {
    resolvedPromise.then(() => {
      this.control.setValue(value, {
        emitViewToModelChange: false
      });
      this._changeDetectorRef?.markForCheck();
    });
  }
  _updateDisabled(changes) {
    const disabledValue = changes["isDisabled"].currentValue;
    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
    resolvedPromise.then(() => {
      if (isDisabled && !this.control.disabled) {
        this.control.disable();
      } else if (!isDisabled && this.control.disabled) {
        this.control.enable();
      }
      this._changeDetectorRef?.markForCheck();
    });
  }
  _getPath(controlName) {
    return this._parent ? controlPath(controlName, this._parent) : [controlName];
  }
  static ɵfac = function NgModel_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModel)(ɵɵdirectiveInject(ControlContainer, 9), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(ChangeDetectorRef, 8), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgModel,
    selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
    inputs: {
      name: "name",
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"],
      options: [0, "ngModelOptions", "options"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngModel"],
    standalone: false,
    features: [ɵɵProvidersFeature([formControlBinding$1]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
    type: Directive,
    args: [{
      selector: "[ngModel]:not([formControlName]):not([formControl])",
      providers: [formControlBinding$1],
      exportAs: "ngModel",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: ChangeDetectorRef,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ChangeDetectorRef]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    name: [{
      type: Input
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    options: [{
      type: Input,
      args: ["ngModelOptions"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
function checkParentType$1(parent) {
  if (!(parent instanceof NgModelGroup) && parent instanceof AbstractFormGroupDirective) {
    throw formGroupNameException();
  } else if (!(parent instanceof NgModelGroup) && !(parent instanceof NgForm)) {
    throw modelParentException();
  }
}
var ɵNgNoValidate = class _ɵNgNoValidate {
  static ɵfac = function ɵNgNoValidate_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵNgNoValidate)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ɵNgNoValidate,
    selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
    hostAttrs: ["novalidate", ""],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵNgNoValidate, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([ngNativeValidate])",
      host: {
        "novalidate": ""
      },
      standalone: false
    }]
  }], null, null);
})();
var NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => NumberValueAccessor),
  multi: true
};
var NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵNumberValueAccessor_BaseFactory;
    return function NumberValueAccessor_Factory(__ngFactoryType__) {
      return (ɵNumberValueAccessor_BaseFactory || (ɵNumberValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_NumberValueAccessor)))(__ngFactoryType__ || _NumberValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _NumberValueAccessor,
    selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
    hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([NUMBER_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
      host: {
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [NUMBER_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
var RadioControlRegistry = class _RadioControlRegistry {
  _accessors = [];
  /**
   * @description
   * Adds a control to the internal registry. For internal use only.
   */
  add(control, accessor) {
    this._accessors.push([control, accessor]);
  }
  /**
   * @description
   * Removes a control from the internal registry. For internal use only.
   */
  remove(accessor) {
    for (let i = this._accessors.length - 1; i >= 0; --i) {
      if (this._accessors[i][1] === accessor) {
        this._accessors.splice(i, 1);
        return;
      }
    }
  }
  /**
   * @description
   * Selects a radio button. For internal use only.
   */
  select(accessor) {
    this._accessors.forEach((c) => {
      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
        c[1].fireUncheck(accessor.value);
      }
    });
  }
  _isSameGroup(controlPair, accessor) {
    if (!controlPair[0].control) return false;
    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
  }
  static ɵfac = function RadioControlRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlRegistry)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _RadioControlRegistry,
    factory: _RadioControlRegistry.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
  _registry;
  _injector;
  /** @internal */
  _state;
  /** @internal */
  _control;
  /** @internal */
  _fn;
  setDisabledStateFired = false;
  /**
   * The registered callback function called when a change event occurs on the input element.
   * Note: we declare `onChange` here (also used as host listener) as a function with no arguments
   * to override the `onChange` function (which expects 1 argument) in the parent
   * `BaseControlValueAccessor` class.
   * @nodoc
   */
  onChange = () => {
  };
  /**
   * @description
   * Tracks the name of the radio input element.
   */
  name;
  /**
   * @description
   * Tracks the name of the `FormControl` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   */
  formControlName;
  /**
   * @description
   * Tracks the value of the radio input element
   */
  value;
  callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {
    optional: true
  }) ?? setDisabledStateDefault;
  constructor(renderer, elementRef, _registry, _injector) {
    super(renderer, elementRef);
    this._registry = _registry;
    this._injector = _injector;
  }
  /** @nodoc */
  ngOnInit() {
    this._control = this._injector.get(NgControl);
    this._checkName();
    this._registry.add(this._control, this);
  }
  /** @nodoc */
  ngOnDestroy() {
    this._registry.remove(this);
  }
  /**
   * Sets the "checked" property value on the radio input element.
   * @nodoc
   */
  writeValue(value) {
    this._state = value === this.value;
    this.setProperty("checked", this._state);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this._fn = fn;
    this.onChange = () => {
      fn(this.value);
      this._registry.select(this);
    };
  }
  /** @nodoc */
  setDisabledState(isDisabled) {
    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
      this.setProperty("disabled", isDisabled);
    }
    this.setDisabledStateFired = true;
  }
  /**
   * Sets the "value" on the radio input element and unchecks it.
   *
   * @param value
   */
  fireUncheck(value) {
    this.writeValue(value);
  }
  _checkName() {
    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwNameError();
    }
    if (!this.name && this.formControlName) this.name = this.formControlName;
  }
  static ɵfac = function RadioControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(RadioControlRegistry), ɵɵdirectiveInject(Injector));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RadioControlValueAccessor,
    selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
    hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
          return ctx.onChange();
        })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      name: "name",
      formControlName: "formControlName",
      value: "value"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([RADIO_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
      host: {
        "(change)": "onChange()",
        "(blur)": "onTouched()"
      },
      providers: [RADIO_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: RadioControlRegistry
  }, {
    type: Injector
  }], {
    name: [{
      type: Input
    }],
    formControlName: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RangeValueAccessor),
  multi: true
};
var RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("value", parseFloat(value));
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRangeValueAccessor_BaseFactory;
    return function RangeValueAccessor_Factory(__ngFactoryType__) {
      return (ɵRangeValueAccessor_BaseFactory || (ɵRangeValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_RangeValueAccessor)))(__ngFactoryType__ || _RangeValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RangeValueAccessor,
    selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
    hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([RANGE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [RANGE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(ngDevMode ? "NgModelWithFormControlWarning" : "");
var formControlBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlDirective)
};
var FormControlDirective = class _FormControlDirective extends NgControl {
  _ngModelWarningConfig;
  callSetDisabledState;
  /**
   * Internal reference to the view model value.
   * @nodoc
   */
  viewModel;
  /**
   * @description
   * Tracks the `FormControl` instance bound to the directive.
   */
  form;
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  // TODO(kara): remove next 4 properties once deprecation period is over
  /** @deprecated as of v6 */
  model;
  /** @deprecated as of v6 */
  update = new EventEmitter();
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlDirective. Used to support warning config of "once".
   *
   * @internal
   */
  static _ngModelWarningSentOnce = false;
  /**
   * @description
   * Instance property used to track whether an ngModel warning has been sent out for this
   * particular `FormControlDirective` instance. Used to support warning config of "always".
   *
   * @internal
   */
  _ngModelWarningSent = false;
  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._isControlChanged(changes)) {
      const previousForm = changes["form"].previousValue;
      if (previousForm) {
        cleanUpControl(
          previousForm,
          this,
          /* validateControlPresenceOnChange */
          false
        );
      }
      setUpControl(this.form, this, this.callSetDisabledState);
      this.form.updateValueAndValidity({
        emitEvent: false
      });
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
      }
      this.form.setValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpControl(
        this.form,
        this,
        /* validateControlPresenceOnChange */
        false
      );
    }
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * The `FormControl` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _isControlChanged(changes) {
    return changes.hasOwnProperty("form");
  }
  static ɵfac = function FormControlDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlDirective)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormControlDirective,
    selectors: [["", "formControl", ""]],
    inputs: {
      form: [0, "formControl", "form"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formControlBinding]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
    type: Directive,
    args: [{
      selector: "[formControl]",
      providers: [formControlBinding],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formControl"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupDirective)
};
var FormGroupDirective = class _FormGroupDirective extends ControlContainer {
  callSetDisabledState;
  /**
   * @description
   * Reports whether the form submission has been triggered.
   */
  get submitted() {
    return untracked(this._submittedReactive);
  }
  // TODO(atscott): Remove once invalid API usage is cleaned up internally
  set submitted(value) {
    this._submittedReactive.set(value);
  }
  /** @internal */
  _submitted = computed(() => this._submittedReactive());
  _submittedReactive = signal(false);
  /**
   * Reference to an old form group input value, which is needed to cleanup
   * old instance in case it was replaced with a new one.
   */
  _oldForm;
  /**
   * Callback that should be invoked when controls in FormGroup or FormArray collection change
   * (added or removed). This callback triggers corresponding DOM updates.
   */
  _onCollectionChange = () => this._updateDomValue();
  /**
   * @description
   * Tracks the list of added `FormControlName` instances
   */
  directives = [];
  /**
   * @description
   * Tracks the `FormGroup` bound to this directive.
   */
  form = null;
  /**
   * @description
   * Emits an event when the form submission has been triggered.
   */
  ngSubmit = new EventEmitter();
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !this.form) {
      throw missingFormException();
    }
    if (changes.hasOwnProperty("form")) {
      this._updateValidators();
      this._updateDomValue();
      this._updateRegistrations();
      this._oldForm = this.form;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpValidators(this.form, this);
      if (this.form._onCollectionChange === this._onCollectionChange) {
        this.form._registerOnCollectionChange(() => {
        });
      }
    }
  }
  /**
   * @description
   * Returns this directive's instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * Returns the `FormGroup` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `FormControlName` directive instance.
   */
  addControl(dir) {
    const ctrl = this.form.get(dir.path);
    setUpControl(ctrl, dir, this.callSetDisabledState);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
    this.directives.push(dir);
    return ctrl;
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `FormControlName` directive
   *
   * @param dir The `FormControlName` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `FormControlName` instance from the internal list of directives
   *
   * @param dir The `FormControlName` directive instance.
   */
  removeControl(dir) {
    cleanUpControl(
      dir.control || null,
      dir,
      /* validateControlPresenceOnChange */
      false
    );
    removeListItem$1(this.directives, dir);
  }
  /**
   * Adds a new `FormGroupName` directive instance to the form.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  addFormGroup(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  removeFormGroup(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
   *
   * @param dir The `FormGroupName` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  addFormArray(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  removeFormArray(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  getFormArray(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `FormControlName` directive.
   *
   * @param dir The `FormControlName` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    const ctrl = this.form.get(dir.path);
    ctrl.setValue(value);
  }
  /**
   * @description
   * Method called with the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this._submittedReactive.set(true);
    syncPendingControls(this.form, this.directives);
    this.ngSubmit.emit($event);
    this.form._events.next(new FormSubmittedEvent(this.control));
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this._submittedReactive.set(false);
    this.form._events.next(new FormResetEvent(this.form));
  }
  /** @internal */
  _updateDomValue() {
    this.directives.forEach((dir) => {
      const oldCtrl = dir.control;
      const newCtrl = this.form.get(dir.path);
      if (oldCtrl !== newCtrl) {
        cleanUpControl(oldCtrl || null, dir);
        if (isFormControl(newCtrl)) {
          setUpControl(newCtrl, dir, this.callSetDisabledState);
          dir.control = newCtrl;
        }
      }
    });
    this.form._updateTreeValidity({
      emitEvent: false
    });
  }
  _setUpFormContainer(dir) {
    const ctrl = this.form.get(dir.path);
    setUpFormContainer(ctrl, dir);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
  }
  _cleanUpFormContainer(dir) {
    if (this.form) {
      const ctrl = this.form.get(dir.path);
      if (ctrl) {
        const isControlUpdated = cleanUpFormContainer(ctrl, dir);
        if (isControlUpdated) {
          ctrl.updateValueAndValidity({
            emitEvent: false
          });
        }
      }
    }
  }
  _updateRegistrations() {
    this.form._registerOnCollectionChange(this._onCollectionChange);
    if (this._oldForm) {
      this._oldForm._registerOnCollectionChange(() => {
      });
    }
  }
  _updateValidators() {
    setUpValidators(this.form, this);
    if (this._oldForm) {
      cleanUpValidators(this._oldForm, this);
    }
  }
  static ɵfac = function FormGroupDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormGroupDirective)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormGroupDirective,
    selectors: [["", "formGroup", ""]],
    hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function FormGroupDirective_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      form: [0, "formGroup", "form"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formDirectiveProvider]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[formGroup]",
      providers: [formDirectiveProvider],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formGroup"]
    }],
    ngSubmit: [{
      type: Output
    }]
  });
})();
var formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupName)
};
var FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
  /**
   * @description
   * Tracks the name of the `FormGroup` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form groups to be bound
   * to indices when iterating over groups in a `FormArray`.
   */
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw groupParentException();
    }
  }
  static ɵfac = function FormGroupName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormGroupName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormGroupName,
    selectors: [["", "formGroupName", ""]],
    inputs: {
      name: [0, "formGroupName", "name"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([formGroupNameProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
    type: Directive,
    args: [{
      selector: "[formGroupName]",
      providers: [formGroupNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formGroupName"]
    }]
  });
})();
var formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormArrayName)
};
var FormArrayName = class _FormArrayName extends ControlContainer {
  /** @internal */
  _parent;
  /**
   * @description
   * Tracks the name of the `FormArray` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form arrays to be bound
   * to indices when iterating over arrays in a `FormArray`.
   */
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /**
   * A lifecycle method called when the directive's inputs are initialized. For internal use only.
   * @throws If the directive does not have a valid parent.
   * @nodoc
   */
  ngOnInit() {
    if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw arrayParentException();
    }
    this.formDirective.addFormArray(this);
  }
  /**
   * A lifecycle method called before the directive's instance is destroyed. For internal use only.
   * @nodoc
   */
  ngOnDestroy() {
    this.formDirective?.removeFormArray(this);
  }
  /**
   * @description
   * The `FormArray` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormArray(this);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  static ɵfac = function FormArrayName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormArrayName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormArrayName,
    selectors: [["", "formArrayName", ""]],
    inputs: {
      name: [0, "formArrayName", "name"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([formArrayNameProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
    type: Directive,
    args: [{
      selector: "[formArrayName]",
      providers: [formArrayNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formArrayName"]
    }]
  });
})();
function hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}
var controlNameBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlName)
};
var FormControlName = class _FormControlName extends NgControl {
  _ngModelWarningConfig;
  _added = false;
  /**
   * Internal reference to the view model value.
   * @internal
   */
  viewModel;
  /**
   * @description
   * Tracks the `FormControl` instance bound to the directive.
   */
  control;
  /**
   * @description
   * Tracks the name of the `FormControl` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form controls to be bound
   * to indices when iterating over controls in a `FormArray`.
   */
  name = null;
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  // TODO(kara): remove next 4 properties once deprecation period is over
  /** @deprecated as of v6 */
  model;
  /** @deprecated as of v6 */
  update = new EventEmitter();
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlName. Used to support warning config of "once".
   *
   * @internal
   */
  static _ngModelWarningSentOnce = false;
  /**
   * @description
   * Instance property used to track whether an ngModel warning has been sent out for this
   * particular FormControlName instance. Used to support warning config of "always".
   *
   * @internal
   */
  _ngModelWarningSent = false;
  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (!this._added) this._setUpControl();
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
      }
      this.viewModel = this.model;
      this.formDirective.updateModel(this, this.model);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeControl(this);
    }
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _setUpControl() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      checkParentType(this._parent, this.name);
    }
    this.control = this.formDirective.addControl(this);
    this._added = true;
  }
  static ɵfac = function FormControlName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormControlName,
    selectors: [["", "formControlName", ""]],
    inputs: {
      name: [0, "formControlName", "name"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([controlNameBinding]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
    type: Directive,
    args: [{
      selector: "[formControlName]",
      providers: [controlNameBinding],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formControlName"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
function checkParentType(parent, name) {
  if (!(parent instanceof FormGroupName) && parent instanceof AbstractFormGroupDirective) {
    throw ngModelGroupException();
  } else if (!(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName)) {
    throw controlParentException(name);
  }
}
var SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null) return `${value}`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
var SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
  /** @nodoc */
  value;
  /** @internal */
  _optionMap = /* @__PURE__ */ new Map();
  /** @internal */
  _idCounter = 0;
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  /**
   * Sets the "value" property on the select element.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    const id = this._getOptionId(value);
    const valueString = _buildValueString$1(id, value);
    this.setProperty("value", valueString);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (valueString) => {
      this.value = this._getOptionValue(valueString);
      fn(this.value);
    };
  }
  /** @internal */
  _registerOption() {
    return (this._idCounter++).toString();
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id), value)) return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId$1(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSelectControlValueAccessor_BaseFactory;
    return function SelectControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵSelectControlValueAccessor_BaseFactory || (ɵSelectControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_SelectControlValueAccessor)))(__ngFactoryType__ || _SelectControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SelectControlValueAccessor,
    selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
    hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([SELECT_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var NgSelectOption = class _NgSelectOption {
  _element;
  _renderer;
  _select;
  /**
   * @description
   * ID of the option element
   */
  id;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) this.id = this._select._registerOption();
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null) return;
    this._select._optionMap.set(this.id, value);
    this._setElementValue(_buildValueString$1(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    this._setElementValue(value);
    if (this._select) this._select.writeValue(this._select.value);
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static ɵfac = function NgSelectOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgSelectOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(SelectControlValueAccessor, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgSelectOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
var SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null) return `${value}`;
  if (typeof value === "string") value = `'${value}'`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
var SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * The current value.
   * @nodoc
   */
  value;
  /** @internal */
  _optionMap = /* @__PURE__ */ new Map();
  /** @internal */
  _idCounter = 0;
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  /**
   * Sets the "value" property on one or of more of the select's options.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    let optionSelectedStateSetter;
    if (Array.isArray(value)) {
      const ids = value.map((v) => this._getOptionId(v));
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(ids.indexOf(o.toString()) > -1);
      };
    } else {
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(false);
      };
    }
    this._optionMap.forEach(optionSelectedStateSetter);
  }
  /**
   * Registers a function called when the control value changes
   * and writes an array of the selected options.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (element) => {
      const selected = [];
      const selectedOptions = element.selectedOptions;
      if (selectedOptions !== void 0) {
        const options = selectedOptions;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          const val = this._getOptionValue(opt.value);
          selected.push(val);
        }
      } else {
        const options = element.options;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          if (opt.selected) {
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
      }
      this.value = selected;
      fn(selected);
    };
  }
  /** @internal */
  _registerOption(value) {
    const id = (this._idCounter++).toString();
    this._optionMap.set(id, value);
    return id;
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id)._value, value)) return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSelectMultipleControlValueAccessor_BaseFactory;
    return function SelectMultipleControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵSelectMultipleControlValueAccessor_BaseFactory || (ɵSelectMultipleControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_SelectMultipleControlValueAccessor)))(__ngFactoryType__ || _SelectMultipleControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SelectMultipleControlValueAccessor,
    selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
    hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target);
        })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
      host: {
        "(change)": "onChange($event.target)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var ɵNgSelectMultipleOption = class _ɵNgSelectMultipleOption {
  _element;
  _renderer;
  _select;
  id;
  /** @internal */
  _value;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) {
      this.id = this._select._registerOption(this);
    }
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null) return;
    this._value = value;
    this._setElementValue(_buildValueString(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    if (this._select) {
      this._value = value;
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    } else {
      this._setElementValue(value);
    }
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @internal */
  _setSelected(selected) {
    this._renderer.setProperty(this._element.nativeElement, "selected", selected);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static ɵfac = function ɵNgSelectMultipleOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵNgSelectMultipleOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(SelectMultipleControlValueAccessor, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ɵNgSelectMultipleOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵNgSelectMultipleOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectMultipleControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
var AbstractValidatorDirective = class _AbstractValidatorDirective {
  _validator = nullValidator;
  _onChange;
  /**
   * A flag that tracks whether this validator is enabled.
   *
   * Marking it `internal` (vs `protected`), so that this flag can be used in host bindings of
   * directive classes that extend this base class.
   * @internal
   */
  _enabled;
  /** @nodoc */
  ngOnChanges(changes) {
    if (this.inputName in changes) {
      const input = this.normalizeInput(changes[this.inputName].currentValue);
      this._enabled = this.enabled(input);
      this._validator = this._enabled ? this.createValidator(input) : nullValidator;
      if (this._onChange) {
        this._onChange();
      }
    }
  }
  /** @nodoc */
  validate(control) {
    return this._validator(control);
  }
  /** @nodoc */
  registerOnValidatorChange(fn) {
    this._onChange = fn;
  }
  /**
   * @description
   * Determines whether this validator should be active or not based on an input.
   * Base class implementation checks whether an input is defined (if the value is different from
   * `null` and `undefined`). Validator classes that extend this base class can override this
   * function with the logic specific to a particular validator directive.
   */
  enabled(input) {
    return input != null;
  }
  static ɵfac = function AbstractValidatorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AbstractValidatorDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AbstractValidatorDirective,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
    type: Directive
  }], null, null);
})();
var MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxValidator),
  multi: true
};
var MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the max bound to this directive.
   */
  max;
  /** @internal */
  inputName = "max";
  /** @internal */
  normalizeInput = (input) => toFloat(input);
  /** @internal */
  createValidator = (max) => maxValidator(max);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMaxValidator_BaseFactory;
    return function MaxValidator_Factory(__ngFactoryType__) {
      return (ɵMaxValidator_BaseFactory || (ɵMaxValidator_BaseFactory = ɵɵgetInheritedFactory(_MaxValidator)))(__ngFactoryType__ || _MaxValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MaxValidator,
    selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("max", ctx._enabled ? ctx.max : null);
      }
    },
    inputs: {
      max: "max"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MAX_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
      providers: [MAX_VALIDATOR],
      host: {
        "[attr.max]": "_enabled ? max : null"
      },
      standalone: false
    }]
  }], null, {
    max: [{
      type: Input
    }]
  });
})();
var MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinValidator),
  multi: true
};
var MinValidator = class _MinValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the min bound to this directive.
   */
  min;
  /** @internal */
  inputName = "min";
  /** @internal */
  normalizeInput = (input) => toFloat(input);
  /** @internal */
  createValidator = (min) => minValidator(min);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMinValidator_BaseFactory;
    return function MinValidator_Factory(__ngFactoryType__) {
      return (ɵMinValidator_BaseFactory || (ɵMinValidator_BaseFactory = ɵɵgetInheritedFactory(_MinValidator)))(__ngFactoryType__ || _MinValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MinValidator,
    selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("min", ctx._enabled ? ctx.min : null);
      }
    },
    inputs: {
      min: "min"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MIN_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
      providers: [MIN_VALIDATOR],
      host: {
        "[attr.min]": "_enabled ? min : null"
      },
      standalone: false
    }]
  }], null, {
    min: [{
      type: Input
    }]
  });
})();
var REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => RequiredValidator),
  multi: true
};
var CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CheckboxRequiredValidator),
  multi: true
};
var RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the required attribute bound to this directive.
   */
  required;
  /** @internal */
  inputName = "required";
  /** @internal */
  normalizeInput = booleanAttribute;
  /** @internal */
  createValidator = (input) => requiredValidator;
  /** @nodoc */
  enabled(input) {
    return input;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRequiredValidator_BaseFactory;
    return function RequiredValidator_Factory(__ngFactoryType__) {
      return (ɵRequiredValidator_BaseFactory || (ɵRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(_RequiredValidator)))(__ngFactoryType__ || _RequiredValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RequiredValidator,
    selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
    hostVars: 1,
    hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("required", ctx._enabled ? "" : null);
      }
    },
    inputs: {
      required: "required"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
    type: Directive,
    args: [{
      selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
      providers: [REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, {
    required: [{
      type: Input
    }]
  });
})();
var CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
  /** @internal */
  createValidator = (input) => requiredTrueValidator;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCheckboxRequiredValidator_BaseFactory;
    return function CheckboxRequiredValidator_Factory(__ngFactoryType__) {
      return (ɵCheckboxRequiredValidator_BaseFactory || (ɵCheckboxRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(_CheckboxRequiredValidator)))(__ngFactoryType__ || _CheckboxRequiredValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _CheckboxRequiredValidator,
    selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("required", ctx._enabled ? "" : null);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
      providers: [CHECKBOX_REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, null);
})();
var EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => EmailValidator),
  multi: true
};
var EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the email attribute bound to this directive.
   */
  email;
  /** @internal */
  inputName = "email";
  /** @internal */
  normalizeInput = booleanAttribute;
  /** @internal */
  createValidator = (input) => emailValidator;
  /** @nodoc */
  enabled(input) {
    return input;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵEmailValidator_BaseFactory;
    return function EmailValidator_Factory(__ngFactoryType__) {
      return (ɵEmailValidator_BaseFactory || (ɵEmailValidator_BaseFactory = ɵɵgetInheritedFactory(_EmailValidator)))(__ngFactoryType__ || _EmailValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _EmailValidator,
    selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
    inputs: {
      email: "email"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([EMAIL_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
    type: Directive,
    args: [{
      selector: "[email][formControlName],[email][formControl],[email][ngModel]",
      providers: [EMAIL_VALIDATOR],
      standalone: false
    }]
  }], null, {
    email: [{
      type: Input
    }]
  });
})();
var MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinLengthValidator),
  multi: true
};
var MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the minimum length bound to this directive.
   */
  minlength;
  /** @internal */
  inputName = "minlength";
  /** @internal */
  normalizeInput = (input) => toInteger(input);
  /** @internal */
  createValidator = (minlength) => minLengthValidator(minlength);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMinLengthValidator_BaseFactory;
    return function MinLengthValidator_Factory(__ngFactoryType__) {
      return (ɵMinLengthValidator_BaseFactory || (ɵMinLengthValidator_BaseFactory = ɵɵgetInheritedFactory(_MinLengthValidator)))(__ngFactoryType__ || _MinLengthValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MinLengthValidator,
    selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("minlength", ctx._enabled ? ctx.minlength : null);
      }
    },
    inputs: {
      minlength: "minlength"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MIN_LENGTH_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
      providers: [MIN_LENGTH_VALIDATOR],
      host: {
        "[attr.minlength]": "_enabled ? minlength : null"
      },
      standalone: false
    }]
  }], null, {
    minlength: [{
      type: Input
    }]
  });
})();
var MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxLengthValidator),
  multi: true
};
var MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the maximum length bound to this directive.
   */
  maxlength;
  /** @internal */
  inputName = "maxlength";
  /** @internal */
  normalizeInput = (input) => toInteger(input);
  /** @internal */
  createValidator = (maxlength) => maxLengthValidator(maxlength);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMaxLengthValidator_BaseFactory;
    return function MaxLengthValidator_Factory(__ngFactoryType__) {
      return (ɵMaxLengthValidator_BaseFactory || (ɵMaxLengthValidator_BaseFactory = ɵɵgetInheritedFactory(_MaxLengthValidator)))(__ngFactoryType__ || _MaxLengthValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MaxLengthValidator,
    selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("maxlength", ctx._enabled ? ctx.maxlength : null);
      }
    },
    inputs: {
      maxlength: "maxlength"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MAX_LENGTH_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
      providers: [MAX_LENGTH_VALIDATOR],
      host: {
        "[attr.maxlength]": "_enabled ? maxlength : null"
      },
      standalone: false
    }]
  }], null, {
    maxlength: [{
      type: Input
    }]
  });
})();
var PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => PatternValidator),
  multi: true
};
var PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the pattern bound to this directive.
   */
  pattern;
  // This input is always defined, since the name matches selector.
  /** @internal */
  inputName = "pattern";
  /** @internal */
  normalizeInput = (input) => input;
  /** @internal */
  createValidator = (input) => patternValidator(input);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPatternValidator_BaseFactory;
    return function PatternValidator_Factory(__ngFactoryType__) {
      return (ɵPatternValidator_BaseFactory || (ɵPatternValidator_BaseFactory = ɵɵgetInheritedFactory(_PatternValidator)))(__ngFactoryType__ || _PatternValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _PatternValidator,
    selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function PatternValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("pattern", ctx._enabled ? ctx.pattern : null);
      }
    },
    inputs: {
      pattern: "pattern"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PATTERN_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
    type: Directive,
    args: [{
      selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
      providers: [PATTERN_VALIDATOR],
      host: {
        "[attr.pattern]": "_enabled ? pattern : null"
      },
      standalone: false
    }]
  }], null, {
    pattern: [{
      type: Input
    }]
  });
})();
var SHARED_FORM_DIRECTIVES = [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
var ɵInternalFormsSharedModule = class _ɵInternalFormsSharedModule {
  static ɵfac = function ɵInternalFormsSharedModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵInternalFormsSharedModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ɵInternalFormsSharedModule,
    declarations: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator],
    exports: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵInternalFormsSharedModule, [{
    type: NgModule,
    args: [{
      declarations: SHARED_FORM_DIRECTIVES,
      exports: SHARED_FORM_DIRECTIVES
    }]
  }], null, null);
})();
var FormArray = class extends AbstractControl {
  /**
   * Creates a new `FormArray` instance.
   *
   * @param controls An array of child controls. Each child control is given an index
   * where it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
   *     around from the back, and if index is greatly negative (less than `-length`), the result is
   * undefined. This behavior is the same as `Array.at(index)`.
   */
  at(index) {
    return this.controls[this._adjustIndex(index)];
  }
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  push(control, options = {}) {
    this.controls.push(control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
   * This behavior is the same as `Array.splice(index, 0, control)`.
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is inserted.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  insert(index, control, options = {}) {
    this.controls.splice(index, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control.  If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), removes the first
   *     element. This behavior is the same as `Array.splice(index, 1)`.
   * @param options Specifies whether this FormArray instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeAt(index, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
   *     element. This behavior is the same as `Array.splice(index, 1, control)`.
   * @param control The `AbstractControl` control to replace the existing control
   * @param options Specifies whether this FormArray instance should emit events after an
   *     existing control is replaced with a new one.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(index, control, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    if (control) {
      this.controls.splice(adjustedIndex, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Length of the control array.
   */
  get length() {
    return this.controls.length;
  }
  /**
   * Sets the value of the `FormArray`. It accepts an array that matches
   * the structure of the control.
   *
   * This method performs strict checks, and throws an error if you try
   * to set the value of a control that doesn't exist or if you exclude the
   * value of a control.
   *
   * @usageNotes
   * ### Set the values for the controls in the form array
   *
   * ```ts
   * const arr = new FormArray([
   *   new FormControl(),
   *   new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.setValue(['Nancy', 'Drew']);
   * console.log(arr.value);   // ['Nancy', 'Drew']
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, false, value);
    value.forEach((newValue, index) => {
      assertControlPresent(this, false, index);
      this.at(index).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormArray`. It accepts an array that matches the
   * structure of the control, and does its best to match the values to the correct
   * controls in the group.
   *
   * It accepts both super-sets and sub-sets of the array without throwing an error.
   *
   * @usageNotes
   * ### Patch the values for controls in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.patchValue(['Nancy']);
   * console.log(arr.value);   // ['Nancy', null]
   * ```
   *
   * @param value Array of latest values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control
   * value is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null) return;
    value.forEach((newValue, index) => {
      if (this.at(index)) {
        this.at(index).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
   * value of all descendants to null or null maps.
   *
   * You reset to a specific form state by passing in an array of states
   * that matches the structure of the control. The state is a standalone value
   * or a form state object with both a value and a disabled status.
   *
   * @usageNotes
   * ### Reset the values in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * arr.reset(['name', 'last name']);
   *
   * console.log(arr.value);  // ['name', 'last name']
   * ```
   *
   * ### Reset the values in a form array and the disabled status for the first control
   *
   * ```ts
   * arr.reset([
   *   {value: 'name', disabled: true},
   *   'last'
   * ]);
   *
   * console.log(arr.value);  // ['last']
   * console.log(arr.at(0).status);  // 'DISABLED'
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  reset(value = [], options = {}) {
    this._forEachChild((control, index) => {
      control.reset(value[index], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the array, including any disabled controls.
   *
   * Reports all values regardless of disabled status.
   */
  getRawValue() {
    return this.controls.map((control) => control.getRawValue());
  }
  /**
   * Remove all controls in the `FormArray`.
   *
   * @param options Specifies whether this FormArray instance should emit events after all
   *     controls are removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when all controls
   * in this FormArray instance are removed. When false, no events are emitted.
   *
   * @usageNotes
   * ### Remove all elements from a FormArray
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.length);  // 2
   *
   * arr.clear();
   * console.log(arr.length);  // 0
   * ```
   *
   * It's a simpler and more efficient alternative to removing all elements one by one:
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   *
   * while (arr.length) {
   *    arr.removeAt(0);
   * }
   * ```
   */
  clear(options = {}) {
    if (this.controls.length < 1) return;
    this._forEachChild((control) => control._registerOnCollectionChange(() => {
    }));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Adjusts a negative index by summing it with the length of the array. For very negative
   * indices, the result may remain negative.
   * @internal
   */
  _adjustIndex(index) {
    return index < 0 ? index + this.length : index;
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    this.controls.forEach((control, index) => {
      cb(control, index);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
  }
  /** @internal */
  _anyControls(condition) {
    return this.controls.some((control) => control.enabled && condition(control));
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => this._registerControl(control));
  }
  /** @internal */
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled) return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
  /** @internal */
  _find(name) {
    return this.at(name) ?? null;
  }
};
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var FormBuilder = class _FormBuilder {
  useNonNullable = false;
  /**
   * @description
   * Returns a FormBuilder in which automatically constructed `FormControl` elements
   * have `{nonNullable: true}` and are non-nullable.
   *
   * **Constructing non-nullable controls**
   *
   * When constructing a control, it will be non-nullable, and will reset to its initial value.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.control('Alex'); // FormControl<string>
   * name.reset();
   * console.log(name); // 'Alex'
   * ```
   *
   * **Constructing non-nullable groups or arrays**
   *
   * When constructing a group or array, all automatically created inner controls will be
   * non-nullable, and will reset to their initial values.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
   * name.reset();
   * console.log(name); // {who: 'Alex'}
   * ```
   * **Constructing *nullable* fields on groups or arrays**
   *
   * It is still possible to have a nullable field. In particular, any `FormControl` which is
   * *already* constructed will not be altered. For example:
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * // FormGroup<{who: FormControl<string|null>}>
   * let name = nnfb.group({who: new FormControl('Alex')});
   * name.reset(); console.log(name); // {who: null}
   * ```
   *
   * Because the inner control is constructed explicitly by the caller, the builder has
   * no control over how it is created, and cannot exclude the `null`.
   */
  get nonNullable() {
    const nnfb = new _FormBuilder();
    nnfb.useNonNullable = true;
    return nnfb;
  }
  group(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    let newOptions = {};
    if (isAbstractControlOptions(options)) {
      newOptions = options;
    } else if (options !== null) {
      newOptions.validators = options.validator;
      newOptions.asyncValidators = options.asyncValidator;
    }
    return new FormGroup(reducedControls, newOptions);
  }
  /**
   * @description
   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
   * containing all the keys and corresponding inner control types.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param options Configuration options object for the `FormRecord`. The object should have the
   * `AbstractControlOptions` type and might contain the following fields:
   * * `validators`: A synchronous validator function, or an array of validator functions.
   * * `asyncValidators`: A single async validator or array of async validator functions.
   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
   * | submit').
   */
  record(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    return new FormRecord(reducedControls, options);
  }
  /**
   * @description
   * Constructs a new `FormControl` with the given state, validators and options. Sets
   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
   * control will be nullable. Accepts a single generic argument, which is the type  of the
   * control's value.
   *
   * @param formState Initializes the control with an initial state value, or
   * with an object that contains both a value and a disabled status.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or a `FormControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator
   * functions.
   *
   * @usageNotes
   *
   * ### Initialize a control as disabled
   *
   * The following example returns a control with an initial value in a disabled state.
   *
   * {@example forms/ts/formBuilder/form_builder_example.ts region='disabled-control'}
   */
  control(formState, validatorOrOpts, asyncValidator) {
    let newOptions = {};
    if (!this.useNonNullable) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    if (isAbstractControlOptions(validatorOrOpts)) {
      newOptions = validatorOrOpts;
    } else {
      newOptions.validators = validatorOrOpts;
      newOptions.asyncValidators = asyncValidator;
    }
    return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
      nonNullable: true
    }));
  }
  /**
   * Constructs a new `FormArray` from the given array of configurations,
   * validators and options. Accepts a single generic argument, which is the type of each control
   * inside the array.
   *
   * @param controls An array of child controls or control configs. Each child control is given an
   *     index when it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
   *     `AbstractControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions.
   */
  array(controls, validatorOrOpts, asyncValidator) {
    const createdControls = controls.map((c) => this._createControl(c));
    return new FormArray(createdControls, validatorOrOpts, asyncValidator);
  }
  /** @internal */
  _reduceControls(controls) {
    const createdControls = {};
    Object.keys(controls).forEach((controlName) => {
      createdControls[controlName] = this._createControl(controls[controlName]);
    });
    return createdControls;
  }
  /** @internal */
  _createControl(controls) {
    if (controls instanceof FormControl) {
      return controls;
    } else if (controls instanceof AbstractControl) {
      return controls;
    } else if (Array.isArray(controls)) {
      const value = controls[0];
      const validator = controls.length > 1 ? controls[1] : null;
      const asyncValidator = controls.length > 2 ? controls[2] : null;
      return this.control(value, validator, asyncValidator);
    } else {
      return this.control(controls);
    }
  }
  static ɵfac = function FormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormBuilder)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FormBuilder,
    factory: _FormBuilder.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NonNullableFormBuilder = class _NonNullableFormBuilder {
  static ɵfac = function NonNullableFormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NonNullableFormBuilder)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NonNullableFormBuilder,
    factory: () => (() => inject(FormBuilder).nonNullable)(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(FormBuilder).nonNullable
    }]
  }], null, null);
})();
var UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
  group(controlsConfig, options = null) {
    return super.group(controlsConfig, options);
  }
  /**
   * Like `FormBuilder#control`, except the resulting control is untyped.
   */
  control(formState, validatorOrOpts, asyncValidator) {
    return super.control(formState, validatorOrOpts, asyncValidator);
  }
  /**
   * Like `FormBuilder#array`, except the resulting array is untyped.
   */
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    return super.array(controlsConfig, validatorOrOpts, asyncValidator);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵUntypedFormBuilder_BaseFactory;
    return function UntypedFormBuilder_Factory(__ngFactoryType__) {
      return (ɵUntypedFormBuilder_BaseFactory || (ɵUntypedFormBuilder_BaseFactory = ɵɵgetInheritedFactory(_UntypedFormBuilder)))(__ngFactoryType__ || _UntypedFormBuilder);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({
    token: _UntypedFormBuilder,
    factory: _UntypedFormBuilder.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var VERSION2 = new Version("19.2.7");
var FormsModule = class _FormsModule {
  /**
   * @description
   * Provides options for configuring the forms module.
   *
   * @param opts An object of configuration options
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _FormsModule,
      providers: [{
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static ɵfac = function FormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _FormsModule,
    declarations: [NgModel, NgModelGroup, NgForm],
    exports: [ɵInternalFormsSharedModule, NgModel, NgModelGroup, NgForm]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ɵInternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
    type: NgModule,
    args: [{
      declarations: TEMPLATE_DRIVEN_DIRECTIVES,
      exports: [ɵInternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();
var ReactiveFormsModule = class _ReactiveFormsModule {
  /**
   * @description
   * Provides options for configuring the reactive forms module.
   *
   * @param opts An object of configuration options
   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
   * binding is used with reactive form directives.
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _ReactiveFormsModule,
      providers: [{
        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
        useValue: opts.warnOnNgModelWithFormControl ?? "always"
      }, {
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static ɵfac = function ReactiveFormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ReactiveFormsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ReactiveFormsModule,
    declarations: [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName],
    exports: [ɵInternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ɵInternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
    type: NgModule,
    args: [{
      declarations: [REACTIVE_DRIVEN_DIRECTIVES],
      exports: [ɵInternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/fake-event-detection-D0_6qVp2.mjs
function isFakeMousedownFromScreenReader(event) {
  return event.buttons === 0 || event.detail === 0;
}
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}

// node_modules/@angular/cdk/fesm2022/keycodes-DPWmI2Ix.mjs
var BACKSPACE = 8;
var TAB = 9;
var ENTER = 13;
var SHIFT = 16;
var CONTROL = 17;
var ALT = 18;
var ESCAPE = 27;
var SPACE = 32;
var PAGE_UP = 33;
var PAGE_DOWN = 34;
var END = 35;
var HOME = 36;
var LEFT_ARROW = 37;
var UP_ARROW = 38;
var RIGHT_ARROW = 39;
var DOWN_ARROW = 40;
var DELETE = 46;
var ZERO = 48;
var NINE = 57;
var A = 65;
var Z = 90;
var META = 91;
var MAC_META = 224;

// node_modules/@angular/cdk/fesm2022/shadow-dom-DFvX9W95.mjs
var shadowDomIsSupported;
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
function _getFocusedElementPierceShadowDom() {
  let activeElement = typeof document !== "undefined" && document ? document.activeElement : null;
  while (activeElement && activeElement.shadowRoot) {
    const newActiveElement = activeElement.shadowRoot.activeElement;
    if (newActiveElement === activeElement) {
      break;
    } else {
      activeElement = newActiveElement;
    }
  }
  return activeElement;
}
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}

// node_modules/@angular/cdk/fesm2022/backwards-compatibility-DYuVCOXM.mjs
function _bindEventWithOptions(renderer, target, eventName, callback, options) {
  const major = parseInt(VERSION.major);
  const minor = parseInt(VERSION.minor);
  if (major > 19 || major === 19 && minor > 0 || major === 0 && minor === 0) {
    return renderer.listen(target, eventName, callback, options);
  }
  target.addEventListener(eventName, callback, options);
  return () => {
    target.removeEventListener(eventName, callback, options);
  };
}

// node_modules/@angular/cdk/fesm2022/platform-Do3uqmxu.mjs
var hasV8BreakIterator;
try {
  hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
} catch {
  hasV8BreakIterator = false;
}
var Platform = class _Platform {
  _platformId = inject(PLATFORM_ID);
  // We want to use the Angular platform check because if the Document is shimmed
  // without the navigator, the following checks will fail. This is preferred because
  // sometimes the Document may be shimmed without the user's knowledge or intention
  /** Whether the Angular application is being rendered in the browser. */
  isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : typeof document === "object" && !!document;
  /** Whether the current browser is Microsoft Edge. */
  EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
  /** Whether the current rendering engine is Microsoft Trident. */
  TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
  // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.
  /** Whether the current rendering engine is Blink. */
  BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !this.EDGE && !this.TRIDENT;
  // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
  // ensure that Webkit runs standalone and is not used as another engine's base.
  /** Whether the current rendering engine is WebKit. */
  WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
  /** Whether the current platform is Apple iOS. */
  IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
  // It's difficult to detect the plain Gecko engine, because most of the browsers identify
  // them self as Gecko-like browsers and modify the userAgent's according to that.
  // Since we only cover one explicit Firefox case, we can simply check for Firefox
  // instead of having an unstable check for Gecko.
  /** Whether the current browser is Firefox. */
  FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
  /** Whether the current platform is Android. */
  // Trident on mobile adds the android platform to the userAgent to trick detections.
  ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
  // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
  // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
  // Safari browser should also use Webkit as its layout engine.
  /** Whether the current browser is Safari. */
  SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
  constructor() {
  }
  static ɵfac = function Platform_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Platform)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _Platform,
    factory: _Platform.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Platform, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/passive-listeners-ZmZRMx8D.mjs
var supportsPassiveEvents;
function supportsPassiveEventListeners() {
  if (supportsPassiveEvents == null && typeof window !== "undefined") {
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get: () => supportsPassiveEvents = true
      }));
    } finally {
      supportsPassiveEvents = supportsPassiveEvents || false;
    }
  }
  return supportsPassiveEvents;
}
function normalizePassiveListenerOptions(options) {
  return supportsPassiveEventListeners() ? options : !!options.capture;
}

// node_modules/@angular/cdk/fesm2022/element-CpqV8p-X.mjs
function coerceNumberProperty(value, fallbackValue = 0) {
  if (_isNumberValue(value)) {
    return Number(value);
  }
  return arguments.length === 2 ? fallbackValue : 0;
}
function _isNumberValue(value) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value));
}
function coerceElement(elementOrRef) {
  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;
}

// node_modules/@angular/cdk/fesm2022/focus-monitor-DJ28zFKt.mjs
var INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken("cdk-input-modality-detector-options");
var INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {
  ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT]
};
var TOUCH_BUFFER_MS = 650;
var modalityEventListenerOptions = {
  passive: true,
  capture: true
};
var InputModalityDetector = class _InputModalityDetector {
  _platform = inject(Platform);
  _listenerCleanups;
  /** Emits whenever an input modality is detected. */
  modalityDetected;
  /** Emits when the input modality changes. */
  modalityChanged;
  /** The most recently detected input modality. */
  get mostRecentModality() {
    return this._modality.value;
  }
  /**
   * The most recently detected input modality event target. Is null if no input modality has been
   * detected or if the associated event target is null for some unknown reason.
   */
  _mostRecentTarget = null;
  /** The underlying BehaviorSubject that emits whenever an input modality is detected. */
  _modality = new BehaviorSubject(null);
  /** Options for this InputModalityDetector. */
  _options;
  /**
   * The timestamp of the last touch input modality. Used to determine whether mousedown events
   * should be attributed to mouse or touch.
   */
  _lastTouchMs = 0;
  /**
   * Handles keydown events. Must be an arrow function in order to preserve the context when it gets
   * bound.
   */
  _onKeydown = (event) => {
    if (this._options?.ignoreKeys?.some((keyCode) => keyCode === event.keyCode)) {
      return;
    }
    this._modality.next("keyboard");
    this._mostRecentTarget = _getEventTarget(event);
  };
  /**
   * Handles mousedown events. Must be an arrow function in order to preserve the context when it
   * gets bound.
   */
  _onMousedown = (event) => {
    if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {
      return;
    }
    this._modality.next(isFakeMousedownFromScreenReader(event) ? "keyboard" : "mouse");
    this._mostRecentTarget = _getEventTarget(event);
  };
  /**
   * Handles touchstart events. Must be an arrow function in order to preserve the context when it
   * gets bound.
   */
  _onTouchstart = (event) => {
    if (isFakeTouchstartFromScreenReader(event)) {
      this._modality.next("keyboard");
      return;
    }
    this._lastTouchMs = Date.now();
    this._modality.next("touch");
    this._mostRecentTarget = _getEventTarget(event);
  };
  constructor() {
    const ngZone = inject(NgZone);
    const document2 = inject(DOCUMENT);
    const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, {
      optional: true
    });
    this._options = __spreadValues(__spreadValues({}, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS), options);
    this.modalityDetected = this._modality.pipe(skip(1));
    this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());
    if (this._platform.isBrowser) {
      const renderer = inject(RendererFactory2).createRenderer(null, null);
      this._listenerCleanups = ngZone.runOutsideAngular(() => {
        return [_bindEventWithOptions(renderer, document2, "keydown", this._onKeydown, modalityEventListenerOptions), _bindEventWithOptions(renderer, document2, "mousedown", this._onMousedown, modalityEventListenerOptions), _bindEventWithOptions(renderer, document2, "touchstart", this._onTouchstart, modalityEventListenerOptions)];
      });
    }
  }
  ngOnDestroy() {
    this._modality.complete();
    this._listenerCleanups?.forEach((cleanup) => cleanup());
  }
  static ɵfac = function InputModalityDetector_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InputModalityDetector)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _InputModalityDetector,
    factory: _InputModalityDetector.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputModalityDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var FocusMonitorDetectionMode;
(function(FocusMonitorDetectionMode2) {
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["IMMEDIATE"] = 0] = "IMMEDIATE";
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["EVENTUAL"] = 1] = "EVENTUAL";
})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));
var FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken("cdk-focus-monitor-default-options");
var captureEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var FocusMonitor = class _FocusMonitor {
  _ngZone = inject(NgZone);
  _platform = inject(Platform);
  _inputModalityDetector = inject(InputModalityDetector);
  /** The focus origin that the next focus event is a result of. */
  _origin = null;
  /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */
  _lastFocusOrigin;
  /** Whether the window has just been focused. */
  _windowFocused = false;
  /** The timeout id of the window focus timeout. */
  _windowFocusTimeoutId;
  /** The timeout id of the origin clearing timeout. */
  _originTimeoutId;
  /**
   * Whether the origin was determined via a touch interaction. Necessary as properly attributing
   * focus events to touch interactions requires special logic.
   */
  _originFromTouchInteraction = false;
  /** Map of elements being monitored to their info. */
  _elementInfo = /* @__PURE__ */ new Map();
  /** The number of elements currently being monitored. */
  _monitoredElementCount = 0;
  /**
   * Keeps track of the root nodes to which we've currently bound a focus/blur handler,
   * as well as the number of monitored elements that they contain. We have to treat focus/blur
   * handlers differently from the rest of the events, because the browser won't emit events
   * to the document when focus moves inside of a shadow root.
   */
  _rootNodeFocusListenerCount = /* @__PURE__ */ new Map();
  /**
   * The specified detection mode, used for attributing the origin of a focus
   * event.
   */
  _detectionMode;
  /**
   * Event listener for `focus` events on the window.
   * Needs to be an arrow function in order to preserve the context when it gets bound.
   */
  _windowFocusListener = () => {
    this._windowFocused = true;
    this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);
  };
  /** Used to reference correct document/window */
  _document = inject(DOCUMENT, {
    optional: true
  });
  /** Subject for stopping our InputModalityDetector subscription. */
  _stopInputModalityDetector = new Subject();
  constructor() {
    const options = inject(FOCUS_MONITOR_DEFAULT_OPTIONS, {
      optional: true
    });
    this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;
  }
  /**
   * Event listener for `focus` and 'blur' events on the document.
   * Needs to be an arrow function in order to preserve the context when it gets bound.
   */
  _rootNodeFocusAndBlurListener = (event) => {
    const target = _getEventTarget(event);
    for (let element = target; element; element = element.parentElement) {
      if (event.type === "focus") {
        this._onFocus(event, element);
      } else {
        this._onBlur(event, element);
      }
    }
  };
  monitor(element, checkChildren = false) {
    const nativeElement = coerceElement(element);
    if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {
      return of();
    }
    const rootNode = _getShadowRoot(nativeElement) || this._getDocument();
    const cachedInfo = this._elementInfo.get(nativeElement);
    if (cachedInfo) {
      if (checkChildren) {
        cachedInfo.checkChildren = true;
      }
      return cachedInfo.subject;
    }
    const info = {
      checkChildren,
      subject: new Subject(),
      rootNode
    };
    this._elementInfo.set(nativeElement, info);
    this._registerGlobalListeners(info);
    return info.subject;
  }
  stopMonitoring(element) {
    const nativeElement = coerceElement(element);
    const elementInfo = this._elementInfo.get(nativeElement);
    if (elementInfo) {
      elementInfo.subject.complete();
      this._setClasses(nativeElement);
      this._elementInfo.delete(nativeElement);
      this._removeGlobalListeners(elementInfo);
    }
  }
  focusVia(element, origin, options) {
    const nativeElement = coerceElement(element);
    const focusedElement = this._getDocument().activeElement;
    if (nativeElement === focusedElement) {
      this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));
    } else {
      this._setOrigin(origin);
      if (typeof nativeElement.focus === "function") {
        nativeElement.focus(options);
      }
    }
  }
  ngOnDestroy() {
    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));
  }
  /** Access injected document if available or fallback to global document reference */
  _getDocument() {
    return this._document || document;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    const doc = this._getDocument();
    return doc.defaultView || window;
  }
  _getFocusOrigin(focusEventTarget) {
    if (this._origin) {
      if (this._originFromTouchInteraction) {
        return this._shouldBeAttributedToTouch(focusEventTarget) ? "touch" : "program";
      } else {
        return this._origin;
      }
    }
    if (this._windowFocused && this._lastFocusOrigin) {
      return this._lastFocusOrigin;
    }
    if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {
      return "mouse";
    }
    return "program";
  }
  /**
   * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a
   * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we
   * handle a focus event following a touch interaction, we need to determine whether (1) the focus
   * event was directly caused by the touch interaction or (2) the focus event was caused by a
   * subsequent programmatic focus call triggered by the touch interaction.
   * @param focusEventTarget The target of the focus event under examination.
   */
  _shouldBeAttributedToTouch(focusEventTarget) {
    return this._detectionMode === FocusMonitorDetectionMode.EVENTUAL || !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget);
  }
  /**
   * Sets the focus classes on the element based on the given focus origin.
   * @param element The element to update the classes on.
   * @param origin The focus origin.
   */
  _setClasses(element, origin) {
    element.classList.toggle("cdk-focused", !!origin);
    element.classList.toggle("cdk-touch-focused", origin === "touch");
    element.classList.toggle("cdk-keyboard-focused", origin === "keyboard");
    element.classList.toggle("cdk-mouse-focused", origin === "mouse");
    element.classList.toggle("cdk-program-focused", origin === "program");
  }
  /**
   * Updates the focus origin. If we're using immediate detection mode, we schedule an async
   * function to clear the origin at the end of a timeout. The duration of the timeout depends on
   * the origin being set.
   * @param origin The origin to set.
   * @param isFromInteraction Whether we are setting the origin from an interaction event.
   */
  _setOrigin(origin, isFromInteraction = false) {
    this._ngZone.runOutsideAngular(() => {
      this._origin = origin;
      this._originFromTouchInteraction = origin === "touch" && isFromInteraction;
      if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {
        clearTimeout(this._originTimeoutId);
        const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;
        this._originTimeoutId = setTimeout(() => this._origin = null, ms);
      }
    });
  }
  /**
   * Handles focus events on a registered element.
   * @param event The focus event.
   * @param element The monitored element.
   */
  _onFocus(event, element) {
    const elementInfo = this._elementInfo.get(element);
    const focusEventTarget = _getEventTarget(event);
    if (!elementInfo || !elementInfo.checkChildren && element !== focusEventTarget) {
      return;
    }
    this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);
  }
  /**
   * Handles blur events on a registered element.
   * @param event The blur event.
   * @param element The monitored element.
   */
  _onBlur(event, element) {
    const elementInfo = this._elementInfo.get(element);
    if (!elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget)) {
      return;
    }
    this._setClasses(element);
    this._emitOrigin(elementInfo, null);
  }
  _emitOrigin(info, origin) {
    if (info.subject.observers.length) {
      this._ngZone.run(() => info.subject.next(origin));
    }
  }
  _registerGlobalListeners(elementInfo) {
    if (!this._platform.isBrowser) {
      return;
    }
    const rootNode = elementInfo.rootNode;
    const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;
    if (!rootNodeFocusListeners) {
      this._ngZone.runOutsideAngular(() => {
        rootNode.addEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.addEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
      });
    }
    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);
    if (++this._monitoredElementCount === 1) {
      this._ngZone.runOutsideAngular(() => {
        const window2 = this._getWindow();
        window2.addEventListener("focus", this._windowFocusListener);
      });
      this._inputModalityDetector.modalityDetected.pipe(takeUntil(this._stopInputModalityDetector)).subscribe((modality) => {
        this._setOrigin(
          modality,
          true
          /* isFromInteraction */
        );
      });
    }
  }
  _removeGlobalListeners(elementInfo) {
    const rootNode = elementInfo.rootNode;
    if (this._rootNodeFocusListenerCount.has(rootNode)) {
      const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);
      if (rootNodeFocusListeners > 1) {
        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);
      } else {
        rootNode.removeEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.removeEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        this._rootNodeFocusListenerCount.delete(rootNode);
      }
    }
    if (!--this._monitoredElementCount) {
      const window2 = this._getWindow();
      window2.removeEventListener("focus", this._windowFocusListener);
      this._stopInputModalityDetector.next();
      clearTimeout(this._windowFocusTimeoutId);
      clearTimeout(this._originTimeoutId);
    }
  }
  /** Updates all the state on an element once its focus origin has changed. */
  _originChanged(element, origin, elementInfo) {
    this._setClasses(element, origin);
    this._emitOrigin(elementInfo, origin);
    this._lastFocusOrigin = origin;
  }
  /**
   * Collects the `MonitoredElementInfo` of a particular element and
   * all of its ancestors that have enabled `checkChildren`.
   * @param element Element from which to start the search.
   */
  _getClosestElementsInfo(element) {
    const results = [];
    this._elementInfo.forEach((info, currentElement) => {
      if (currentElement === element || info.checkChildren && currentElement.contains(element)) {
        results.push([currentElement, info]);
      }
    });
    return results;
  }
  /**
   * Returns whether an interaction is likely to have come from the user clicking the `label` of
   * an `input` or `textarea` in order to focus it.
   * @param focusEventTarget Target currently receiving focus.
   */
  _isLastInteractionFromInputLabel(focusEventTarget) {
    const {
      _mostRecentTarget: mostRecentTarget,
      mostRecentModality
    } = this._inputModalityDetector;
    if (mostRecentModality !== "mouse" || !mostRecentTarget || mostRecentTarget === focusEventTarget || focusEventTarget.nodeName !== "INPUT" && focusEventTarget.nodeName !== "TEXTAREA" || focusEventTarget.disabled) {
      return false;
    }
    const labels = focusEventTarget.labels;
    if (labels) {
      for (let i = 0; i < labels.length; i++) {
        if (labels[i].contains(mostRecentTarget)) {
          return true;
        }
      }
    }
    return false;
  }
  static ɵfac = function FocusMonitor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusMonitor)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusMonitor,
    factory: _FocusMonitor.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusMonitor, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkMonitorFocus = class _CdkMonitorFocus {
  _elementRef = inject(ElementRef);
  _focusMonitor = inject(FocusMonitor);
  _monitorSubscription;
  _focusOrigin = null;
  cdkFocusChange = new EventEmitter();
  constructor() {
  }
  get focusOrigin() {
    return this._focusOrigin;
  }
  ngAfterViewInit() {
    const element = this._elementRef.nativeElement;
    this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute("cdkMonitorSubtreeFocus")).subscribe((origin) => {
      this._focusOrigin = origin;
      this.cdkFocusChange.emit(origin);
    });
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this._elementRef);
    if (this._monitorSubscription) {
      this._monitorSubscription.unsubscribe();
    }
  }
  static ɵfac = function CdkMonitorFocus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkMonitorFocus)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkMonitorFocus,
    selectors: [["", "cdkMonitorElementFocus", ""], ["", "cdkMonitorSubtreeFocus", ""]],
    outputs: {
      cdkFocusChange: "cdkFocusChange"
    },
    exportAs: ["cdkMonitorFocus"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkMonitorFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]",
      exportAs: "cdkMonitorFocus"
    }]
  }], () => [], {
    cdkFocusChange: [{
      type: Output
    }]
  });
})();

// node_modules/@angular/cdk/fesm2022/style-loader-WcmCyO2o.mjs
var appsWithLoaders = /* @__PURE__ */ new WeakMap();
var _CdkPrivateStyleLoader = class __CdkPrivateStyleLoader {
  _appRef;
  _injector = inject(Injector);
  _environmentInjector = inject(EnvironmentInjector);
  /**
   * Loads a set of styles.
   * @param loader Component which will be instantiated to load the styles.
   */
  load(loader) {
    const appRef = this._appRef = this._appRef || this._injector.get(ApplicationRef);
    let data = appsWithLoaders.get(appRef);
    if (!data) {
      data = {
        loaders: /* @__PURE__ */ new Set(),
        refs: []
      };
      appsWithLoaders.set(appRef, data);
      appRef.onDestroy(() => {
        appsWithLoaders.get(appRef)?.refs.forEach((ref) => ref.destroy());
        appsWithLoaders.delete(appRef);
      });
    }
    if (!data.loaders.has(loader)) {
      data.loaders.add(loader);
      data.refs.push(createComponent(loader, {
        environmentInjector: this._environmentInjector
      }));
    }
  }
  static ɵfac = function _CdkPrivateStyleLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __CdkPrivateStyleLoader)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: __CdkPrivateStyleLoader,
    factory: __CdkPrivateStyleLoader.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CdkPrivateStyleLoader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/private.mjs
var _VisuallyHiddenLoader = class __VisuallyHiddenLoader {
  static ɵfac = function _VisuallyHiddenLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __VisuallyHiddenLoader)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: __VisuallyHiddenLoader,
    selectors: [["ng-component"]],
    exportAs: ["cdkVisuallyHidden"],
    decls: 0,
    vars: 0,
    template: function _VisuallyHiddenLoader_Template(rf, ctx) {
    },
    styles: [".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}\n"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_VisuallyHiddenLoader, [{
    type: Component,
    args: [{
      exportAs: "cdkVisuallyHidden",
      encapsulation: ViewEncapsulation.None,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}\n"]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/array-Hg8isvLj.mjs
function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}

// node_modules/@angular/cdk/fesm2022/breakpoints-observer-CHAS_XA1.mjs
var mediaQueriesForWebkitCompatibility = /* @__PURE__ */ new Set();
var mediaQueryStyleNode;
var MediaMatcher = class _MediaMatcher {
  _platform = inject(Platform);
  _nonce = inject(CSP_NONCE, {
    optional: true
  });
  /** The internal matchMedia method to return back a MediaQueryList like object. */
  _matchMedia;
  constructor() {
    this._matchMedia = this._platform.isBrowser && window.matchMedia ? (
      // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
      // call it from a different scope.
      window.matchMedia.bind(window)
    ) : noopMatchMedia;
  }
  /**
   * Evaluates the given media query and returns the native MediaQueryList from which results
   * can be retrieved.
   * Confirms the layout engine will trigger for the selector query provided and returns the
   * MediaQueryList for the query provided.
   */
  matchMedia(query2) {
    if (this._platform.WEBKIT || this._platform.BLINK) {
      createEmptyStyleRule(query2, this._nonce);
    }
    return this._matchMedia(query2);
  }
  static ɵfac = function MediaMatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MediaMatcher)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MediaMatcher,
    factory: _MediaMatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaMatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function createEmptyStyleRule(query2, nonce) {
  if (mediaQueriesForWebkitCompatibility.has(query2)) {
    return;
  }
  try {
    if (!mediaQueryStyleNode) {
      mediaQueryStyleNode = document.createElement("style");
      if (nonce) {
        mediaQueryStyleNode.setAttribute("nonce", nonce);
      }
      mediaQueryStyleNode.setAttribute("type", "text/css");
      document.head.appendChild(mediaQueryStyleNode);
    }
    if (mediaQueryStyleNode.sheet) {
      mediaQueryStyleNode.sheet.insertRule(`@media ${query2} {body{ }}`, 0);
      mediaQueriesForWebkitCompatibility.add(query2);
    }
  } catch (e) {
    console.error(e);
  }
}
function noopMatchMedia(query2) {
  return {
    matches: query2 === "all" || query2 === "",
    media: query2,
    addListener: () => {
    },
    removeListener: () => {
    }
  };
}
var BreakpointObserver = class _BreakpointObserver {
  _mediaMatcher = inject(MediaMatcher);
  _zone = inject(NgZone);
  /**  A map of all media queries currently being listened for. */
  _queries = /* @__PURE__ */ new Map();
  /** A subject for all other observables to takeUntil based on. */
  _destroySubject = new Subject();
  constructor() {
  }
  /** Completes the active subject, signalling to all other observables to complete. */
  ngOnDestroy() {
    this._destroySubject.next();
    this._destroySubject.complete();
  }
  /**
   * Whether one or more media queries match the current viewport size.
   * @param value One or more media queries to check.
   * @returns Whether any of the media queries match.
   */
  isMatched(value) {
    const queries = splitQueries(coerceArray(value));
    return queries.some((mediaQuery) => this._registerQuery(mediaQuery).mql.matches);
  }
  /**
   * Gets an observable of results for the given queries that will emit new results for any changes
   * in matching of the given queries.
   * @param value One or more media queries to check.
   * @returns A stream of matches for the given queries.
   */
  observe(value) {
    const queries = splitQueries(coerceArray(value));
    const observables = queries.map((query2) => this._registerQuery(query2).observable);
    let stateObservable = combineLatest(observables);
    stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));
    return stateObservable.pipe(map((breakpointStates) => {
      const response = {
        matches: false,
        breakpoints: {}
      };
      breakpointStates.forEach(({
        matches,
        query: query2
      }) => {
        response.matches = response.matches || matches;
        response.breakpoints[query2] = matches;
      });
      return response;
    }));
  }
  /** Registers a specific query to be listened for. */
  _registerQuery(query2) {
    if (this._queries.has(query2)) {
      return this._queries.get(query2);
    }
    const mql = this._mediaMatcher.matchMedia(query2);
    const queryObservable = new Observable((observer) => {
      const handler = (e) => this._zone.run(() => observer.next(e));
      mql.addListener(handler);
      return () => {
        mql.removeListener(handler);
      };
    }).pipe(startWith(mql), map(({
      matches
    }) => ({
      query: query2,
      matches
    })), takeUntil(this._destroySubject));
    const output = {
      observable: queryObservable,
      mql
    };
    this._queries.set(query2, output);
    return output;
  }
  static ɵfac = function BreakpointObserver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreakpointObserver)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _BreakpointObserver,
    factory: _BreakpointObserver.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreakpointObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function splitQueries(queries) {
  return queries.map((query2) => query2.split(",")).reduce((a1, a2) => a1.concat(a2)).map((query2) => query2.trim());
}

// node_modules/@angular/cdk/fesm2022/observers.mjs
function shouldIgnoreRecord(record) {
  if (record.type === "characterData" && record.target instanceof Comment) {
    return true;
  }
  if (record.type === "childList") {
    for (let i = 0; i < record.addedNodes.length; i++) {
      if (!(record.addedNodes[i] instanceof Comment)) {
        return false;
      }
    }
    for (let i = 0; i < record.removedNodes.length; i++) {
      if (!(record.removedNodes[i] instanceof Comment)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var MutationObserverFactory = class _MutationObserverFactory {
  create(callback) {
    return typeof MutationObserver === "undefined" ? null : new MutationObserver(callback);
  }
  static ɵfac = function MutationObserverFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MutationObserverFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MutationObserverFactory,
    factory: _MutationObserverFactory.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MutationObserverFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ContentObserver = class _ContentObserver {
  _mutationObserverFactory = inject(MutationObserverFactory);
  /** Keeps track of the existing MutationObservers so they can be reused. */
  _observedElements = /* @__PURE__ */ new Map();
  _ngZone = inject(NgZone);
  constructor() {
  }
  ngOnDestroy() {
    this._observedElements.forEach((_, element) => this._cleanupObserver(element));
  }
  observe(elementOrRef) {
    const element = coerceElement(elementOrRef);
    return new Observable((observer) => {
      const stream = this._observeElement(element);
      const subscription = stream.pipe(map((records) => records.filter((record) => !shouldIgnoreRecord(record))), filter((records) => !!records.length)).subscribe((records) => {
        this._ngZone.run(() => {
          observer.next(records);
        });
      });
      return () => {
        subscription.unsubscribe();
        this._unobserveElement(element);
      };
    });
  }
  /**
   * Observes the given element by using the existing MutationObserver if available, or creating a
   * new one if not.
   */
  _observeElement(element) {
    return this._ngZone.runOutsideAngular(() => {
      if (!this._observedElements.has(element)) {
        const stream = new Subject();
        const observer = this._mutationObserverFactory.create((mutations) => stream.next(mutations));
        if (observer) {
          observer.observe(element, {
            characterData: true,
            childList: true,
            subtree: true
          });
        }
        this._observedElements.set(element, {
          observer,
          stream,
          count: 1
        });
      } else {
        this._observedElements.get(element).count++;
      }
      return this._observedElements.get(element).stream;
    });
  }
  /**
   * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
   * observing this element.
   */
  _unobserveElement(element) {
    if (this._observedElements.has(element)) {
      this._observedElements.get(element).count--;
      if (!this._observedElements.get(element).count) {
        this._cleanupObserver(element);
      }
    }
  }
  /** Clean up the underlying MutationObserver for the specified element. */
  _cleanupObserver(element) {
    if (this._observedElements.has(element)) {
      const {
        observer,
        stream
      } = this._observedElements.get(element);
      if (observer) {
        observer.disconnect();
      }
      stream.complete();
      this._observedElements.delete(element);
    }
  }
  static ɵfac = function ContentObserver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContentObserver)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ContentObserver,
    factory: _ContentObserver.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkObserveContent = class _CdkObserveContent {
  _contentObserver = inject(ContentObserver);
  _elementRef = inject(ElementRef);
  /** Event emitted for each change in the element's content. */
  event = new EventEmitter();
  /**
   * Whether observing content is disabled. This option can be used
   * to disconnect the underlying MutationObserver until it is needed.
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._disabled ? this._unsubscribe() : this._subscribe();
  }
  _disabled = false;
  /** Debounce interval for emitting the changes. */
  get debounce() {
    return this._debounce;
  }
  set debounce(value) {
    this._debounce = coerceNumberProperty(value);
    this._subscribe();
  }
  _debounce;
  _currentSubscription = null;
  constructor() {
  }
  ngAfterContentInit() {
    if (!this._currentSubscription && !this.disabled) {
      this._subscribe();
    }
  }
  ngOnDestroy() {
    this._unsubscribe();
  }
  _subscribe() {
    this._unsubscribe();
    const stream = this._contentObserver.observe(this._elementRef);
    this._currentSubscription = (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);
  }
  _unsubscribe() {
    this._currentSubscription?.unsubscribe();
  }
  static ɵfac = function CdkObserveContent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkObserveContent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkObserveContent,
    selectors: [["", "cdkObserveContent", ""]],
    inputs: {
      disabled: [2, "cdkObserveContentDisabled", "disabled", booleanAttribute],
      debounce: "debounce"
    },
    outputs: {
      event: "cdkObserveContent"
    },
    exportAs: ["cdkObserveContent"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkObserveContent, [{
    type: Directive,
    args: [{
      selector: "[cdkObserveContent]",
      exportAs: "cdkObserveContent"
    }]
  }], () => [], {
    event: [{
      type: Output,
      args: ["cdkObserveContent"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkObserveContentDisabled",
        transform: booleanAttribute
      }]
    }],
    debounce: [{
      type: Input
    }]
  });
})();
var ObserversModule = class _ObserversModule {
  static ɵfac = function ObserversModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ObserversModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ObserversModule,
    imports: [CdkObserveContent],
    exports: [CdkObserveContent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [MutationObserverFactory]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObserversModule, [{
    type: NgModule,
    args: [{
      imports: [CdkObserveContent],
      exports: [CdkObserveContent],
      providers: [MutationObserverFactory]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/a11y-module-CgaSR12u.mjs
var InteractivityChecker = class _InteractivityChecker {
  _platform = inject(Platform);
  constructor() {
  }
  /**
   * Gets whether an element is disabled.
   *
   * @param element Element to be checked.
   * @returns Whether the element is disabled.
   */
  isDisabled(element) {
    return element.hasAttribute("disabled");
  }
  /**
   * Gets whether an element is visible for the purposes of interactivity.
   *
   * This will capture states like `display: none` and `visibility: hidden`, but not things like
   * being clipped by an `overflow: hidden` parent or being outside the viewport.
   *
   * @returns Whether the element is visible.
   */
  isVisible(element) {
    return hasGeometry(element) && getComputedStyle(element).visibility === "visible";
  }
  /**
   * Gets whether an element can be reached via Tab key.
   * Assumes that the element has already been checked with isFocusable.
   *
   * @param element Element to be checked.
   * @returns Whether the element is tabbable.
   */
  isTabbable(element) {
    if (!this._platform.isBrowser) {
      return false;
    }
    const frameElement = getFrameElement(getWindow(element));
    if (frameElement) {
      if (getTabIndexValue(frameElement) === -1) {
        return false;
      }
      if (!this.isVisible(frameElement)) {
        return false;
      }
    }
    let nodeName = element.nodeName.toLowerCase();
    let tabIndexValue = getTabIndexValue(element);
    if (element.hasAttribute("contenteditable")) {
      return tabIndexValue !== -1;
    }
    if (nodeName === "iframe" || nodeName === "object") {
      return false;
    }
    if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
      return false;
    }
    if (nodeName === "audio") {
      if (!element.hasAttribute("controls")) {
        return false;
      }
      return tabIndexValue !== -1;
    }
    if (nodeName === "video") {
      if (tabIndexValue === -1) {
        return false;
      }
      if (tabIndexValue !== null) {
        return true;
      }
      return this._platform.FIREFOX || element.hasAttribute("controls");
    }
    return element.tabIndex >= 0;
  }
  /**
   * Gets whether an element can be focused by the user.
   *
   * @param element Element to be checked.
   * @param config The config object with options to customize this method's behavior
   * @returns Whether the element is focusable.
   */
  isFocusable(element, config) {
    return isPotentiallyFocusable(element) && !this.isDisabled(element) && (config?.ignoreVisibility || this.isVisible(element));
  }
  static ɵfac = function InteractivityChecker_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InteractivityChecker)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _InteractivityChecker,
    factory: _InteractivityChecker.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InteractivityChecker, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function getFrameElement(window2) {
  try {
    return window2.frameElement;
  } catch {
    return null;
  }
}
function hasGeometry(element) {
  return !!(element.offsetWidth || element.offsetHeight || typeof element.getClientRects === "function" && element.getClientRects().length);
}
function isNativeFormElement(element) {
  let nodeName = element.nodeName.toLowerCase();
  return nodeName === "input" || nodeName === "select" || nodeName === "button" || nodeName === "textarea";
}
function isHiddenInput(element) {
  return isInputElement(element) && element.type == "hidden";
}
function isAnchorWithHref(element) {
  return isAnchorElement(element) && element.hasAttribute("href");
}
function isInputElement(element) {
  return element.nodeName.toLowerCase() == "input";
}
function isAnchorElement(element) {
  return element.nodeName.toLowerCase() == "a";
}
function hasValidTabIndex(element) {
  if (!element.hasAttribute("tabindex") || element.tabIndex === void 0) {
    return false;
  }
  let tabIndex = element.getAttribute("tabindex");
  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
}
function getTabIndexValue(element) {
  if (!hasValidTabIndex(element)) {
    return null;
  }
  const tabIndex = parseInt(element.getAttribute("tabindex") || "", 10);
  return isNaN(tabIndex) ? -1 : tabIndex;
}
function isPotentiallyTabbableIOS(element) {
  let nodeName = element.nodeName.toLowerCase();
  let inputType = nodeName === "input" && element.type;
  return inputType === "text" || inputType === "password" || nodeName === "select" || nodeName === "textarea";
}
function isPotentiallyFocusable(element) {
  if (isHiddenInput(element)) {
    return false;
  }
  return isNativeFormElement(element) || isAnchorWithHref(element) || element.hasAttribute("contenteditable") || hasValidTabIndex(element);
}
function getWindow(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || window;
}
var FocusTrap = class {
  _element;
  _checker;
  _ngZone;
  _document;
  _injector;
  _startAnchor;
  _endAnchor;
  _hasAttached = false;
  // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.
  startAnchorListener = () => this.focusLastTabbableElement();
  endAnchorListener = () => this.focusFirstTabbableElement();
  /** Whether the focus trap is active. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(value, this._startAnchor);
      this._toggleAnchorTabIndex(value, this._endAnchor);
    }
  }
  _enabled = true;
  constructor(_element, _checker, _ngZone, _document, deferAnchors = false, _injector) {
    this._element = _element;
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._document = _document;
    this._injector = _injector;
    if (!deferAnchors) {
      this.attachAnchors();
    }
  }
  /** Destroys the focus trap by cleaning up the anchors. */
  destroy() {
    const startAnchor = this._startAnchor;
    const endAnchor = this._endAnchor;
    if (startAnchor) {
      startAnchor.removeEventListener("focus", this.startAnchorListener);
      startAnchor.remove();
    }
    if (endAnchor) {
      endAnchor.removeEventListener("focus", this.endAnchorListener);
      endAnchor.remove();
    }
    this._startAnchor = this._endAnchor = null;
    this._hasAttached = false;
  }
  /**
   * Inserts the anchors into the DOM. This is usually done automatically
   * in the constructor, but can be deferred for cases like directives with `*ngIf`.
   * @returns Whether the focus trap managed to attach successfully. This may not be the case
   * if the target element isn't currently in the DOM.
   */
  attachAnchors() {
    if (this._hasAttached) {
      return true;
    }
    this._ngZone.runOutsideAngular(() => {
      if (!this._startAnchor) {
        this._startAnchor = this._createAnchor();
        this._startAnchor.addEventListener("focus", this.startAnchorListener);
      }
      if (!this._endAnchor) {
        this._endAnchor = this._createAnchor();
        this._endAnchor.addEventListener("focus", this.endAnchorListener);
      }
    });
    if (this._element.parentNode) {
      this._element.parentNode.insertBefore(this._startAnchor, this._element);
      this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);
      this._hasAttached = true;
    }
    return this._hasAttached;
  }
  /**
   * Waits for the zone to stabilize, then focuses the first tabbable element.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusInitialElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusInitialElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the first tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusFirstTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the last tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusLastTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));
    });
  }
  /**
   * Get the specified boundary element of the trapped region.
   * @param bound The boundary to get (start or end of trapped region).
   * @returns The boundary element.
   */
  _getRegionBoundary(bound) {
    const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], [cdkFocusRegion${bound}], [cdk-focus-${bound}]`);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      for (let i = 0; i < markers.length; i++) {
        if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        } else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        }
      }
    }
    if (bound == "start") {
      return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);
    }
    return markers.length ? markers[markers.length - 1] : this._getLastTabbableElement(this._element);
  }
  /**
   * Focuses the element that should be focused when the focus trap is initialized.
   * @returns Whether focus was moved successfully.
   */
  focusInitialElement(options) {
    const redirectToElement = this._element.querySelector(`[cdk-focus-initial], [cdkFocusInitial]`);
    if (redirectToElement) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && redirectToElement.hasAttribute(`cdk-focus-initial`)) {
        console.warn(`Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0`, redirectToElement);
      }
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._checker.isFocusable(redirectToElement)) {
        console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);
      }
      if (!this._checker.isFocusable(redirectToElement)) {
        const focusableChild = this._getFirstTabbableElement(redirectToElement);
        focusableChild?.focus(options);
        return !!focusableChild;
      }
      redirectToElement.focus(options);
      return true;
    }
    return this.focusFirstTabbableElement(options);
  }
  /**
   * Focuses the first tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusFirstTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("start");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Focuses the last tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusLastTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("end");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Checks whether the focus trap has successfully been attached.
   */
  hasAttached() {
    return this._hasAttached;
  }
  /** Get the first tabbable element from a DOM subtree (inclusive). */
  _getFirstTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = 0; i < children.length; i++) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Get the last tabbable element from a DOM subtree (inclusive). */
  _getLastTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = children.length - 1; i >= 0; i--) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Creates an anchor element. */
  _createAnchor() {
    const anchor = this._document.createElement("div");
    this._toggleAnchorTabIndex(this._enabled, anchor);
    anchor.classList.add("cdk-visually-hidden");
    anchor.classList.add("cdk-focus-trap-anchor");
    anchor.setAttribute("aria-hidden", "true");
    return anchor;
  }
  /**
   * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.
   * @param isEnabled Whether the focus trap is enabled.
   * @param anchor Anchor on which to toggle the tabindex.
   */
  _toggleAnchorTabIndex(isEnabled, anchor) {
    isEnabled ? anchor.setAttribute("tabindex", "0") : anchor.removeAttribute("tabindex");
  }
  /**
   * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.
   * @param enabled: Whether the anchors should trap Tab.
   */
  toggleAnchors(enabled) {
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(enabled, this._startAnchor);
      this._toggleAnchorTabIndex(enabled, this._endAnchor);
    }
  }
  /** Executes a function when the zone is stable. */
  _executeOnStable(fn) {
    if (this._injector) {
      afterNextRender(fn, {
        injector: this._injector
      });
    } else {
      setTimeout(fn);
    }
  }
};
var FocusTrapFactory = class _FocusTrapFactory {
  _checker = inject(InteractivityChecker);
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  _injector = inject(Injector);
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
  }
  /**
   * Creates a focus-trapped region around the given element.
   * @param element The element around which focus will be trapped.
   * @param deferCaptureElements Defers the creation of focus-capturing elements to be done
   *     manually by the user.
   * @returns The created focus trap instance.
   */
  create(element, deferCaptureElements = false) {
    return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements, this._injector);
  }
  static ɵfac = function FocusTrapFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusTrapFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusTrapFactory,
    factory: _FocusTrapFactory.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkTrapFocus = class _CdkTrapFocus {
  _elementRef = inject(ElementRef);
  _focusTrapFactory = inject(FocusTrapFactory);
  /** Underlying FocusTrap instance. */
  focusTrap;
  /** Previously focused element to restore focus to upon destroy when using autoCapture. */
  _previouslyFocusedElement = null;
  /** Whether the focus trap is active. */
  get enabled() {
    return this.focusTrap?.enabled || false;
  }
  set enabled(value) {
    if (this.focusTrap) {
      this.focusTrap.enabled = value;
    }
  }
  /**
   * Whether the directive should automatically move focus into the trapped region upon
   * initialization and return focus to the previous activeElement upon destruction.
   */
  autoCapture;
  constructor() {
    const platform = inject(Platform);
    if (platform.isBrowser) {
      this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
    }
  }
  ngOnDestroy() {
    this.focusTrap?.destroy();
    if (this._previouslyFocusedElement) {
      this._previouslyFocusedElement.focus();
      this._previouslyFocusedElement = null;
    }
  }
  ngAfterContentInit() {
    this.focusTrap?.attachAnchors();
    if (this.autoCapture) {
      this._captureFocus();
    }
  }
  ngDoCheck() {
    if (this.focusTrap && !this.focusTrap.hasAttached()) {
      this.focusTrap.attachAnchors();
    }
  }
  ngOnChanges(changes) {
    const autoCaptureChange = changes["autoCapture"];
    if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture && this.focusTrap?.hasAttached()) {
      this._captureFocus();
    }
  }
  _captureFocus() {
    this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();
    this.focusTrap?.focusInitialElementWhenReady();
  }
  static ɵfac = function CdkTrapFocus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTrapFocus)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkTrapFocus,
    selectors: [["", "cdkTrapFocus", ""]],
    inputs: {
      enabled: [2, "cdkTrapFocus", "enabled", booleanAttribute],
      autoCapture: [2, "cdkTrapFocusAutoCapture", "autoCapture", booleanAttribute]
    },
    exportAs: ["cdkTrapFocus"],
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTrapFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkTrapFocus]",
      exportAs: "cdkTrapFocus"
    }]
  }], () => [], {
    enabled: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocus",
        transform: booleanAttribute
      }]
    }],
    autoCapture: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocusAutoCapture",
        transform: booleanAttribute
      }]
    }]
  });
})();
var LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken("liveAnnouncerElement", {
  providedIn: "root",
  factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY
});
function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {
  return null;
}
var LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
var uniqueIds = 0;
var LiveAnnouncer = class _LiveAnnouncer {
  _ngZone = inject(NgZone);
  _defaultOptions = inject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, {
    optional: true
  });
  _liveElement;
  _document = inject(DOCUMENT);
  _previousTimeout;
  _currentPromise;
  _currentResolve;
  constructor() {
    const elementToken = inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, {
      optional: true
    });
    this._liveElement = elementToken || this._createLiveElement();
  }
  announce(message, ...args) {
    const defaultOptions2 = this._defaultOptions;
    let politeness;
    let duration;
    if (args.length === 1 && typeof args[0] === "number") {
      duration = args[0];
    } else {
      [politeness, duration] = args;
    }
    this.clear();
    clearTimeout(this._previousTimeout);
    if (!politeness) {
      politeness = defaultOptions2 && defaultOptions2.politeness ? defaultOptions2.politeness : "polite";
    }
    if (duration == null && defaultOptions2) {
      duration = defaultOptions2.duration;
    }
    this._liveElement.setAttribute("aria-live", politeness);
    if (this._liveElement.id) {
      this._exposeAnnouncerToModals(this._liveElement.id);
    }
    return this._ngZone.runOutsideAngular(() => {
      if (!this._currentPromise) {
        this._currentPromise = new Promise((resolve) => this._currentResolve = resolve);
      }
      clearTimeout(this._previousTimeout);
      this._previousTimeout = setTimeout(() => {
        this._liveElement.textContent = message;
        if (typeof duration === "number") {
          this._previousTimeout = setTimeout(() => this.clear(), duration);
        }
        this._currentResolve?.();
        this._currentPromise = this._currentResolve = void 0;
      }, 100);
      return this._currentPromise;
    });
  }
  /**
   * Clears the current text from the announcer element. Can be used to prevent
   * screen readers from reading the text out again while the user is going
   * through the page landmarks.
   */
  clear() {
    if (this._liveElement) {
      this._liveElement.textContent = "";
    }
  }
  ngOnDestroy() {
    clearTimeout(this._previousTimeout);
    this._liveElement?.remove();
    this._liveElement = null;
    this._currentResolve?.();
    this._currentPromise = this._currentResolve = void 0;
  }
  _createLiveElement() {
    const elementClass = "cdk-live-announcer-element";
    const previousElements = this._document.getElementsByClassName(elementClass);
    const liveEl = this._document.createElement("div");
    for (let i = 0; i < previousElements.length; i++) {
      previousElements[i].remove();
    }
    liveEl.classList.add(elementClass);
    liveEl.classList.add("cdk-visually-hidden");
    liveEl.setAttribute("aria-atomic", "true");
    liveEl.setAttribute("aria-live", "polite");
    liveEl.id = `cdk-live-announcer-${uniqueIds++}`;
    this._document.body.appendChild(liveEl);
    return liveEl;
  }
  /**
   * Some browsers won't expose the accessibility node of the live announcer element if there is an
   * `aria-modal` and the live announcer is outside of it. This method works around the issue by
   * pointing the `aria-owns` of all modals to the live announcer element.
   */
  _exposeAnnouncerToModals(id) {
    const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');
    for (let i = 0; i < modals.length; i++) {
      const modal = modals[i];
      const ariaOwns = modal.getAttribute("aria-owns");
      if (!ariaOwns) {
        modal.setAttribute("aria-owns", id);
      } else if (ariaOwns.indexOf(id) === -1) {
        modal.setAttribute("aria-owns", ariaOwns + " " + id);
      }
    }
  }
  static ɵfac = function LiveAnnouncer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LiveAnnouncer)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _LiveAnnouncer,
    factory: _LiveAnnouncer.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LiveAnnouncer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkAriaLive = class _CdkAriaLive {
  _elementRef = inject(ElementRef);
  _liveAnnouncer = inject(LiveAnnouncer);
  _contentObserver = inject(ContentObserver);
  _ngZone = inject(NgZone);
  /** The aria-live politeness level to use when announcing messages. */
  get politeness() {
    return this._politeness;
  }
  set politeness(value) {
    this._politeness = value === "off" || value === "assertive" ? value : "polite";
    if (this._politeness === "off") {
      if (this._subscription) {
        this._subscription.unsubscribe();
        this._subscription = null;
      }
    } else if (!this._subscription) {
      this._subscription = this._ngZone.runOutsideAngular(() => {
        return this._contentObserver.observe(this._elementRef).subscribe(() => {
          const elementText = this._elementRef.nativeElement.textContent;
          if (elementText !== this._previousAnnouncedText) {
            this._liveAnnouncer.announce(elementText, this._politeness, this.duration);
            this._previousAnnouncedText = elementText;
          }
        });
      });
    }
  }
  _politeness = "polite";
  /** Time in milliseconds after which to clear out the announcer element. */
  duration;
  _previousAnnouncedText;
  _subscription;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._subscription.unsubscribe();
    }
  }
  static ɵfac = function CdkAriaLive_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkAriaLive)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkAriaLive,
    selectors: [["", "cdkAriaLive", ""]],
    inputs: {
      politeness: [0, "cdkAriaLive", "politeness"],
      duration: [0, "cdkAriaLiveDuration", "duration"]
    },
    exportAs: ["cdkAriaLive"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAriaLive, [{
    type: Directive,
    args: [{
      selector: "[cdkAriaLive]",
      exportAs: "cdkAriaLive"
    }]
  }], () => [], {
    politeness: [{
      type: Input,
      args: ["cdkAriaLive"]
    }],
    duration: [{
      type: Input,
      args: ["cdkAriaLiveDuration"]
    }]
  });
})();
var HighContrastMode;
(function(HighContrastMode2) {
  HighContrastMode2[HighContrastMode2["NONE"] = 0] = "NONE";
  HighContrastMode2[HighContrastMode2["BLACK_ON_WHITE"] = 1] = "BLACK_ON_WHITE";
  HighContrastMode2[HighContrastMode2["WHITE_ON_BLACK"] = 2] = "WHITE_ON_BLACK";
})(HighContrastMode || (HighContrastMode = {}));
var BLACK_ON_WHITE_CSS_CLASS = "cdk-high-contrast-black-on-white";
var WHITE_ON_BLACK_CSS_CLASS = "cdk-high-contrast-white-on-black";
var HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = "cdk-high-contrast-active";
var HighContrastModeDetector = class _HighContrastModeDetector {
  _platform = inject(Platform);
  /**
   * Figuring out the high contrast mode and adding the body classes can cause
   * some expensive layouts. This flag is used to ensure that we only do it once.
   */
  _hasCheckedHighContrastMode;
  _document = inject(DOCUMENT);
  _breakpointSubscription;
  constructor() {
    this._breakpointSubscription = inject(BreakpointObserver).observe("(forced-colors: active)").subscribe(() => {
      if (this._hasCheckedHighContrastMode) {
        this._hasCheckedHighContrastMode = false;
        this._applyBodyHighContrastModeCssClasses();
      }
    });
  }
  /** Gets the current high-contrast-mode for the page. */
  getHighContrastMode() {
    if (!this._platform.isBrowser) {
      return HighContrastMode.NONE;
    }
    const testElement = this._document.createElement("div");
    testElement.style.backgroundColor = "rgb(1,2,3)";
    testElement.style.position = "absolute";
    this._document.body.appendChild(testElement);
    const documentWindow = this._document.defaultView || window;
    const computedStyle = documentWindow && documentWindow.getComputedStyle ? documentWindow.getComputedStyle(testElement) : null;
    const computedColor = (computedStyle && computedStyle.backgroundColor || "").replace(/ /g, "");
    testElement.remove();
    switch (computedColor) {
      // Pre Windows 11 dark theme.
      case "rgb(0,0,0)":
      // Windows 11 dark themes.
      case "rgb(45,50,54)":
      case "rgb(32,32,32)":
        return HighContrastMode.WHITE_ON_BLACK;
      // Pre Windows 11 light theme.
      case "rgb(255,255,255)":
      // Windows 11 light theme.
      case "rgb(255,250,239)":
        return HighContrastMode.BLACK_ON_WHITE;
    }
    return HighContrastMode.NONE;
  }
  ngOnDestroy() {
    this._breakpointSubscription.unsubscribe();
  }
  /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */
  _applyBodyHighContrastModeCssClasses() {
    if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {
      const bodyClasses = this._document.body.classList;
      bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      this._hasCheckedHighContrastMode = true;
      const mode = this.getHighContrastMode();
      if (mode === HighContrastMode.BLACK_ON_WHITE) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);
      } else if (mode === HighContrastMode.WHITE_ON_BLACK) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      }
    }
  }
  static ɵfac = function HighContrastModeDetector_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HighContrastModeDetector)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _HighContrastModeDetector,
    factory: _HighContrastModeDetector.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighContrastModeDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var A11yModule = class _A11yModule {
  constructor() {
    inject(HighContrastModeDetector)._applyBodyHighContrastModeCssClasses();
  }
  static ɵfac = function A11yModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _A11yModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _A11yModule,
    imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
    exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ObserversModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(A11yModule, [{
    type: NgModule,
    args: [{
      imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
      exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/id-generator-tlPCNuwi.mjs
var counters = {};
var _IdGenerator = class __IdGenerator {
  _appId = inject(APP_ID);
  /**
   * Generates a unique ID with a specific prefix.
   * @param prefix Prefix to add to the ID.
   */
  getId(prefix) {
    if (this._appId !== "ng") {
      prefix += this._appId;
    }
    if (!counters.hasOwnProperty(prefix)) {
      counters[prefix] = 0;
    }
    return `${prefix}${counters[prefix]++}`;
  }
  static ɵfac = function _IdGenerator_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __IdGenerator)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: __IdGenerator,
    factory: __IdGenerator.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_IdGenerator, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/typeahead-BAa3HZoh.mjs
var DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS = 200;
var Typeahead = class {
  _letterKeyStream = new Subject();
  _items = [];
  _selectedItemIndex = -1;
  /** Buffer for the letters that the user has pressed */
  _pressedLetters = [];
  _skipPredicateFn;
  _selectedItem = new Subject();
  selectedItem = this._selectedItem;
  constructor(initialItems, config) {
    const typeAheadInterval = typeof config?.debounceInterval === "number" ? config.debounceInterval : DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS;
    if (config?.skipPredicate) {
      this._skipPredicateFn = config.skipPredicate;
    }
    if ((typeof ngDevMode === "undefined" || ngDevMode) && initialItems.length && initialItems.some((item) => typeof item.getLabel !== "function")) {
      throw new Error("KeyManager items in typeahead mode must implement the `getLabel` method.");
    }
    this.setItems(initialItems);
    this._setupKeyHandler(typeAheadInterval);
  }
  destroy() {
    this._pressedLetters = [];
    this._letterKeyStream.complete();
    this._selectedItem.complete();
  }
  setCurrentSelectedItemIndex(index) {
    this._selectedItemIndex = index;
  }
  setItems(items) {
    this._items = items;
  }
  handleKey(event) {
    const keyCode = event.keyCode;
    if (event.key && event.key.length === 1) {
      this._letterKeyStream.next(event.key.toLocaleUpperCase());
    } else if (keyCode >= A && keyCode <= Z || keyCode >= ZERO && keyCode <= NINE) {
      this._letterKeyStream.next(String.fromCharCode(keyCode));
    }
  }
  /** Gets whether the user is currently typing into the manager using the typeahead feature. */
  isTyping() {
    return this._pressedLetters.length > 0;
  }
  /** Resets the currently stored sequence of typed letters. */
  reset() {
    this._pressedLetters = [];
  }
  _setupKeyHandler(typeAheadInterval) {
    this._letterKeyStream.pipe(tap((letter) => this._pressedLetters.push(letter)), debounceTime(typeAheadInterval), filter(() => this._pressedLetters.length > 0), map(() => this._pressedLetters.join("").toLocaleUpperCase())).subscribe((inputString) => {
      for (let i = 1; i < this._items.length + 1; i++) {
        const index = (this._selectedItemIndex + i) % this._items.length;
        const item = this._items[index];
        if (!this._skipPredicateFn?.(item) && item.getLabel?.().toLocaleUpperCase().trim().indexOf(inputString) === 0) {
          this._selectedItem.next(item);
          break;
        }
      }
      this._pressedLetters = [];
    });
  }
};

// node_modules/@angular/cdk/fesm2022/keycodes.mjs
function hasModifierKey(event, ...modifiers) {
  if (modifiers.length) {
    return modifiers.some((modifier) => event[modifier]);
  }
  return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;
}

// node_modules/@angular/cdk/fesm2022/list-key-manager-CYBoL_nN.mjs
var ListKeyManager = class {
  _items;
  _activeItemIndex = -1;
  _activeItem = signal(null);
  _wrap = false;
  _typeaheadSubscription = Subscription.EMPTY;
  _itemChangesSubscription;
  _vertical = true;
  _horizontal;
  _allowedModifierKeys = [];
  _homeAndEnd = false;
  _pageUpAndDown = {
    enabled: false,
    delta: 10
  };
  _effectRef;
  _typeahead;
  /**
   * Predicate function that can be used to check whether an item should be skipped
   * by the key manager. By default, disabled items are skipped.
   */
  _skipPredicateFn = (item) => item.disabled;
  constructor(_items, injector) {
    this._items = _items;
    if (_items instanceof QueryList) {
      this._itemChangesSubscription = _items.changes.subscribe((newItems) => this._itemsChanged(newItems.toArray()));
    } else if (isSignal(_items)) {
      if (!injector && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw new Error("ListKeyManager constructed with a signal must receive an injector");
      }
      this._effectRef = effect(() => this._itemsChanged(_items()), {
        injector
      });
    }
  }
  /**
   * Stream that emits any time the TAB key is pressed, so components can react
   * when focus is shifted off of the list.
   */
  tabOut = new Subject();
  /** Stream that emits whenever the active item of the list manager changes. */
  change = new Subject();
  /**
   * Sets the predicate function that determines which items should be skipped by the
   * list key manager.
   * @param predicate Function that determines whether the given item should be skipped.
   */
  skipPredicate(predicate) {
    this._skipPredicateFn = predicate;
    return this;
  }
  /**
   * Configures wrapping mode, which determines whether the active item will wrap to
   * the other end of list when there are no more items in the given direction.
   * @param shouldWrap Whether the list should wrap when reaching the end.
   */
  withWrap(shouldWrap = true) {
    this._wrap = shouldWrap;
    return this;
  }
  /**
   * Configures whether the key manager should be able to move the selection vertically.
   * @param enabled Whether vertical selection should be enabled.
   */
  withVerticalOrientation(enabled = true) {
    this._vertical = enabled;
    return this;
  }
  /**
   * Configures the key manager to move the selection horizontally.
   * Passing in `null` will disable horizontal movement.
   * @param direction Direction in which the selection can be moved.
   */
  withHorizontalOrientation(direction) {
    this._horizontal = direction;
    return this;
  }
  /**
   * Modifier keys which are allowed to be held down and whose default actions will be prevented
   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.
   */
  withAllowedModifierKeys(keys) {
    this._allowedModifierKeys = keys;
    return this;
  }
  /**
   * Turns on typeahead mode which allows users to set the active item by typing.
   * @param debounceInterval Time to wait after the last keystroke before setting the active item.
   */
  withTypeAhead(debounceInterval = 200) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const items2 = this._getItemsArray();
      if (items2.length > 0 && items2.some((item) => typeof item.getLabel !== "function")) {
        throw Error("ListKeyManager items in typeahead mode must implement the `getLabel` method.");
      }
    }
    this._typeaheadSubscription.unsubscribe();
    const items = this._getItemsArray();
    this._typeahead = new Typeahead(items, {
      debounceInterval: typeof debounceInterval === "number" ? debounceInterval : void 0,
      skipPredicate: (item) => this._skipPredicateFn(item)
    });
    this._typeaheadSubscription = this._typeahead.selectedItem.subscribe((item) => {
      this.setActiveItem(item);
    });
    return this;
  }
  /** Cancels the current typeahead sequence. */
  cancelTypeahead() {
    this._typeahead?.reset();
    return this;
  }
  /**
   * Configures the key manager to activate the first and last items
   * respectively when the Home or End key is pressed.
   * @param enabled Whether pressing the Home or End key activates the first/last item.
   */
  withHomeAndEnd(enabled = true) {
    this._homeAndEnd = enabled;
    return this;
  }
  /**
   * Configures the key manager to activate every 10th, configured or first/last element in up/down direction
   * respectively when the Page-Up or Page-Down key is pressed.
   * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.
   * @param delta Whether pressing the Home or End key activates the first/last item.
   */
  withPageUpDown(enabled = true, delta = 10) {
    this._pageUpAndDown = {
      enabled,
      delta
    };
    return this;
  }
  setActiveItem(item) {
    const previousActiveItem = this._activeItem();
    this.updateActiveItem(item);
    if (this._activeItem() !== previousActiveItem) {
      this.change.next(this._activeItemIndex);
    }
  }
  /**
   * Sets the active item depending on the key event passed in.
   * @param event Keyboard event to be used for determining which element should be active.
   */
  onKeydown(event) {
    const keyCode = event.keyCode;
    const modifiers = ["altKey", "ctrlKey", "metaKey", "shiftKey"];
    const isModifierAllowed = modifiers.every((modifier) => {
      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;
    });
    switch (keyCode) {
      case TAB:
        this.tabOut.next();
        return;
      case DOWN_ARROW:
        if (this._vertical && isModifierAllowed) {
          this.setNextItemActive();
          break;
        } else {
          return;
        }
      case UP_ARROW:
        if (this._vertical && isModifierAllowed) {
          this.setPreviousItemActive();
          break;
        } else {
          return;
        }
      case RIGHT_ARROW:
        if (this._horizontal && isModifierAllowed) {
          this._horizontal === "rtl" ? this.setPreviousItemActive() : this.setNextItemActive();
          break;
        } else {
          return;
        }
      case LEFT_ARROW:
        if (this._horizontal && isModifierAllowed) {
          this._horizontal === "rtl" ? this.setNextItemActive() : this.setPreviousItemActive();
          break;
        } else {
          return;
        }
      case HOME:
        if (this._homeAndEnd && isModifierAllowed) {
          this.setFirstItemActive();
          break;
        } else {
          return;
        }
      case END:
        if (this._homeAndEnd && isModifierAllowed) {
          this.setLastItemActive();
          break;
        } else {
          return;
        }
      case PAGE_UP:
        if (this._pageUpAndDown.enabled && isModifierAllowed) {
          const targetIndex = this._activeItemIndex - this._pageUpAndDown.delta;
          this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);
          break;
        } else {
          return;
        }
      case PAGE_DOWN:
        if (this._pageUpAndDown.enabled && isModifierAllowed) {
          const targetIndex = this._activeItemIndex + this._pageUpAndDown.delta;
          const itemsLength = this._getItemsArray().length;
          this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);
          break;
        } else {
          return;
        }
      default:
        if (isModifierAllowed || hasModifierKey(event, "shiftKey")) {
          this._typeahead?.handleKey(event);
        }
        return;
    }
    this._typeahead?.reset();
    event.preventDefault();
  }
  /** Index of the currently active item. */
  get activeItemIndex() {
    return this._activeItemIndex;
  }
  /** The active item. */
  get activeItem() {
    return this._activeItem();
  }
  /** Gets whether the user is currently typing into the manager using the typeahead feature. */
  isTyping() {
    return !!this._typeahead && this._typeahead.isTyping();
  }
  /** Sets the active item to the first enabled item in the list. */
  setFirstItemActive() {
    this._setActiveItemByIndex(0, 1);
  }
  /** Sets the active item to the last enabled item in the list. */
  setLastItemActive() {
    this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);
  }
  /** Sets the active item to the next enabled item in the list. */
  setNextItemActive() {
    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);
  }
  /** Sets the active item to a previous enabled item in the list. */
  setPreviousItemActive() {
    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1);
  }
  updateActiveItem(item) {
    const itemArray = this._getItemsArray();
    const index = typeof item === "number" ? item : itemArray.indexOf(item);
    const activeItem = itemArray[index];
    this._activeItem.set(activeItem == null ? null : activeItem);
    this._activeItemIndex = index;
    this._typeahead?.setCurrentSelectedItemIndex(index);
  }
  /** Cleans up the key manager. */
  destroy() {
    this._typeaheadSubscription.unsubscribe();
    this._itemChangesSubscription?.unsubscribe();
    this._effectRef?.destroy();
    this._typeahead?.destroy();
    this.tabOut.complete();
    this.change.complete();
  }
  /**
   * This method sets the active item, given a list of items and the delta between the
   * currently active item and the new active item. It will calculate differently
   * depending on whether wrap mode is turned on.
   */
  _setActiveItemByDelta(delta) {
    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);
  }
  /**
   * Sets the active item properly given "wrap" mode. In other words, it will continue to move
   * down the list until it finds an item that is not disabled, and it will wrap if it
   * encounters either end of the list.
   */
  _setActiveInWrapMode(delta) {
    const items = this._getItemsArray();
    for (let i = 1; i <= items.length; i++) {
      const index = (this._activeItemIndex + delta * i + items.length) % items.length;
      const item = items[index];
      if (!this._skipPredicateFn(item)) {
        this.setActiveItem(index);
        return;
      }
    }
  }
  /**
   * Sets the active item properly given the default mode. In other words, it will
   * continue to move down the list until it finds an item that is not disabled. If
   * it encounters either end of the list, it will stop and not wrap.
   */
  _setActiveInDefaultMode(delta) {
    this._setActiveItemByIndex(this._activeItemIndex + delta, delta);
  }
  /**
   * Sets the active item to the first enabled item starting at the index specified. If the
   * item is disabled, it will move in the fallbackDelta direction until it either
   * finds an enabled item or encounters the end of the list.
   */
  _setActiveItemByIndex(index, fallbackDelta) {
    const items = this._getItemsArray();
    if (!items[index]) {
      return;
    }
    while (this._skipPredicateFn(items[index])) {
      index += fallbackDelta;
      if (!items[index]) {
        return;
      }
    }
    this.setActiveItem(index);
  }
  /** Returns the items as an array. */
  _getItemsArray() {
    if (isSignal(this._items)) {
      return this._items();
    }
    return this._items instanceof QueryList ? this._items.toArray() : this._items;
  }
  /** Callback for when the items have changed. */
  _itemsChanged(newItems) {
    this._typeahead?.setItems(newItems);
    const activeItem = this._activeItem();
    if (activeItem) {
      const newIndex = newItems.indexOf(activeItem);
      if (newIndex > -1 && newIndex !== this._activeItemIndex) {
        this._activeItemIndex = newIndex;
        this._typeahead?.setCurrentSelectedItemIndex(newIndex);
      }
    }
  }
};

// node_modules/@angular/cdk/fesm2022/activedescendant-key-manager-BYiHZAZc.mjs
var ActiveDescendantKeyManager = class extends ListKeyManager {
  setActiveItem(index) {
    if (this.activeItem) {
      this.activeItem.setInactiveStyles();
    }
    super.setActiveItem(index);
    if (this.activeItem) {
      this.activeItem.setActiveStyles();
    }
  }
};

// node_modules/@angular/cdk/fesm2022/focus-key-manager-DgyxYbV2.mjs
var FocusKeyManager = class extends ListKeyManager {
  _origin = "program";
  /**
   * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.
   * @param origin Focus origin to be used when focusing items.
   */
  setFocusOrigin(origin) {
    this._origin = origin;
    return this;
  }
  setActiveItem(item) {
    super.setActiveItem(item);
    if (this.activeItem) {
      this.activeItem.focus(this._origin);
    }
  }
};

// node_modules/@angular/cdk/fesm2022/coercion/private.mjs
function coerceObservable(data) {
  if (!isObservable(data)) {
    return of(data);
  }
  return data;
}

// node_modules/@angular/cdk/fesm2022/tree-key-manager-DIhQ-v4R.mjs
var TreeKeyManager = class {
  /** The index of the currently active (focused) item. */
  _activeItemIndex = -1;
  /** The currently active (focused) item. */
  _activeItem = null;
  /** Whether or not we activate the item when it's focused. */
  _shouldActivationFollowFocus = false;
  /**
   * The orientation that the tree is laid out in. In `rtl` mode, the behavior of Left and
   * Right arrow are switched.
   */
  _horizontalOrientation = "ltr";
  /**
   * Predicate function that can be used to check whether an item should be skipped
   * by the key manager.
   *
   * The default value for this doesn't skip any elements in order to keep tree items focusable
   * when disabled. This aligns with ARIA guidelines:
   * https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols.
   */
  _skipPredicateFn = (_item) => false;
  /** Function to determine equivalent items. */
  _trackByFn = (item) => item;
  /** Synchronous cache of the items to manage. */
  _items = [];
  _typeahead;
  _typeaheadSubscription = Subscription.EMPTY;
  _hasInitialFocused = false;
  _initializeFocus() {
    if (this._hasInitialFocused || this._items.length === 0) {
      return;
    }
    let activeIndex = 0;
    for (let i = 0; i < this._items.length; i++) {
      if (!this._skipPredicateFn(this._items[i]) && !this._isItemDisabled(this._items[i])) {
        activeIndex = i;
        break;
      }
    }
    const activeItem = this._items[activeIndex];
    if (activeItem.makeFocusable) {
      this._activeItem?.unfocus();
      this._activeItemIndex = activeIndex;
      this._activeItem = activeItem;
      this._typeahead?.setCurrentSelectedItemIndex(activeIndex);
      activeItem.makeFocusable();
    } else {
      this.focusItem(activeIndex);
    }
    this._hasInitialFocused = true;
  }
  /**
   *
   * @param items List of TreeKeyManager options. Can be synchronous or asynchronous.
   * @param config Optional configuration options. By default, use 'ltr' horizontal orientation. By
   * default, do not skip any nodes. By default, key manager only calls `focus` method when items
   * are focused and does not call `activate`. If `typeaheadDefaultInterval` is `true`, use a
   * default interval of 200ms.
   */
  constructor(items, config) {
    if (items instanceof QueryList) {
      this._items = items.toArray();
      items.changes.subscribe((newItems) => {
        this._items = newItems.toArray();
        this._typeahead?.setItems(this._items);
        this._updateActiveItemIndex(this._items);
        this._initializeFocus();
      });
    } else if (isObservable(items)) {
      items.subscribe((newItems) => {
        this._items = newItems;
        this._typeahead?.setItems(newItems);
        this._updateActiveItemIndex(newItems);
        this._initializeFocus();
      });
    } else {
      this._items = items;
      this._initializeFocus();
    }
    if (typeof config.shouldActivationFollowFocus === "boolean") {
      this._shouldActivationFollowFocus = config.shouldActivationFollowFocus;
    }
    if (config.horizontalOrientation) {
      this._horizontalOrientation = config.horizontalOrientation;
    }
    if (config.skipPredicate) {
      this._skipPredicateFn = config.skipPredicate;
    }
    if (config.trackBy) {
      this._trackByFn = config.trackBy;
    }
    if (typeof config.typeAheadDebounceInterval !== "undefined") {
      this._setTypeAhead(config.typeAheadDebounceInterval);
    }
  }
  /** Stream that emits any time the focused item changes. */
  change = new Subject();
  /** Cleans up the key manager. */
  destroy() {
    this._typeaheadSubscription.unsubscribe();
    this._typeahead?.destroy();
    this.change.complete();
  }
  /**
   * Handles a keyboard event on the tree.
   * @param event Keyboard event that represents the user interaction with the tree.
   */
  onKeydown(event) {
    const key = event.key;
    switch (key) {
      case "Tab":
        return;
      case "ArrowDown":
        this._focusNextItem();
        break;
      case "ArrowUp":
        this._focusPreviousItem();
        break;
      case "ArrowRight":
        this._horizontalOrientation === "rtl" ? this._collapseCurrentItem() : this._expandCurrentItem();
        break;
      case "ArrowLeft":
        this._horizontalOrientation === "rtl" ? this._expandCurrentItem() : this._collapseCurrentItem();
        break;
      case "Home":
        this._focusFirstItem();
        break;
      case "End":
        this._focusLastItem();
        break;
      case "Enter":
      case " ":
        this._activateCurrentItem();
        break;
      default:
        if (event.key === "*") {
          this._expandAllItemsAtCurrentItemLevel();
          break;
        }
        this._typeahead?.handleKey(event);
        return;
    }
    this._typeahead?.reset();
    event.preventDefault();
  }
  /** Index of the currently active item. */
  getActiveItemIndex() {
    return this._activeItemIndex;
  }
  /** The currently active item. */
  getActiveItem() {
    return this._activeItem;
  }
  /** Focus the first available item. */
  _focusFirstItem() {
    this.focusItem(this._findNextAvailableItemIndex(-1));
  }
  /** Focus the last available item. */
  _focusLastItem() {
    this.focusItem(this._findPreviousAvailableItemIndex(this._items.length));
  }
  /** Focus the next available item. */
  _focusNextItem() {
    this.focusItem(this._findNextAvailableItemIndex(this._activeItemIndex));
  }
  /** Focus the previous available item. */
  _focusPreviousItem() {
    this.focusItem(this._findPreviousAvailableItemIndex(this._activeItemIndex));
  }
  focusItem(itemOrIndex, options = {}) {
    options.emitChangeEvent ??= true;
    let index = typeof itemOrIndex === "number" ? itemOrIndex : this._items.findIndex((item) => this._trackByFn(item) === this._trackByFn(itemOrIndex));
    if (index < 0 || index >= this._items.length) {
      return;
    }
    const activeItem = this._items[index];
    if (this._activeItem !== null && this._trackByFn(activeItem) === this._trackByFn(this._activeItem)) {
      return;
    }
    const previousActiveItem = this._activeItem;
    this._activeItem = activeItem ?? null;
    this._activeItemIndex = index;
    this._typeahead?.setCurrentSelectedItemIndex(index);
    this._activeItem?.focus();
    previousActiveItem?.unfocus();
    if (options.emitChangeEvent) {
      this.change.next(this._activeItem);
    }
    if (this._shouldActivationFollowFocus) {
      this._activateCurrentItem();
    }
  }
  _updateActiveItemIndex(newItems) {
    const activeItem = this._activeItem;
    if (!activeItem) {
      return;
    }
    const newIndex = newItems.findIndex((item) => this._trackByFn(item) === this._trackByFn(activeItem));
    if (newIndex > -1 && newIndex !== this._activeItemIndex) {
      this._activeItemIndex = newIndex;
      this._typeahead?.setCurrentSelectedItemIndex(newIndex);
    }
  }
  _setTypeAhead(debounceInterval) {
    this._typeahead = new Typeahead(this._items, {
      debounceInterval: typeof debounceInterval === "number" ? debounceInterval : void 0,
      skipPredicate: (item) => this._skipPredicateFn(item)
    });
    this._typeaheadSubscription = this._typeahead.selectedItem.subscribe((item) => {
      this.focusItem(item);
    });
  }
  _findNextAvailableItemIndex(startingIndex) {
    for (let i = startingIndex + 1; i < this._items.length; i++) {
      if (!this._skipPredicateFn(this._items[i])) {
        return i;
      }
    }
    return startingIndex;
  }
  _findPreviousAvailableItemIndex(startingIndex) {
    for (let i = startingIndex - 1; i >= 0; i--) {
      if (!this._skipPredicateFn(this._items[i])) {
        return i;
      }
    }
    return startingIndex;
  }
  /**
   * If the item is already expanded, we collapse the item. Otherwise, we will focus the parent.
   */
  _collapseCurrentItem() {
    if (!this._activeItem) {
      return;
    }
    if (this._isCurrentItemExpanded()) {
      this._activeItem.collapse();
    } else {
      const parent = this._activeItem.getParent();
      if (!parent || this._skipPredicateFn(parent)) {
        return;
      }
      this.focusItem(parent);
    }
  }
  /**
   * If the item is already collapsed, we expand the item. Otherwise, we will focus the first child.
   */
  _expandCurrentItem() {
    if (!this._activeItem) {
      return;
    }
    if (!this._isCurrentItemExpanded()) {
      this._activeItem.expand();
    } else {
      coerceObservable(this._activeItem.getChildren()).pipe(take(1)).subscribe((children) => {
        const firstChild = children.find((child) => !this._skipPredicateFn(child));
        if (!firstChild) {
          return;
        }
        this.focusItem(firstChild);
      });
    }
  }
  _isCurrentItemExpanded() {
    if (!this._activeItem) {
      return false;
    }
    return typeof this._activeItem.isExpanded === "boolean" ? this._activeItem.isExpanded : this._activeItem.isExpanded();
  }
  _isItemDisabled(item) {
    return typeof item.isDisabled === "boolean" ? item.isDisabled : item.isDisabled?.();
  }
  /** For all items that are the same level as the current item, we expand those items. */
  _expandAllItemsAtCurrentItemLevel() {
    if (!this._activeItem) {
      return;
    }
    const parent = this._activeItem.getParent();
    let itemsToExpand;
    if (!parent) {
      itemsToExpand = of(this._items.filter((item) => item.getParent() === null));
    } else {
      itemsToExpand = coerceObservable(parent.getChildren());
    }
    itemsToExpand.pipe(take(1)).subscribe((items) => {
      for (const item of items) {
        item.expand();
      }
    });
  }
  _activateCurrentItem() {
    this._activeItem?.activate();
  }
};
function TREE_KEY_MANAGER_FACTORY() {
  return (items, options) => new TreeKeyManager(items, options);
}
var TREE_KEY_MANAGER = new InjectionToken("tree-key-manager", {
  providedIn: "root",
  factory: TREE_KEY_MANAGER_FACTORY
});

// node_modules/@angular/cdk/fesm2022/a11y.mjs
var ID_DELIMITER = " ";
function addAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  if (ids.some((existingId) => existingId.trim() === id)) {
    return;
  }
  ids.push(id);
  el.setAttribute(attr, ids.join(ID_DELIMITER));
}
function removeAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  const filteredIds = ids.filter((val) => val !== id);
  if (filteredIds.length) {
    el.setAttribute(attr, filteredIds.join(ID_DELIMITER));
  } else {
    el.removeAttribute(attr);
  }
}
function getAriaReferenceIds(el, attr) {
  const attrValue = el.getAttribute(attr);
  return attrValue?.match(/\S+/g) ?? [];
}
var CDK_DESCRIBEDBY_ID_PREFIX = "cdk-describedby-message";
var CDK_DESCRIBEDBY_HOST_ATTRIBUTE = "cdk-describedby-host";
var nextId = 0;
var AriaDescriber = class _AriaDescriber {
  _platform = inject(Platform);
  _document = inject(DOCUMENT);
  /** Map of all registered message elements that have been placed into the document. */
  _messageRegistry = /* @__PURE__ */ new Map();
  /** Container for all registered messages. */
  _messagesContainer = null;
  /** Unique ID for the service. */
  _id = `${nextId++}`;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
    this._id = inject(APP_ID) + "-" + nextId++;
  }
  describe(hostElement, message, role) {
    if (!this._canBeDescribed(hostElement, message)) {
      return;
    }
    const key = getKey(message, role);
    if (typeof message !== "string") {
      setMessageId(message, this._id);
      this._messageRegistry.set(key, {
        messageElement: message,
        referenceCount: 0
      });
    } else if (!this._messageRegistry.has(key)) {
      this._createMessageElement(message, role);
    }
    if (!this._isElementDescribedByMessage(hostElement, key)) {
      this._addMessageReference(hostElement, key);
    }
  }
  removeDescription(hostElement, message, role) {
    if (!message || !this._isElementNode(hostElement)) {
      return;
    }
    const key = getKey(message, role);
    if (this._isElementDescribedByMessage(hostElement, key)) {
      this._removeMessageReference(hostElement, key);
    }
    if (typeof message === "string") {
      const registeredMessage = this._messageRegistry.get(key);
      if (registeredMessage && registeredMessage.referenceCount === 0) {
        this._deleteMessageElement(key);
      }
    }
    if (this._messagesContainer?.childNodes.length === 0) {
      this._messagesContainer.remove();
      this._messagesContainer = null;
    }
  }
  /** Unregisters all created message elements and removes the message container. */
  ngOnDestroy() {
    const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}="${this._id}"]`);
    for (let i = 0; i < describedElements.length; i++) {
      this._removeCdkDescribedByReferenceIds(describedElements[i]);
      describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
    }
    this._messagesContainer?.remove();
    this._messagesContainer = null;
    this._messageRegistry.clear();
  }
  /**
   * Creates a new element in the visually hidden message container element with the message
   * as its content and adds it to the message registry.
   */
  _createMessageElement(message, role) {
    const messageElement = this._document.createElement("div");
    setMessageId(messageElement, this._id);
    messageElement.textContent = message;
    if (role) {
      messageElement.setAttribute("role", role);
    }
    this._createMessagesContainer();
    this._messagesContainer.appendChild(messageElement);
    this._messageRegistry.set(getKey(message, role), {
      messageElement,
      referenceCount: 0
    });
  }
  /** Deletes the message element from the global messages container. */
  _deleteMessageElement(key) {
    this._messageRegistry.get(key)?.messageElement?.remove();
    this._messageRegistry.delete(key);
  }
  /** Creates the global container for all aria-describedby messages. */
  _createMessagesContainer() {
    if (this._messagesContainer) {
      return;
    }
    const containerClassName = "cdk-describedby-message-container";
    const serverContainers = this._document.querySelectorAll(`.${containerClassName}[platform="server"]`);
    for (let i = 0; i < serverContainers.length; i++) {
      serverContainers[i].remove();
    }
    const messagesContainer = this._document.createElement("div");
    messagesContainer.style.visibility = "hidden";
    messagesContainer.classList.add(containerClassName);
    messagesContainer.classList.add("cdk-visually-hidden");
    if (!this._platform.isBrowser) {
      messagesContainer.setAttribute("platform", "server");
    }
    this._document.body.appendChild(messagesContainer);
    this._messagesContainer = messagesContainer;
  }
  /** Removes all cdk-describedby messages that are hosted through the element. */
  _removeCdkDescribedByReferenceIds(element) {
    const originalReferenceIds = getAriaReferenceIds(element, "aria-describedby").filter((id) => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);
    element.setAttribute("aria-describedby", originalReferenceIds.join(" "));
  }
  /**
   * Adds a message reference to the element using aria-describedby and increments the registered
   * message's reference count.
   */
  _addMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    addAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);
    registeredMessage.referenceCount++;
  }
  /**
   * Removes a message reference from the element using aria-describedby
   * and decrements the registered message's reference count.
   */
  _removeMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    registeredMessage.referenceCount--;
    removeAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
  }
  /** Returns true if the element has been described by the provided message ID. */
  _isElementDescribedByMessage(element, key) {
    const referenceIds = getAriaReferenceIds(element, "aria-describedby");
    const registeredMessage = this._messageRegistry.get(key);
    const messageId = registeredMessage && registeredMessage.messageElement.id;
    return !!messageId && referenceIds.indexOf(messageId) != -1;
  }
  /** Determines whether a message can be described on a particular element. */
  _canBeDescribed(element, message) {
    if (!this._isElementNode(element)) {
      return false;
    }
    if (message && typeof message === "object") {
      return true;
    }
    const trimmedMessage = message == null ? "" : `${message}`.trim();
    const ariaLabel = element.getAttribute("aria-label");
    return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;
  }
  /** Checks whether a node is an Element node. */
  _isElementNode(element) {
    return element.nodeType === this._document.ELEMENT_NODE;
  }
  static ɵfac = function AriaDescriber_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AriaDescriber)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AriaDescriber,
    factory: _AriaDescriber.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AriaDescriber, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function getKey(message, role) {
  return typeof message === "string" ? `${role || ""}/${message}` : message;
}
function setMessageId(element, serviceId) {
  if (!element.id) {
    element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;
  }
}
var ConfigurableFocusTrap = class extends FocusTrap {
  _focusTrapManager;
  _inertStrategy;
  /** Whether the FocusTrap is enabled. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._enabled) {
      this._focusTrapManager.register(this);
    } else {
      this._focusTrapManager.deregister(this);
    }
  }
  constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config, injector) {
    super(_element, _checker, _ngZone, _document, config.defer, injector);
    this._focusTrapManager = _focusTrapManager;
    this._inertStrategy = _inertStrategy;
    this._focusTrapManager.register(this);
  }
  /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */
  destroy() {
    this._focusTrapManager.deregister(this);
    super.destroy();
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _enable() {
    this._inertStrategy.preventFocus(this);
    this.toggleAnchors(true);
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _disable() {
    this._inertStrategy.allowFocus(this);
    this.toggleAnchors(false);
  }
};
var EventListenerFocusTrapInertStrategy = class {
  /** Focus event handler. */
  _listener = null;
  /** Adds a document event listener that keeps focus inside the FocusTrap. */
  preventFocus(focusTrap) {
    if (this._listener) {
      focusTrap._document.removeEventListener("focus", this._listener, true);
    }
    this._listener = (e) => this._trapFocus(focusTrap, e);
    focusTrap._ngZone.runOutsideAngular(() => {
      focusTrap._document.addEventListener("focus", this._listener, true);
    });
  }
  /** Removes the event listener added in preventFocus. */
  allowFocus(focusTrap) {
    if (!this._listener) {
      return;
    }
    focusTrap._document.removeEventListener("focus", this._listener, true);
    this._listener = null;
  }
  /**
   * Refocuses the first element in the FocusTrap if the focus event target was outside
   * the FocusTrap.
   *
   * This is an event listener callback. The event listener is added in runOutsideAngular,
   * so all this code runs outside Angular as well.
   */
  _trapFocus(focusTrap, event) {
    const target = event.target;
    const focusTrapRoot = focusTrap._element;
    if (target && !focusTrapRoot.contains(target) && !target.closest?.("div.cdk-overlay-pane")) {
      setTimeout(() => {
        if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {
          focusTrap.focusFirstTabbableElement();
        }
      });
    }
  }
};
var FOCUS_TRAP_INERT_STRATEGY = new InjectionToken("FOCUS_TRAP_INERT_STRATEGY");
var FocusTrapManager = class _FocusTrapManager {
  // A stack of the FocusTraps on the page. Only the FocusTrap at the
  // top of the stack is active.
  _focusTrapStack = [];
  /**
   * Disables the FocusTrap at the top of the stack, and then pushes
   * the new FocusTrap onto the stack.
   */
  register(focusTrap) {
    this._focusTrapStack = this._focusTrapStack.filter((ft) => ft !== focusTrap);
    let stack = this._focusTrapStack;
    if (stack.length) {
      stack[stack.length - 1]._disable();
    }
    stack.push(focusTrap);
    focusTrap._enable();
  }
  /**
   * Removes the FocusTrap from the stack, and activates the
   * FocusTrap that is the new top of the stack.
   */
  deregister(focusTrap) {
    focusTrap._disable();
    const stack = this._focusTrapStack;
    const i = stack.indexOf(focusTrap);
    if (i !== -1) {
      stack.splice(i, 1);
      if (stack.length) {
        stack[stack.length - 1]._enable();
      }
    }
  }
  static ɵfac = function FocusTrapManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusTrapManager)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusTrapManager,
    factory: _FocusTrapManager.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ConfigurableFocusTrapFactory = class _ConfigurableFocusTrapFactory {
  _checker = inject(InteractivityChecker);
  _ngZone = inject(NgZone);
  _focusTrapManager = inject(FocusTrapManager);
  _document = inject(DOCUMENT);
  _inertStrategy;
  _injector = inject(Injector);
  constructor() {
    const inertStrategy = inject(FOCUS_TRAP_INERT_STRATEGY, {
      optional: true
    });
    this._inertStrategy = inertStrategy || new EventListenerFocusTrapInertStrategy();
  }
  create(element, config = {
    defer: false
  }) {
    let configObject;
    if (typeof config === "boolean") {
      configObject = {
        defer: config
      };
    } else {
      configObject = config;
    }
    return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject, this._injector);
  }
  static ɵfac = function ConfigurableFocusTrapFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ConfigurableFocusTrapFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ConfigurableFocusTrapFactory,
    factory: _ConfigurableFocusTrapFactory.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConfigurableFocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/portal-directives-CtfZjx5e.mjs
function throwNullPortalError() {
  throw Error("Must provide a portal to attach");
}
function throwPortalAlreadyAttachedError() {
  throw Error("Host already has a portal attached");
}
function throwPortalOutletAlreadyDisposedError() {
  throw Error("This PortalOutlet has already been disposed");
}
function throwUnknownPortalTypeError() {
  throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.");
}
function throwNullPortalOutletError() {
  throw Error("Attempting to attach a portal to a null PortalOutlet");
}
function throwNoPortalAttachedError() {
  throw Error("Attempting to detach a portal that is not attached to a host");
}
var Portal = class {
  _attachedHost;
  /** Attach this portal to a host. */
  attach(host) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (host == null) {
        throwNullPortalOutletError();
      }
      if (host.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
    }
    this._attachedHost = host;
    return host.attach(this);
  }
  /** Detach this portal from its host */
  detach() {
    let host = this._attachedHost;
    if (host != null) {
      this._attachedHost = null;
      host.detach();
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwNoPortalAttachedError();
    }
  }
  /** Whether this portal is attached to a host. */
  get isAttached() {
    return this._attachedHost != null;
  }
  /**
   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
   * the PortalOutlet when it is performing an `attach()` or `detach()`.
   */
  setAttachedHost(host) {
    this._attachedHost = host;
  }
};
var ComponentPortal = class extends Portal {
  /** The type of the component that will be instantiated for attachment. */
  component;
  /**
   * Where the attached component should live in Angular's *logical* component tree.
   * This is different from where the component *renders*, which is determined by the PortalOutlet.
   * The origin is necessary when the host is outside of the Angular application context.
   */
  viewContainerRef;
  /** Injector used for the instantiation of the component. */
  injector;
  /**
   * @deprecated No longer in use. To be removed.
   * @breaking-change 18.0.0
   */
  componentFactoryResolver;
  /**
   * List of DOM nodes that should be projected through `<ng-content>` of the attached component.
   */
  projectableNodes;
  constructor(component, viewContainerRef, injector, _componentFactoryResolver, projectableNodes) {
    super();
    this.component = component;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.projectableNodes = projectableNodes;
  }
};
var TemplatePortal = class extends Portal {
  templateRef;
  viewContainerRef;
  context;
  injector;
  constructor(templateRef, viewContainerRef, context, injector) {
    super();
    this.templateRef = templateRef;
    this.viewContainerRef = viewContainerRef;
    this.context = context;
    this.injector = injector;
  }
  get origin() {
    return this.templateRef.elementRef;
  }
  /**
   * Attach the portal to the provided `PortalOutlet`.
   * When a context is provided it will override the `context` property of the `TemplatePortal`
   * instance.
   */
  attach(host, context = this.context) {
    this.context = context;
    return super.attach(host);
  }
  detach() {
    this.context = void 0;
    return super.detach();
  }
};
var DomPortal = class extends Portal {
  /** DOM node hosting the portal's content. */
  element;
  constructor(element) {
    super();
    this.element = element instanceof ElementRef ? element.nativeElement : element;
  }
};
var BasePortalOutlet = class {
  /** The portal currently attached to the host. */
  _attachedPortal;
  /** A function that will permanently dispose this host. */
  _disposeFn;
  /** Whether this host has already been permanently disposed. */
  _isDisposed = false;
  /** Whether this host has an attached portal. */
  hasAttached() {
    return !!this._attachedPortal;
  }
  /** Attaches a portal. */
  attach(portal) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!portal) {
        throwNullPortalError();
      }
      if (this.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
      if (this._isDisposed) {
        throwPortalOutletAlreadyDisposedError();
      }
    }
    if (portal instanceof ComponentPortal) {
      this._attachedPortal = portal;
      return this.attachComponentPortal(portal);
    } else if (portal instanceof TemplatePortal) {
      this._attachedPortal = portal;
      return this.attachTemplatePortal(portal);
    } else if (this.attachDomPortal && portal instanceof DomPortal) {
      this._attachedPortal = portal;
      return this.attachDomPortal(portal);
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwUnknownPortalTypeError();
    }
  }
  // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.
  attachDomPortal = null;
  /** Detaches a previously attached portal. */
  detach() {
    if (this._attachedPortal) {
      this._attachedPortal.setAttachedHost(null);
      this._attachedPortal = null;
    }
    this._invokeDisposeFn();
  }
  /** Permanently dispose of this portal host. */
  dispose() {
    if (this.hasAttached()) {
      this.detach();
    }
    this._invokeDisposeFn();
    this._isDisposed = true;
  }
  /** @docs-private */
  setDisposeFn(fn) {
    this._disposeFn = fn;
  }
  _invokeDisposeFn() {
    if (this._disposeFn) {
      this._disposeFn();
      this._disposeFn = null;
    }
  }
};
var DomPortalOutlet = class extends BasePortalOutlet {
  outletElement;
  _appRef;
  _defaultInjector;
  _document;
  /**
   * @param outletElement Element into which the content is projected.
   * @param _unusedComponentFactoryResolver Used to resolve the component factory.
   *   Only required when attaching component portals.
   * @param _appRef Reference to the application. Only used in component portals when there
   *   is no `ViewContainerRef` available.
   * @param _defaultInjector Injector to use as a fallback when the portal being attached doesn't
   *   have one. Only used for component portals.
   * @param _document Reference to the document. Used when attaching a DOM portal. Will eventually
   *   become a required parameter.
   */
  constructor(outletElement, _unusedComponentFactoryResolver, _appRef, _defaultInjector, _document) {
    super();
    this.outletElement = outletElement;
    this._appRef = _appRef;
    this._defaultInjector = _defaultInjector;
    this._document = _document;
  }
  /**
   * Attach the given ComponentPortal to DOM element.
   * @param portal Portal to be attached
   * @returns Reference to the created component.
   */
  attachComponentPortal(portal) {
    let componentRef;
    if (portal.viewContainerRef) {
      const injector = portal.injector || portal.viewContainerRef.injector;
      const ngModuleRef = injector.get(NgModuleRef$1, null, {
        optional: true
      }) || void 0;
      componentRef = portal.viewContainerRef.createComponent(portal.component, {
        index: portal.viewContainerRef.length,
        injector,
        ngModuleRef,
        projectableNodes: portal.projectableNodes || void 0
      });
      this.setDisposeFn(() => componentRef.destroy());
    } else {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._appRef) {
        throw Error("Cannot attach component portal to outlet without an ApplicationRef.");
      }
      const appRef = this._appRef;
      const elementInjector = portal.injector || this._defaultInjector || Injector.NULL;
      const environmentInjector = elementInjector.get(EnvironmentInjector, appRef.injector);
      componentRef = createComponent(portal.component, {
        elementInjector,
        environmentInjector,
        projectableNodes: portal.projectableNodes || void 0
      });
      appRef.attachView(componentRef.hostView);
      this.setDisposeFn(() => {
        if (appRef.viewCount > 0) {
          appRef.detachView(componentRef.hostView);
        }
        componentRef.destroy();
      });
    }
    this.outletElement.appendChild(this._getComponentRootNode(componentRef));
    this._attachedPortal = portal;
    return componentRef;
  }
  /**
   * Attaches a template portal to the DOM as an embedded view.
   * @param portal Portal to be attached.
   * @returns Reference to the created embedded view.
   */
  attachTemplatePortal(portal) {
    let viewContainer = portal.viewContainerRef;
    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    viewRef.rootNodes.forEach((rootNode) => this.outletElement.appendChild(rootNode));
    viewRef.detectChanges();
    this.setDisposeFn(() => {
      let index = viewContainer.indexOf(viewRef);
      if (index !== -1) {
        viewContainer.remove(index);
      }
    });
    this._attachedPortal = portal;
    return viewRef;
  }
  /**
   * Attaches a DOM portal by transferring its content into the outlet.
   * @param portal Portal to be attached.
   * @deprecated To be turned into a method.
   * @breaking-change 10.0.0
   */
  attachDomPortal = (portal) => {
    const element = portal.element;
    if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("DOM portal content must be attached to a parent node.");
    }
    const anchorNode = this._document.createComment("dom-portal");
    element.parentNode.insertBefore(anchorNode, element);
    this.outletElement.appendChild(element);
    this._attachedPortal = portal;
    super.setDisposeFn(() => {
      if (anchorNode.parentNode) {
        anchorNode.parentNode.replaceChild(element, anchorNode);
      }
    });
  };
  /**
   * Clears out a portal from the DOM.
   */
  dispose() {
    super.dispose();
    this.outletElement.remove();
  }
  /** Gets the root HTMLElement for an instantiated component. */
  _getComponentRootNode(componentRef) {
    return componentRef.hostView.rootNodes[0];
  }
};
var CdkPortal = class _CdkPortal extends TemplatePortal {
  constructor() {
    const templateRef = inject(TemplateRef);
    const viewContainerRef = inject(ViewContainerRef);
    super(templateRef, viewContainerRef);
  }
  static ɵfac = function CdkPortal_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkPortal)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkPortal,
    selectors: [["", "cdkPortal", ""]],
    exportAs: ["cdkPortal"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortal, [{
    type: Directive,
    args: [{
      selector: "[cdkPortal]",
      exportAs: "cdkPortal"
    }]
  }], () => [], null);
})();
var TemplatePortalDirective = class _TemplatePortalDirective extends CdkPortal {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTemplatePortalDirective_BaseFactory;
    return function TemplatePortalDirective_Factory(__ngFactoryType__) {
      return (ɵTemplatePortalDirective_BaseFactory || (ɵTemplatePortalDirective_BaseFactory = ɵɵgetInheritedFactory(_TemplatePortalDirective)))(__ngFactoryType__ || _TemplatePortalDirective);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _TemplatePortalDirective,
    selectors: [["", "cdk-portal", ""], ["", "portal", ""]],
    exportAs: ["cdkPortal"],
    features: [ɵɵProvidersFeature([{
      provide: CdkPortal,
      useExisting: _TemplatePortalDirective
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplatePortalDirective, [{
    type: Directive,
    args: [{
      selector: "[cdk-portal], [portal]",
      exportAs: "cdkPortal",
      providers: [{
        provide: CdkPortal,
        useExisting: TemplatePortalDirective
      }]
    }]
  }], null, null);
})();
var CdkPortalOutlet = class _CdkPortalOutlet extends BasePortalOutlet {
  _moduleRef = inject(NgModuleRef$1, {
    optional: true
  });
  _document = inject(DOCUMENT);
  _viewContainerRef = inject(ViewContainerRef);
  /** Whether the portal component is initialized. */
  _isInitialized = false;
  /** Reference to the currently-attached component/view ref. */
  _attachedRef;
  constructor() {
    super();
  }
  /** Portal associated with the Portal outlet. */
  get portal() {
    return this._attachedPortal;
  }
  set portal(portal) {
    if (this.hasAttached() && !portal && !this._isInitialized) {
      return;
    }
    if (this.hasAttached()) {
      super.detach();
    }
    if (portal) {
      super.attach(portal);
    }
    this._attachedPortal = portal || null;
  }
  /** Emits when a portal is attached to the outlet. */
  attached = new EventEmitter();
  /** Component or view reference that is attached to the portal. */
  get attachedRef() {
    return this._attachedRef;
  }
  ngOnInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    super.dispose();
    this._attachedRef = this._attachedPortal = null;
  }
  /**
   * Attach the given ComponentPortal to this PortalOutlet.
   *
   * @param portal Portal to be attached to the portal outlet.
   * @returns Reference to the created component.
   */
  attachComponentPortal(portal) {
    portal.setAttachedHost(this);
    const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;
    const ref = viewContainerRef.createComponent(portal.component, {
      index: viewContainerRef.length,
      injector: portal.injector || viewContainerRef.injector,
      projectableNodes: portal.projectableNodes || void 0,
      ngModuleRef: this._moduleRef || void 0
    });
    if (viewContainerRef !== this._viewContainerRef) {
      this._getRootNode().appendChild(ref.hostView.rootNodes[0]);
    }
    super.setDisposeFn(() => ref.destroy());
    this._attachedPortal = portal;
    this._attachedRef = ref;
    this.attached.emit(ref);
    return ref;
  }
  /**
   * Attach the given TemplatePortal to this PortalHost as an embedded View.
   * @param portal Portal to be attached.
   * @returns Reference to the created embedded view.
   */
  attachTemplatePortal(portal) {
    portal.setAttachedHost(this);
    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    super.setDisposeFn(() => this._viewContainerRef.clear());
    this._attachedPortal = portal;
    this._attachedRef = viewRef;
    this.attached.emit(viewRef);
    return viewRef;
  }
  /**
   * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.
   * @param portal Portal to be attached.
   * @deprecated To be turned into a method.
   * @breaking-change 10.0.0
   */
  attachDomPortal = (portal) => {
    const element = portal.element;
    if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("DOM portal content must be attached to a parent node.");
    }
    const anchorNode = this._document.createComment("dom-portal");
    portal.setAttachedHost(this);
    element.parentNode.insertBefore(anchorNode, element);
    this._getRootNode().appendChild(element);
    this._attachedPortal = portal;
    super.setDisposeFn(() => {
      if (anchorNode.parentNode) {
        anchorNode.parentNode.replaceChild(element, anchorNode);
      }
    });
  };
  /** Gets the root node of the portal outlet. */
  _getRootNode() {
    const nativeElement = this._viewContainerRef.element.nativeElement;
    return nativeElement.nodeType === nativeElement.ELEMENT_NODE ? nativeElement : nativeElement.parentNode;
  }
  static ɵfac = function CdkPortalOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkPortalOutlet)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkPortalOutlet,
    selectors: [["", "cdkPortalOutlet", ""]],
    inputs: {
      portal: [0, "cdkPortalOutlet", "portal"]
    },
    outputs: {
      attached: "attached"
    },
    exportAs: ["cdkPortalOutlet"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortalOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkPortalOutlet]",
      exportAs: "cdkPortalOutlet"
    }]
  }], () => [], {
    portal: [{
      type: Input,
      args: ["cdkPortalOutlet"]
    }],
    attached: [{
      type: Output
    }]
  });
})();
var PortalHostDirective = class _PortalHostDirective extends CdkPortalOutlet {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPortalHostDirective_BaseFactory;
    return function PortalHostDirective_Factory(__ngFactoryType__) {
      return (ɵPortalHostDirective_BaseFactory || (ɵPortalHostDirective_BaseFactory = ɵɵgetInheritedFactory(_PortalHostDirective)))(__ngFactoryType__ || _PortalHostDirective);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _PortalHostDirective,
    selectors: [["", "cdkPortalHost", ""], ["", "portalHost", ""]],
    inputs: {
      portal: [0, "cdkPortalHost", "portal"]
    },
    exportAs: ["cdkPortalHost"],
    features: [ɵɵProvidersFeature([{
      provide: CdkPortalOutlet,
      useExisting: _PortalHostDirective
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PortalHostDirective, [{
    type: Directive,
    args: [{
      selector: "[cdkPortalHost], [portalHost]",
      exportAs: "cdkPortalHost",
      inputs: [{
        name: "portal",
        alias: "cdkPortalHost"
      }],
      providers: [{
        provide: CdkPortalOutlet,
        useExisting: PortalHostDirective
      }]
    }]
  }], null, null);
})();
var PortalModule = class _PortalModule {
  static ɵfac = function PortalModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PortalModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PortalModule,
    imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
    exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PortalModule, [{
    type: NgModule,
    args: [{
      imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
      exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/portal.mjs
var PortalInjector = class {
  _parentInjector;
  _customTokens;
  constructor(_parentInjector, _customTokens) {
    this._parentInjector = _parentInjector;
    this._customTokens = _customTokens;
  }
  get(token, notFoundValue) {
    const value = this._customTokens.get(token);
    if (typeof value !== "undefined") {
      return value;
    }
    return this._parentInjector.get(token, notFoundValue);
  }
};

// node_modules/@angular/cdk/fesm2022/test-environment-BgaaXvCA.mjs
function _isTestEnvironment() {
  return (
    // @ts-ignore
    typeof __karma__ !== "undefined" && !!__karma__ || // @ts-ignore
    typeof jasmine !== "undefined" && !!jasmine || // @ts-ignore
    typeof jest !== "undefined" && !!jest || // @ts-ignore
    typeof Mocha !== "undefined" && !!Mocha
  );
}

// node_modules/@angular/cdk/fesm2022/css-pixel-value-C1yoKJ7R.mjs
function coerceCssPixelValue(value) {
  if (value == null) {
    return "";
  }
  return typeof value === "string" ? value : `${value}px`;
}

// node_modules/@angular/cdk/fesm2022/directionality-DPQw3n2b.mjs
var DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
  providedIn: "root",
  factory: DIR_DOCUMENT_FACTORY
});
function DIR_DOCUMENT_FACTORY() {
  return inject(DOCUMENT);
}
var RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
function _resolveDirectionality(rawValue) {
  const value = rawValue?.toLowerCase() || "";
  if (value === "auto" && typeof navigator !== "undefined" && navigator?.language) {
    return RTL_LOCALE_PATTERN.test(navigator.language) ? "rtl" : "ltr";
  }
  return value === "rtl" ? "rtl" : "ltr";
}
var Directionality = class _Directionality {
  /** The current 'ltr' or 'rtl' value. */
  value = "ltr";
  /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */
  change = new EventEmitter();
  constructor() {
    const _document = inject(DIR_DOCUMENT, {
      optional: true
    });
    if (_document) {
      const bodyDir = _document.body ? _document.body.dir : null;
      const htmlDir = _document.documentElement ? _document.documentElement.dir : null;
      this.value = _resolveDirectionality(bodyDir || htmlDir || "ltr");
    }
  }
  ngOnDestroy() {
    this.change.complete();
  }
  static ɵfac = function Directionality_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Directionality)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _Directionality,
    factory: _Directionality.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Directionality, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/scrolling-BXVcIfjZ.mjs
var RtlScrollAxisType;
(function(RtlScrollAxisType2) {
  RtlScrollAxisType2[RtlScrollAxisType2["NORMAL"] = 0] = "NORMAL";
  RtlScrollAxisType2[RtlScrollAxisType2["NEGATED"] = 1] = "NEGATED";
  RtlScrollAxisType2[RtlScrollAxisType2["INVERTED"] = 2] = "INVERTED";
})(RtlScrollAxisType || (RtlScrollAxisType = {}));
var rtlScrollAxisType;
var scrollBehaviorSupported;
function supportsScrollBehavior() {
  if (scrollBehaviorSupported == null) {
    if (typeof document !== "object" || !document || typeof Element !== "function" || !Element) {
      scrollBehaviorSupported = false;
      return scrollBehaviorSupported;
    }
    if ("scrollBehavior" in document.documentElement.style) {
      scrollBehaviorSupported = true;
    } else {
      const scrollToFunction = Element.prototype.scrollTo;
      if (scrollToFunction) {
        scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
      } else {
        scrollBehaviorSupported = false;
      }
    }
  }
  return scrollBehaviorSupported;
}
function getRtlScrollAxisType() {
  if (typeof document !== "object" || !document) {
    return RtlScrollAxisType.NORMAL;
  }
  if (rtlScrollAxisType == null) {
    const scrollContainer = document.createElement("div");
    const containerStyle = scrollContainer.style;
    scrollContainer.dir = "rtl";
    containerStyle.width = "1px";
    containerStyle.overflow = "auto";
    containerStyle.visibility = "hidden";
    containerStyle.pointerEvents = "none";
    containerStyle.position = "absolute";
    const content = document.createElement("div");
    const contentStyle = content.style;
    contentStyle.width = "2px";
    contentStyle.height = "1px";
    scrollContainer.appendChild(content);
    document.body.appendChild(scrollContainer);
    rtlScrollAxisType = RtlScrollAxisType.NORMAL;
    if (scrollContainer.scrollLeft === 0) {
      scrollContainer.scrollLeft = 1;
      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;
    }
    scrollContainer.remove();
  }
  return rtlScrollAxisType;
}

// node_modules/@angular/cdk/fesm2022/bidi.mjs
var Dir = class _Dir {
  /** Normalized direction that accounts for invalid/unsupported values. */
  _dir = "ltr";
  /** Whether the `value` has been set to its initial value. */
  _isInitialized = false;
  /** Direction as passed in by the consumer. */
  _rawDir;
  /** Event emitted when the direction changes. */
  change = new EventEmitter();
  /** @docs-private */
  get dir() {
    return this._dir;
  }
  set dir(value) {
    const previousValue = this._dir;
    this._dir = _resolveDirectionality(value);
    this._rawDir = value;
    if (previousValue !== this._dir && this._isInitialized) {
      this.change.emit(this._dir);
    }
  }
  /** Current layout direction of the element. */
  get value() {
    return this.dir;
  }
  /** Initialize once default value has been set. */
  ngAfterContentInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    this.change.complete();
  }
  static ɵfac = function Dir_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Dir)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _Dir,
    selectors: [["", "dir", ""]],
    hostVars: 1,
    hostBindings: function Dir_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx._rawDir);
      }
    },
    inputs: {
      dir: "dir"
    },
    outputs: {
      change: "dirChange"
    },
    exportAs: ["dir"],
    features: [ɵɵProvidersFeature([{
      provide: Directionality,
      useExisting: _Dir
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dir, [{
    type: Directive,
    args: [{
      selector: "[dir]",
      providers: [{
        provide: Directionality,
        useExisting: Dir
      }],
      host: {
        "[attr.dir]": "_rawDir"
      },
      exportAs: "dir"
    }]
  }], null, {
    change: [{
      type: Output,
      args: ["dirChange"]
    }],
    dir: [{
      type: Input
    }]
  });
})();
var BidiModule = class _BidiModule {
  static ɵfac = function BidiModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BidiModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _BidiModule,
    imports: [Dir],
    exports: [Dir]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BidiModule, [{
    type: NgModule,
    args: [{
      imports: [Dir],
      exports: [Dir]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/data-source-CL6Fasig.mjs
var DataSource = class {
};
function isDataSource(value) {
  return value && typeof value.connect === "function" && !(value instanceof ConnectableObservable);
}

// node_modules/@angular/cdk/fesm2022/recycle-view-repeater-strategy-Ce0p4WhD.mjs
var ArrayDataSource = class extends DataSource {
  _data;
  constructor(_data) {
    super();
    this._data = _data;
  }
  connect() {
    return isObservable(this._data) ? this._data : of(this._data);
  }
  disconnect() {
  }
};
var _ViewRepeaterOperation;
(function(_ViewRepeaterOperation2) {
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REPLACED"] = 0] = "REPLACED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["INSERTED"] = 1] = "INSERTED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["MOVED"] = 2] = "MOVED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REMOVED"] = 3] = "REMOVED";
})(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));
var _VIEW_REPEATER_STRATEGY = new InjectionToken("_ViewRepeater");
var _RecycleViewRepeaterStrategy = class {
  /**
   * The size of the cache used to store unused views.
   * Setting the cache size to `0` will disable caching. Defaults to 20 views.
   */
  viewCacheSize = 20;
  /**
   * View cache that stores embedded view instances that have been previously stamped out,
   * but don't are not currently rendered. The view repeater will reuse these views rather than
   * creating brand new ones.
   *
   * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.
   */
  _viewCache = [];
  /** Apply changes to the DOM. */
  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
      let view;
      let operation;
      if (record.previousIndex == null) {
        const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);
        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;
      } else if (currentIndex == null) {
        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
        operation = _ViewRepeaterOperation.REMOVED;
      } else {
        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = _ViewRepeaterOperation.MOVED;
      }
      if (itemViewChanged) {
        itemViewChanged({
          context: view?.context,
          operation,
          record
        });
      }
    });
  }
  detach() {
    for (const view of this._viewCache) {
      view.destroy();
    }
    this._viewCache = [];
  }
  /**
   * Inserts a view for a new item, either from the cache or by creating a new
   * one. Returns `undefined` if the item was inserted into a cached view.
   */
  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
    if (cachedView) {
      cachedView.context.$implicit = value;
      return void 0;
    }
    const viewArgs = viewArgsFactory();
    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
  }
  /** Detaches the view at the given index and inserts into the view cache. */
  _detachAndCacheView(index, viewContainerRef) {
    const detachedView = viewContainerRef.detach(index);
    this._maybeCacheView(detachedView, viewContainerRef);
  }
  /** Moves view at the previous index to the current index. */
  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
    const view = viewContainerRef.get(adjustedPreviousIndex);
    viewContainerRef.move(view, currentIndex);
    view.context.$implicit = value;
    return view;
  }
  /**
   * Cache the given detached view. If the cache is full, the view will be
   * destroyed.
   */
  _maybeCacheView(view, viewContainerRef) {
    if (this._viewCache.length < this.viewCacheSize) {
      this._viewCache.push(view);
    } else {
      const index = viewContainerRef.indexOf(view);
      if (index === -1) {
        view.destroy();
      } else {
        viewContainerRef.remove(index);
      }
    }
  }
  /** Inserts a recycled view from the cache at the given index. */
  _insertViewFromCache(index, viewContainerRef) {
    const cachedView = this._viewCache.pop();
    if (cachedView) {
      viewContainerRef.insert(cachedView, index);
    }
    return cachedView || null;
  }
};

// node_modules/@angular/cdk/fesm2022/scrolling.mjs
var _c0 = ["contentWrapper"];
var _c1 = ["*"];
var VIRTUAL_SCROLL_STRATEGY = new InjectionToken("VIRTUAL_SCROLL_STRATEGY");
var FixedSizeVirtualScrollStrategy = class {
  _scrolledIndexChange = new Subject();
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());
  /** The attached viewport. */
  _viewport = null;
  /** The size of the items in the virtually scrolling list. */
  _itemSize;
  /** The minimum amount of buffer rendered beyond the viewport (in pixels). */
  _minBufferPx;
  /** The number of buffer items to render beyond the edge of the viewport (in pixels). */
  _maxBufferPx;
  /**
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  constructor(itemSize, minBufferPx, maxBufferPx) {
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
  }
  /**
   * Attaches this scroll strategy to a viewport.
   * @param viewport The viewport to attach this strategy to.
   */
  attach(viewport) {
    this._viewport = viewport;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** Detaches this scroll strategy from the currently attached viewport. */
  detach() {
    this._scrolledIndexChange.complete();
    this._viewport = null;
  }
  /**
   * Update the item size and buffer size.
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
    if (maxBufferPx < minBufferPx && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx");
    }
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentScrolled() {
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onDataLengthChanged() {
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentRendered() {
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onRenderedOffsetChanged() {
  }
  /**
   * Scroll to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling.
   */
  scrollToIndex(index, behavior) {
    if (this._viewport) {
      this._viewport.scrollToOffset(index * this._itemSize, behavior);
    }
  }
  /** Update the viewport's total content size. */
  _updateTotalContentSize() {
    if (!this._viewport) {
      return;
    }
    this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
  }
  /** Update the viewport's rendered range. */
  _updateRenderedRange() {
    if (!this._viewport) {
      return;
    }
    const renderedRange = this._viewport.getRenderedRange();
    const newRange = {
      start: renderedRange.start,
      end: renderedRange.end
    };
    const viewportSize = this._viewport.getViewportSize();
    const dataLength = this._viewport.getDataLength();
    let scrollOffset = this._viewport.measureScrollOffset();
    let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
    if (newRange.end > dataLength) {
      const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
      const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
      if (firstVisibleIndex != newVisibleIndex) {
        firstVisibleIndex = newVisibleIndex;
        scrollOffset = newVisibleIndex * this._itemSize;
        newRange.start = Math.floor(firstVisibleIndex);
      }
      newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
    }
    const startBuffer = scrollOffset - newRange.start * this._itemSize;
    if (startBuffer < this._minBufferPx && newRange.start != 0) {
      const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
      newRange.start = Math.max(0, newRange.start - expandStart);
      newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
    } else {
      const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
      if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
        const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
        if (expandEnd > 0) {
          newRange.end = Math.min(dataLength, newRange.end + expandEnd);
          newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
        }
      }
    }
    this._viewport.setRenderedRange(newRange);
    this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);
    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
  }
};
function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
  return fixedSizeDir._scrollStrategy;
}
var CdkFixedSizeVirtualScroll = class _CdkFixedSizeVirtualScroll {
  /** The size of the items in the list (in pixels). */
  get itemSize() {
    return this._itemSize;
  }
  set itemSize(value) {
    this._itemSize = coerceNumberProperty(value);
  }
  _itemSize = 20;
  /**
   * The minimum amount of buffer rendered beyond the viewport (in pixels).
   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
   */
  get minBufferPx() {
    return this._minBufferPx;
  }
  set minBufferPx(value) {
    this._minBufferPx = coerceNumberProperty(value);
  }
  _minBufferPx = 100;
  /**
   * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
   */
  get maxBufferPx() {
    return this._maxBufferPx;
  }
  set maxBufferPx(value) {
    this._maxBufferPx = coerceNumberProperty(value);
  }
  _maxBufferPx = 200;
  /** The scroll strategy used by this directive. */
  _scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
  ngOnChanges() {
    this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
  }
  static ɵfac = function CdkFixedSizeVirtualScroll_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFixedSizeVirtualScroll)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkFixedSizeVirtualScroll,
    selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
    inputs: {
      itemSize: "itemSize",
      minBufferPx: "minBufferPx",
      maxBufferPx: "maxBufferPx"
    },
    features: [ɵɵProvidersFeature([{
      provide: VIRTUAL_SCROLL_STRATEGY,
      useFactory: _fixedSizeVirtualScrollStrategyFactory,
      deps: [forwardRef(() => _CdkFixedSizeVirtualScroll)]
    }]), ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFixedSizeVirtualScroll, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[itemSize]",
      providers: [{
        provide: VIRTUAL_SCROLL_STRATEGY,
        useFactory: _fixedSizeVirtualScrollStrategyFactory,
        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]
      }]
    }]
  }], null, {
    itemSize: [{
      type: Input
    }],
    minBufferPx: [{
      type: Input
    }],
    maxBufferPx: [{
      type: Input
    }]
  });
})();
var DEFAULT_SCROLL_TIME = 20;
var ScrollDispatcher = class _ScrollDispatcher {
  _ngZone = inject(NgZone);
  _platform = inject(Platform);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cleanupGlobalListener;
  constructor() {
  }
  /** Subject for notifying that a registered scrollable reference element has been scrolled. */
  _scrolled = new Subject();
  /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */
  _scrolledCount = 0;
  /**
   * Map of all the scrollable references that are registered with the service and their
   * scroll event subscriptions.
   */
  scrollContainers = /* @__PURE__ */ new Map();
  /**
   * Registers a scrollable instance with the service and listens for its scrolled events. When the
   * scrollable is scrolled, the service emits the event to its scrolled observable.
   * @param scrollable Scrollable instance to be registered.
   */
  register(scrollable) {
    if (!this.scrollContainers.has(scrollable)) {
      this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
    }
  }
  /**
   * De-registers a Scrollable reference and unsubscribes from its scroll event observable.
   * @param scrollable Scrollable instance to be deregistered.
   */
  deregister(scrollable) {
    const scrollableReference = this.scrollContainers.get(scrollable);
    if (scrollableReference) {
      scrollableReference.unsubscribe();
      this.scrollContainers.delete(scrollable);
    }
  }
  /**
   * Returns an observable that emits an event whenever any of the registered Scrollable
   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
   * to override the default "throttle" time.
   *
   * **Note:** in order to avoid hitting change detection for every scroll event,
   * all of the events emitted from this stream will be run outside the Angular zone.
   * If you need to update any data bindings as a result of a scroll event, you have
   * to run the callback using `NgZone.run`.
   */
  scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
    if (!this._platform.isBrowser) {
      return of();
    }
    return new Observable((observer) => {
      if (!this._cleanupGlobalListener) {
        this._cleanupGlobalListener = this._ngZone.runOutsideAngular(() => this._renderer.listen("document", "scroll", () => this._scrolled.next()));
      }
      const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
      this._scrolledCount++;
      return () => {
        subscription.unsubscribe();
        this._scrolledCount--;
        if (!this._scrolledCount) {
          this._cleanupGlobalListener?.();
          this._cleanupGlobalListener = void 0;
        }
      };
    });
  }
  ngOnDestroy() {
    this._cleanupGlobalListener?.();
    this._cleanupGlobalListener = void 0;
    this.scrollContainers.forEach((_, container) => this.deregister(container));
    this._scrolled.complete();
  }
  /**
   * Returns an observable that emits whenever any of the
   * scrollable ancestors of an element are scrolled.
   * @param elementOrElementRef Element whose ancestors to listen for.
   * @param auditTimeInMs Time to throttle the scroll events.
   */
  ancestorScrolled(elementOrElementRef, auditTimeInMs) {
    const ancestors = this.getAncestorScrollContainers(elementOrElementRef);
    return this.scrolled(auditTimeInMs).pipe(filter((target) => !target || ancestors.indexOf(target) > -1));
  }
  /** Returns all registered Scrollables that contain the provided element. */
  getAncestorScrollContainers(elementOrElementRef) {
    const scrollingContainers = [];
    this.scrollContainers.forEach((_subscription, scrollable) => {
      if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {
        scrollingContainers.push(scrollable);
      }
    });
    return scrollingContainers;
  }
  /** Returns true if the element is contained within the provided Scrollable. */
  _scrollableContainsElement(scrollable, elementOrElementRef) {
    let element = coerceElement(elementOrElementRef);
    let scrollableElement = scrollable.getElementRef().nativeElement;
    do {
      if (element == scrollableElement) {
        return true;
      }
    } while (element = element.parentElement);
    return false;
  }
  static ɵfac = function ScrollDispatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollDispatcher)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollDispatcher,
    factory: _ScrollDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkScrollable = class _CdkScrollable {
  elementRef = inject(ElementRef);
  scrollDispatcher = inject(ScrollDispatcher);
  ngZone = inject(NgZone);
  dir = inject(Directionality, {
    optional: true
  });
  _scrollElement = this.elementRef.nativeElement;
  _destroyed = new Subject();
  _renderer = inject(Renderer2);
  _cleanupScroll;
  _elementScrolled = new Subject();
  constructor() {
  }
  ngOnInit() {
    this._cleanupScroll = this.ngZone.runOutsideAngular(() => this._renderer.listen(this._scrollElement, "scroll", (event) => this._elementScrolled.next(event)));
    this.scrollDispatcher.register(this);
  }
  ngOnDestroy() {
    this._cleanupScroll?.();
    this._elementScrolled.complete();
    this.scrollDispatcher.deregister(this);
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Returns observable that emits when a scroll event is fired on the host element. */
  elementScrolled() {
    return this._elementScrolled;
  }
  /** Gets the ElementRef for the viewport. */
  getElementRef() {
    return this.elementRef;
  }
  /**
   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param options specified the offsets to scroll to.
   */
  scrollTo(options) {
    const el = this.elementRef.nativeElement;
    const isRtl = this.dir && this.dir.value == "rtl";
    if (options.left == null) {
      options.left = isRtl ? options.end : options.start;
    }
    if (options.right == null) {
      options.right = isRtl ? options.start : options.end;
    }
    if (options.bottom != null) {
      options.top = el.scrollHeight - el.clientHeight - options.bottom;
    }
    if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {
      if (options.left != null) {
        options.right = el.scrollWidth - el.clientWidth - options.left;
      }
      if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
        options.left = options.right;
      } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
        options.left = options.right ? -options.right : options.right;
      }
    } else {
      if (options.right != null) {
        options.left = el.scrollWidth - el.clientWidth - options.right;
      }
    }
    this._applyScrollToOptions(options);
  }
  _applyScrollToOptions(options) {
    const el = this.elementRef.nativeElement;
    if (supportsScrollBehavior()) {
      el.scrollTo(options);
    } else {
      if (options.top != null) {
        el.scrollTop = options.top;
      }
      if (options.left != null) {
        el.scrollLeft = options.left;
      }
    }
  }
  /**
   * Measures the scroll offset relative to the specified edge of the viewport. This method can be
   * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
   * about what scrollLeft means in RTL. The values returned by this method are normalized such that
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param from The edge to measure from.
   */
  measureScrollOffset(from2) {
    const LEFT = "left";
    const RIGHT = "right";
    const el = this.elementRef.nativeElement;
    if (from2 == "top") {
      return el.scrollTop;
    }
    if (from2 == "bottom") {
      return el.scrollHeight - el.clientHeight - el.scrollTop;
    }
    const isRtl = this.dir && this.dir.value == "rtl";
    if (from2 == "start") {
      from2 = isRtl ? RIGHT : LEFT;
    } else if (from2 == "end") {
      from2 = isRtl ? LEFT : RIGHT;
    }
    if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
      if (from2 == LEFT) {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      } else {
        return el.scrollLeft;
      }
    } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
      if (from2 == LEFT) {
        return el.scrollLeft + el.scrollWidth - el.clientWidth;
      } else {
        return -el.scrollLeft;
      }
    } else {
      if (from2 == LEFT) {
        return el.scrollLeft;
      } else {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      }
    }
  }
  static ɵfac = function CdkScrollable_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkScrollable)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkScrollable,
    selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollable, [{
    type: Directive,
    args: [{
      selector: "[cdk-scrollable], [cdkScrollable]"
    }]
  }], () => [], null);
})();
var DEFAULT_RESIZE_TIME = 20;
var ViewportRuler = class _ViewportRuler {
  _platform = inject(Platform);
  _listeners;
  /** Cached viewport dimensions. */
  _viewportSize;
  /** Stream of viewport change events. */
  _change = new Subject();
  /** Used to reference correct document/window */
  _document = inject(DOCUMENT, {
    optional: true
  });
  constructor() {
    const ngZone = inject(NgZone);
    const renderer = inject(RendererFactory2).createRenderer(null, null);
    ngZone.runOutsideAngular(() => {
      if (this._platform.isBrowser) {
        const changeListener = (event) => this._change.next(event);
        this._listeners = [renderer.listen("window", "resize", changeListener), renderer.listen("window", "orientationchange", changeListener)];
      }
      this.change().subscribe(() => this._viewportSize = null);
    });
  }
  ngOnDestroy() {
    this._listeners?.forEach((cleanup) => cleanup());
    this._change.complete();
  }
  /** Returns the viewport's width and height. */
  getViewportSize() {
    if (!this._viewportSize) {
      this._updateViewportSize();
    }
    const output = {
      width: this._viewportSize.width,
      height: this._viewportSize.height
    };
    if (!this._platform.isBrowser) {
      this._viewportSize = null;
    }
    return output;
  }
  /** Gets a DOMRect for the viewport's bounds. */
  getViewportRect() {
    const scrollPosition = this.getViewportScrollPosition();
    const {
      width,
      height
    } = this.getViewportSize();
    return {
      top: scrollPosition.top,
      left: scrollPosition.left,
      bottom: scrollPosition.top + height,
      right: scrollPosition.left + width,
      height,
      width
    };
  }
  /** Gets the (top, left) scroll position of the viewport. */
  getViewportScrollPosition() {
    if (!this._platform.isBrowser) {
      return {
        top: 0,
        left: 0
      };
    }
    const document2 = this._document;
    const window2 = this._getWindow();
    const documentElement = document2.documentElement;
    const documentRect = documentElement.getBoundingClientRect();
    const top = -documentRect.top || document2.body.scrollTop || window2.scrollY || documentElement.scrollTop || 0;
    const left = -documentRect.left || document2.body.scrollLeft || window2.scrollX || documentElement.scrollLeft || 0;
    return {
      top,
      left
    };
  }
  /**
   * Returns a stream that emits whenever the size of the viewport changes.
   * This stream emits outside of the Angular zone.
   * @param throttleTime Time in milliseconds to throttle the stream.
   */
  change(throttleTime = DEFAULT_RESIZE_TIME) {
    return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /** Updates the cached viewport size. */
  _updateViewportSize() {
    const window2 = this._getWindow();
    this._viewportSize = this._platform.isBrowser ? {
      width: window2.innerWidth,
      height: window2.innerHeight
    } : {
      width: 0,
      height: 0
    };
  }
  static ɵfac = function ViewportRuler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ViewportRuler)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ViewportRuler,
    factory: _ViewportRuler.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewportRuler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var VIRTUAL_SCROLLABLE = new InjectionToken("VIRTUAL_SCROLLABLE");
var CdkVirtualScrollable = class _CdkVirtualScrollable extends CdkScrollable {
  constructor() {
    super();
  }
  /**
   * Measure the viewport size for the provided orientation.
   *
   * @param orientation The orientation to measure the size from.
   */
  measureViewportSize(orientation) {
    const viewportEl = this.elementRef.nativeElement;
    return orientation === "horizontal" ? viewportEl.clientWidth : viewportEl.clientHeight;
  }
  static ɵfac = function CdkVirtualScrollable_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollable)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualScrollable,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollable, [{
    type: Directive
  }], () => [], null);
})();
function rangesEqual(r1, r2) {
  return r1.start == r2.start && r1.end == r2.end;
}
var SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
var CdkVirtualScrollViewport = class _CdkVirtualScrollViewport extends CdkVirtualScrollable {
  elementRef = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _scrollStrategy = inject(VIRTUAL_SCROLL_STRATEGY, {
    optional: true
  });
  scrollable = inject(VIRTUAL_SCROLLABLE, {
    optional: true
  });
  _platform = inject(Platform);
  /** Emits when the viewport is detached from a CdkVirtualForOf. */
  _detachedSubject = new Subject();
  /** Emits when the rendered range changes. */
  _renderedRangeSubject = new Subject();
  /** The direction the viewport scrolls. */
  get orientation() {
    return this._orientation;
  }
  set orientation(orientation) {
    if (this._orientation !== orientation) {
      this._orientation = orientation;
      this._calculateSpacerSize();
    }
  }
  _orientation = "vertical";
  /**
   * Whether rendered items should persist in the DOM after scrolling out of view. By default, items
   * will be removed.
   */
  appendOnly = false;
  // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll
  // strategy lazily (i.e. only if the user is actually listening to the events). We do this because
  // depending on how the strategy calculates the scrolled index, it may come at a cost to
  // performance.
  /** Emits when the index of the first element visible in the viewport changes. */
  scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe((index) => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));
  /** The element that wraps the rendered content. */
  _contentWrapper;
  /** A stream that emits whenever the rendered range changes. */
  renderedRangeStream = this._renderedRangeSubject;
  /**
   * The total size of all content (in pixels), including content that is not currently rendered.
   */
  _totalContentSize = 0;
  /** A string representing the `style.width` property value to be used for the spacer element. */
  _totalContentWidth = "";
  /** A string representing the `style.height` property value to be used for the spacer element. */
  _totalContentHeight = "";
  /**
   * The CSS transform applied to the rendered subset of items so that they appear within the bounds
   * of the visible viewport.
   */
  _renderedContentTransform;
  /** The currently rendered range of indices. */
  _renderedRange = {
    start: 0,
    end: 0
  };
  /** The length of the data bound to this viewport (in number of items). */
  _dataLength = 0;
  /** The size of the viewport (in pixels). */
  _viewportSize = 0;
  /** the currently attached CdkVirtualScrollRepeater. */
  _forOf;
  /** The last rendered content offset that was set. */
  _renderedContentOffset = 0;
  /**
   * Whether the last rendered content offset was to the end of the content (and therefore needs to
   * be rewritten as an offset to the start of the content).
   */
  _renderedContentOffsetNeedsRewrite = false;
  /** Whether there is a pending change detection cycle. */
  _isChangeDetectionPending = false;
  /** A list of functions to run after the next change detection cycle. */
  _runAfterChangeDetection = [];
  /** Subscription to changes in the viewport size. */
  _viewportChanges = Subscription.EMPTY;
  _injector = inject(Injector);
  _isDestroyed = false;
  constructor() {
    super();
    const viewportRuler = inject(ViewportRuler);
    if (!this._scrollStrategy && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
    }
    this._viewportChanges = viewportRuler.change().subscribe(() => {
      this.checkViewportSize();
    });
    if (!this.scrollable) {
      this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable");
      this.scrollable = this;
    }
  }
  ngOnInit() {
    if (!this._platform.isBrowser) {
      return;
    }
    if (this.scrollable === this) {
      super.ngOnInit();
    }
    this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
      this._measureViewportSize();
      this._scrollStrategy.attach(this);
      this.scrollable.elementScrolled().pipe(
        // Start off with a fake scroll event so we properly detect our initial position.
        startWith(null),
        // Collect multiple events into one until the next animation frame. This way if
        // there are multiple scroll events in the same frame we only need to recheck
        // our layout once.
        auditTime(0, SCROLL_SCHEDULER),
        // Usually `elementScrolled` is completed when the scrollable is destroyed, but
        // that may not be the case if a `CdkVirtualScrollableElement` is used so we have
        // to unsubscribe here just in case.
        takeUntil(this._destroyed)
      ).subscribe(() => this._scrollStrategy.onContentScrolled());
      this._markChangeDetectionNeeded();
    }));
  }
  ngOnDestroy() {
    this.detach();
    this._scrollStrategy.detach();
    this._renderedRangeSubject.complete();
    this._detachedSubject.complete();
    this._viewportChanges.unsubscribe();
    this._isDestroyed = true;
    super.ngOnDestroy();
  }
  /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */
  attach(forOf) {
    if (this._forOf && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CdkVirtualScrollViewport is already attached.");
    }
    this.ngZone.runOutsideAngular(() => {
      this._forOf = forOf;
      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((data) => {
        const newLength = data.length;
        if (newLength !== this._dataLength) {
          this._dataLength = newLength;
          this._scrollStrategy.onDataLengthChanged();
        }
        this._doChangeDetection();
      });
    });
  }
  /** Detaches the current `CdkVirtualForOf`. */
  detach() {
    this._forOf = null;
    this._detachedSubject.next();
  }
  /** Gets the length of the data bound to this viewport (in number of items). */
  getDataLength() {
    return this._dataLength;
  }
  /** Gets the size of the viewport (in pixels). */
  getViewportSize() {
    return this._viewportSize;
  }
  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
  // cycle happens. I'm being careful to only call it after the render cycle is complete and before
  // setting it to something else, but its error prone and should probably be split into
  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
  /** Get the current rendered range of items. */
  getRenderedRange() {
    return this._renderedRange;
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
  }
  /**
   * Sets the total size of all content (in pixels), including content that is not currently
   * rendered.
   */
  setTotalContentSize(size) {
    if (this._totalContentSize !== size) {
      this._totalContentSize = size;
      this._calculateSpacerSize();
      this._markChangeDetectionNeeded();
    }
  }
  /** Sets the currently rendered range of indices. */
  setRenderedRange(range2) {
    if (!rangesEqual(this._renderedRange, range2)) {
      if (this.appendOnly) {
        range2 = {
          start: 0,
          end: Math.max(this._renderedRange.end, range2.end)
        };
      }
      this._renderedRangeSubject.next(this._renderedRange = range2);
      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());
    }
  }
  /**
   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
   */
  getOffsetToRenderedContentStart() {
    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
  }
  /**
   * Sets the offset from the start of the viewport to either the start or end of the rendered data
   * (in pixels).
   */
  setRenderedContentOffset(offset, to = "to-start") {
    offset = this.appendOnly && to === "to-start" ? 0 : offset;
    const isRtl = this.dir && this.dir.value == "rtl";
    const isHorizontal = this.orientation == "horizontal";
    const axis = isHorizontal ? "X" : "Y";
    const axisDirection = isHorizontal && isRtl ? -1 : 1;
    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;
    this._renderedContentOffset = offset;
    if (to === "to-end") {
      transform += ` translate${axis}(-100%)`;
      this._renderedContentOffsetNeedsRewrite = true;
    }
    if (this._renderedContentTransform != transform) {
      this._renderedContentTransform = transform;
      this._markChangeDetectionNeeded(() => {
        if (this._renderedContentOffsetNeedsRewrite) {
          this._renderedContentOffset -= this.measureRenderedContentSize();
          this._renderedContentOffsetNeedsRewrite = false;
          this.setRenderedContentOffset(this._renderedContentOffset);
        } else {
          this._scrollStrategy.onRenderedOffsetChanged();
        }
      });
    }
  }
  /**
   * Scrolls to the given offset from the start of the viewport. Please note that this is not always
   * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
   * direction, this would be the equivalent of setting a fictional `scrollRight` property.
   * @param offset The offset to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToOffset(offset, behavior = "auto") {
    const options = {
      behavior
    };
    if (this.orientation === "horizontal") {
      options.start = offset;
    } else {
      options.top = offset;
    }
    this.scrollable.scrollTo(options);
  }
  /**
   * Scrolls to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToIndex(index, behavior = "auto") {
    this._scrollStrategy.scrollToIndex(index, behavior);
  }
  /**
   * Gets the current scroll offset from the start of the scrollable (in pixels).
   * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
   *     in horizontal mode.
   */
  measureScrollOffset(from2) {
    let measureScrollOffset;
    if (this.scrollable == this) {
      measureScrollOffset = (_from) => super.measureScrollOffset(_from);
    } else {
      measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);
    }
    return Math.max(0, measureScrollOffset(from2 ?? (this.orientation === "horizontal" ? "start" : "top")) - this.measureViewportOffset());
  }
  /**
   * Measures the offset of the viewport from the scrolling container
   * @param from The edge to measure from.
   */
  measureViewportOffset(from2) {
    let fromRect;
    const LEFT = "left";
    const RIGHT = "right";
    const isRtl = this.dir?.value == "rtl";
    if (from2 == "start") {
      fromRect = isRtl ? RIGHT : LEFT;
    } else if (from2 == "end") {
      fromRect = isRtl ? LEFT : RIGHT;
    } else if (from2) {
      fromRect = from2;
    } else {
      fromRect = this.orientation === "horizontal" ? "left" : "top";
    }
    const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);
    const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];
    return viewportClientRect - scrollerClientRect;
  }
  /** Measure the combined size of all of the rendered items. */
  measureRenderedContentSize() {
    const contentEl = this._contentWrapper.nativeElement;
    return this.orientation === "horizontal" ? contentEl.offsetWidth : contentEl.offsetHeight;
  }
  /**
   * Measure the total combined size of the given range. Throws if the range includes items that are
   * not rendered.
   */
  measureRangeSize(range2) {
    if (!this._forOf) {
      return 0;
    }
    return this._forOf.measureRangeSize(range2, this.orientation);
  }
  /** Update the viewport dimensions and re-render. */
  checkViewportSize() {
    this._measureViewportSize();
    this._scrollStrategy.onDataLengthChanged();
  }
  /** Measure the viewport size. */
  _measureViewportSize() {
    this._viewportSize = this.scrollable.measureViewportSize(this.orientation);
  }
  /** Queue up change detection to run. */
  _markChangeDetectionNeeded(runAfter) {
    if (runAfter) {
      this._runAfterChangeDetection.push(runAfter);
    }
    if (!this._isChangeDetectionPending) {
      this._isChangeDetectionPending = true;
      this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
        this._doChangeDetection();
      }));
    }
  }
  /** Run change detection. */
  _doChangeDetection() {
    if (this._isDestroyed) {
      return;
    }
    this.ngZone.run(() => {
      this._changeDetectorRef.markForCheck();
      this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
      afterNextRender(() => {
        this._isChangeDetectionPending = false;
        const runAfterChangeDetection = this._runAfterChangeDetection;
        this._runAfterChangeDetection = [];
        for (const fn of runAfterChangeDetection) {
          fn();
        }
      }, {
        injector: this._injector
      });
    });
  }
  /** Calculates the `style.width` and `style.height` for the spacer element. */
  _calculateSpacerSize() {
    this._totalContentHeight = this.orientation === "horizontal" ? "" : `${this._totalContentSize}px`;
    this._totalContentWidth = this.orientation === "horizontal" ? `${this._totalContentSize}px` : "";
  }
  static ɵfac = function CdkVirtualScrollViewport_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollViewport)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CdkVirtualScrollViewport,
    selectors: [["cdk-virtual-scroll-viewport"]],
    viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentWrapper = _t.first);
      }
    },
    hostAttrs: [1, "cdk-virtual-scroll-viewport"],
    hostVars: 4,
    hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
      }
    },
    inputs: {
      orientation: "orientation",
      appendOnly: [2, "appendOnly", "appendOnly", booleanAttribute]
    },
    outputs: {
      scrolledIndexChange: "scrolledIndexChange"
    },
    features: [ɵɵProvidersFeature([{
      provide: CdkScrollable,
      useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
      deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], _CdkVirtualScrollViewport]
    }]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c1,
    decls: 4,
    vars: 4,
    consts: [["contentWrapper", ""], [1, "cdk-virtual-scroll-content-wrapper"], [1, "cdk-virtual-scroll-spacer"]],
    template: function CdkVirtualScrollViewport_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 1, 0);
        ɵɵprojection(2);
        ɵɵelementEnd();
        ɵɵelement(3, "div", 2);
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵstyleProp("width", ctx._totalContentWidth)("height", ctx._totalContentHeight);
      }
    },
    styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollViewport, [{
    type: Component,
    args: [{
      selector: "cdk-virtual-scroll-viewport",
      host: {
        "class": "cdk-virtual-scroll-viewport",
        "[class.cdk-virtual-scroll-orientation-horizontal]": 'orientation === "horizontal"',
        "[class.cdk-virtual-scroll-orientation-vertical]": 'orientation !== "horizontal"'
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: CdkScrollable,
        useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
        deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]
      }],
      template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth" [style.height]="_totalContentHeight"></div>\n',
      styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"]
    }]
  }], () => [], {
    orientation: [{
      type: Input
    }],
    appendOnly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    scrolledIndexChange: [{
      type: Output
    }],
    _contentWrapper: [{
      type: ViewChild,
      args: ["contentWrapper", {
        static: true
      }]
    }]
  });
})();
function getOffset(orientation, direction, node) {
  const el = node;
  if (!el.getBoundingClientRect) {
    return 0;
  }
  const rect = el.getBoundingClientRect();
  if (orientation === "horizontal") {
    return direction === "start" ? rect.left : rect.right;
  }
  return direction === "start" ? rect.top : rect.bottom;
}
var CdkVirtualForOf = class _CdkVirtualForOf {
  _viewContainerRef = inject(ViewContainerRef);
  _template = inject(TemplateRef);
  _differs = inject(IterableDiffers);
  _viewRepeater = inject(_VIEW_REPEATER_STRATEGY);
  _viewport = inject(CdkVirtualScrollViewport, {
    skipSelf: true
  });
  /** Emits when the rendered view of the data changes. */
  viewChange = new Subject();
  /** Subject that emits when a new DataSource instance is given. */
  _dataSourceChanges = new Subject();
  /** The DataSource to display. */
  get cdkVirtualForOf() {
    return this._cdkVirtualForOf;
  }
  set cdkVirtualForOf(value) {
    this._cdkVirtualForOf = value;
    if (isDataSource(value)) {
      this._dataSourceChanges.next(value);
    } else {
      this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));
    }
  }
  _cdkVirtualForOf;
  /**
   * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
   * the item and produces a value to be used as the item's identity when tracking changes.
   */
  get cdkVirtualForTrackBy() {
    return this._cdkVirtualForTrackBy;
  }
  set cdkVirtualForTrackBy(fn) {
    this._needsUpdate = true;
    this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : void 0;
  }
  _cdkVirtualForTrackBy;
  /** The template used to stamp out new elements. */
  set cdkVirtualForTemplate(value) {
    if (value) {
      this._needsUpdate = true;
      this._template = value;
    }
  }
  /**
   * The size of the cache used to store templates that are not being used for re-use later.
   * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
   */
  get cdkVirtualForTemplateCacheSize() {
    return this._viewRepeater.viewCacheSize;
  }
  set cdkVirtualForTemplateCacheSize(size) {
    this._viewRepeater.viewCacheSize = coerceNumberProperty(size);
  }
  /** Emits whenever the data in the current DataSource changes. */
  dataStream = this._dataSourceChanges.pipe(
    // Start off with null `DataSource`.
    startWith(null),
    // Bundle up the previous and current data sources so we can work with both.
    pairwise(),
    // Use `_changeDataSource` to disconnect from the previous data source and connect to the
    // new one, passing back a stream of data changes which we run through `switchMap` to give
    // us a data stream that emits the latest data from whatever the current `DataSource` is.
    switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),
    // Replay the last emitted data when someone subscribes.
    shareReplay(1)
  );
  /** The differ used to calculate changes to the data. */
  _differ = null;
  /** The most recent data emitted from the DataSource. */
  _data;
  /** The currently rendered items. */
  _renderedItems;
  /** The currently rendered range of indices. */
  _renderedRange;
  /** Whether the rendered data should be updated during the next ngDoCheck cycle. */
  _needsUpdate = false;
  _destroyed = new Subject();
  constructor() {
    const ngZone = inject(NgZone);
    this.dataStream.subscribe((data) => {
      this._data = data;
      this._onRenderedDataChange();
    });
    this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((range2) => {
      this._renderedRange = range2;
      if (this.viewChange.observers.length) {
        ngZone.run(() => this.viewChange.next(this._renderedRange));
      }
      this._onRenderedDataChange();
    });
    this._viewport.attach(this);
  }
  /**
   * Measures the combined size (width for horizontal orientation, height for vertical) of all items
   * in the specified range. Throws an error if the range includes items that are not currently
   * rendered.
   */
  measureRangeSize(range2, orientation) {
    if (range2.start >= range2.end) {
      return 0;
    }
    if ((range2.start < this._renderedRange.start || range2.end > this._renderedRange.end) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Error: attempted to measure an item that isn't rendered.`);
    }
    const renderedStartIndex = range2.start - this._renderedRange.start;
    const rangeLen = range2.end - range2.start;
    let firstNode;
    let lastNode;
    for (let i = 0; i < rangeLen; i++) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        firstNode = lastNode = view.rootNodes[0];
        break;
      }
    }
    for (let i = rangeLen - 1; i > -1; i--) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        lastNode = view.rootNodes[view.rootNodes.length - 1];
        break;
      }
    }
    return firstNode && lastNode ? getOffset(orientation, "end", lastNode) - getOffset(orientation, "start", firstNode) : 0;
  }
  ngDoCheck() {
    if (this._differ && this._needsUpdate) {
      const changes = this._differ.diff(this._renderedItems);
      if (!changes) {
        this._updateContext();
      } else {
        this._applyChanges(changes);
      }
      this._needsUpdate = false;
    }
  }
  ngOnDestroy() {
    this._viewport.detach();
    this._dataSourceChanges.next(void 0);
    this._dataSourceChanges.complete();
    this.viewChange.complete();
    this._destroyed.next();
    this._destroyed.complete();
    this._viewRepeater.detach();
  }
  /** React to scroll state changes in the viewport. */
  _onRenderedDataChange() {
    if (!this._renderedRange) {
      return;
    }
    this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
    if (!this._differ) {
      this._differ = this._differs.find(this._renderedItems).create((index, item) => {
        return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;
      });
    }
    this._needsUpdate = true;
  }
  /** Swap out one `DataSource` for another. */
  _changeDataSource(oldDs, newDs) {
    if (oldDs) {
      oldDs.disconnect(this);
    }
    this._needsUpdate = true;
    return newDs ? newDs.connect(this) : of();
  }
  /** Update the `CdkVirtualForOfContext` for all views. */
  _updateContext() {
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
      view.detectChanges();
    }
  }
  /** Apply changes to the DOM. */
  _applyChanges(changes) {
    this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);
    changes.forEachIdentityChange((record) => {
      const view = this._viewContainerRef.get(record.currentIndex);
      view.context.$implicit = record.item;
    });
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
    }
  }
  /** Update the computed properties on the `CdkVirtualForOfContext`. */
  _updateComputedContextProperties(context) {
    context.first = context.index === 0;
    context.last = context.index === context.count - 1;
    context.even = context.index % 2 === 0;
    context.odd = !context.even;
  }
  _getEmbeddedViewArgs(record, index) {
    return {
      templateRef: this._template,
      context: {
        $implicit: record.item,
        // It's guaranteed that the iterable is not "undefined" or "null" because we only
        // generate views for elements if the "cdkVirtualForOf" iterable has elements.
        cdkVirtualForOf: this._cdkVirtualForOf,
        index: -1,
        count: -1,
        first: false,
        last: false,
        odd: false,
        even: false
      },
      index
    };
  }
  static ngTemplateContextGuard(directive, context) {
    return true;
  }
  static ɵfac = function CdkVirtualForOf_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualForOf)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualForOf,
    selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
    inputs: {
      cdkVirtualForOf: "cdkVirtualForOf",
      cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
      cdkVirtualForTemplate: "cdkVirtualForTemplate",
      cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
    },
    features: [ɵɵProvidersFeature([{
      provide: _VIEW_REPEATER_STRATEGY,
      useClass: _RecycleViewRepeaterStrategy
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualForOf, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualFor][cdkVirtualForOf]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }]
    }]
  }], () => [], {
    cdkVirtualForOf: [{
      type: Input
    }],
    cdkVirtualForTrackBy: [{
      type: Input
    }],
    cdkVirtualForTemplate: [{
      type: Input
    }],
    cdkVirtualForTemplateCacheSize: [{
      type: Input
    }]
  });
})();
var CdkVirtualScrollableElement = class _CdkVirtualScrollableElement extends CdkVirtualScrollable {
  constructor() {
    super();
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2] - this.measureScrollOffset(from2);
  }
  static ɵfac = function CdkVirtualScrollableElement_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollableElement)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualScrollableElement,
    selectors: [["", "cdkVirtualScrollingElement", ""]],
    hostAttrs: [1, "cdk-virtual-scrollable"],
    features: [ɵɵProvidersFeature([{
      provide: VIRTUAL_SCROLLABLE,
      useExisting: _CdkVirtualScrollableElement
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableElement, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualScrollingElement]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableElement
      }],
      host: {
        "class": "cdk-virtual-scrollable"
      }
    }]
  }], () => [], null);
})();
var CdkVirtualScrollableWindow = class _CdkVirtualScrollableWindow extends CdkVirtualScrollable {
  constructor() {
    super();
    const document2 = inject(DOCUMENT);
    this.elementRef = new ElementRef(document2.documentElement);
    this._scrollElement = document2;
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
  }
  static ɵfac = function CdkVirtualScrollableWindow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollableWindow)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualScrollableWindow,
    selectors: [["cdk-virtual-scroll-viewport", "scrollWindow", ""]],
    features: [ɵɵProvidersFeature([{
      provide: VIRTUAL_SCROLLABLE,
      useExisting: _CdkVirtualScrollableWindow
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableWindow, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[scrollWindow]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableWindow
      }]
    }]
  }], () => [], null);
})();
var CdkScrollableModule = class _CdkScrollableModule {
  static ɵfac = function CdkScrollableModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkScrollableModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CdkScrollableModule,
    imports: [CdkScrollable],
    exports: [CdkScrollable]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollableModule, [{
    type: NgModule,
    args: [{
      exports: [CdkScrollable],
      imports: [CdkScrollable]
    }]
  }], null, null);
})();
var ScrollingModule = class _ScrollingModule {
  static ɵfac = function ScrollingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollingModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ScrollingModule,
    imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
    exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [BidiModule, CdkScrollableModule, BidiModule, CdkScrollableModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
      exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/overlay-module-DVlnSjmr.mjs
var scrollBehaviorSupported2 = supportsScrollBehavior();
var BlockScrollStrategy = class {
  _viewportRuler;
  _previousHTMLStyles = {
    top: "",
    left: ""
  };
  _previousScrollPosition;
  _isEnabled = false;
  _document;
  constructor(_viewportRuler, document2) {
    this._viewportRuler = _viewportRuler;
    this._document = document2;
  }
  /** Attaches this scroll strategy to an overlay. */
  attach() {
  }
  /** Blocks page-level scroll while the attached overlay is open. */
  enable() {
    if (this._canBeEnabled()) {
      const root = this._document.documentElement;
      this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();
      this._previousHTMLStyles.left = root.style.left || "";
      this._previousHTMLStyles.top = root.style.top || "";
      root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);
      root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);
      root.classList.add("cdk-global-scrollblock");
      this._isEnabled = true;
    }
  }
  /** Unblocks page-level scroll while the attached overlay is open. */
  disable() {
    if (this._isEnabled) {
      const html = this._document.documentElement;
      const body = this._document.body;
      const htmlStyle = html.style;
      const bodyStyle = body.style;
      const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || "";
      const previousBodyScrollBehavior = bodyStyle.scrollBehavior || "";
      this._isEnabled = false;
      htmlStyle.left = this._previousHTMLStyles.left;
      htmlStyle.top = this._previousHTMLStyles.top;
      html.classList.remove("cdk-global-scrollblock");
      if (scrollBehaviorSupported2) {
        htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = "auto";
      }
      window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);
      if (scrollBehaviorSupported2) {
        htmlStyle.scrollBehavior = previousHtmlScrollBehavior;
        bodyStyle.scrollBehavior = previousBodyScrollBehavior;
      }
    }
  }
  _canBeEnabled() {
    const html = this._document.documentElement;
    if (html.classList.contains("cdk-global-scrollblock") || this._isEnabled) {
      return false;
    }
    const body = this._document.body;
    const viewport = this._viewportRuler.getViewportSize();
    return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;
  }
};
function getMatScrollStrategyAlreadyAttachedError() {
  return Error(`Scroll strategy has already been attached.`);
}
var CloseScrollStrategy = class {
  _scrollDispatcher;
  _ngZone;
  _viewportRuler;
  _config;
  _scrollSubscription = null;
  _overlayRef;
  _initialScrollPosition;
  constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {
    this._scrollDispatcher = _scrollDispatcher;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._config = _config;
  }
  /** Attaches this scroll strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatScrollStrategyAlreadyAttachedError();
    }
    this._overlayRef = overlayRef;
  }
  /** Enables the closing of the attached overlay on scroll. */
  enable() {
    if (this._scrollSubscription) {
      return;
    }
    const stream = this._scrollDispatcher.scrolled(0).pipe(filter((scrollable) => {
      return !scrollable || !this._overlayRef.overlayElement.contains(scrollable.getElementRef().nativeElement);
    }));
    if (this._config && this._config.threshold && this._config.threshold > 1) {
      this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;
      this._scrollSubscription = stream.subscribe(() => {
        const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;
        if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {
          this._detach();
        } else {
          this._overlayRef.updatePosition();
        }
      });
    } else {
      this._scrollSubscription = stream.subscribe(this._detach);
    }
  }
  /** Disables the closing the attached overlay on scroll. */
  disable() {
    if (this._scrollSubscription) {
      this._scrollSubscription.unsubscribe();
      this._scrollSubscription = null;
    }
  }
  detach() {
    this.disable();
    this._overlayRef = null;
  }
  /** Detaches the overlay ref and disables the scroll strategy. */
  _detach = () => {
    this.disable();
    if (this._overlayRef.hasAttached()) {
      this._ngZone.run(() => this._overlayRef.detach());
    }
  };
};
var NoopScrollStrategy = class {
  /** Does nothing, as this scroll strategy is a no-op. */
  enable() {
  }
  /** Does nothing, as this scroll strategy is a no-op. */
  disable() {
  }
  /** Does nothing, as this scroll strategy is a no-op. */
  attach() {
  }
};
function isElementScrolledOutsideView(element, scrollContainers) {
  return scrollContainers.some((containerBounds) => {
    const outsideAbove = element.bottom < containerBounds.top;
    const outsideBelow = element.top > containerBounds.bottom;
    const outsideLeft = element.right < containerBounds.left;
    const outsideRight = element.left > containerBounds.right;
    return outsideAbove || outsideBelow || outsideLeft || outsideRight;
  });
}
function isElementClippedByScrolling(element, scrollContainers) {
  return scrollContainers.some((scrollContainerRect) => {
    const clippedAbove = element.top < scrollContainerRect.top;
    const clippedBelow = element.bottom > scrollContainerRect.bottom;
    const clippedLeft = element.left < scrollContainerRect.left;
    const clippedRight = element.right > scrollContainerRect.right;
    return clippedAbove || clippedBelow || clippedLeft || clippedRight;
  });
}
var RepositionScrollStrategy = class {
  _scrollDispatcher;
  _viewportRuler;
  _ngZone;
  _config;
  _scrollSubscription = null;
  _overlayRef;
  constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {
    this._scrollDispatcher = _scrollDispatcher;
    this._viewportRuler = _viewportRuler;
    this._ngZone = _ngZone;
    this._config = _config;
  }
  /** Attaches this scroll strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatScrollStrategyAlreadyAttachedError();
    }
    this._overlayRef = overlayRef;
  }
  /** Enables repositioning of the attached overlay on scroll. */
  enable() {
    if (!this._scrollSubscription) {
      const throttle2 = this._config ? this._config.scrollThrottle : 0;
      this._scrollSubscription = this._scrollDispatcher.scrolled(throttle2).subscribe(() => {
        this._overlayRef.updatePosition();
        if (this._config && this._config.autoClose) {
          const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();
          const {
            width,
            height
          } = this._viewportRuler.getViewportSize();
          const parentRects = [{
            width,
            height,
            bottom: height,
            right: width,
            top: 0,
            left: 0
          }];
          if (isElementScrolledOutsideView(overlayRect, parentRects)) {
            this.disable();
            this._ngZone.run(() => this._overlayRef.detach());
          }
        }
      });
    }
  }
  /** Disables repositioning of the attached overlay on scroll. */
  disable() {
    if (this._scrollSubscription) {
      this._scrollSubscription.unsubscribe();
      this._scrollSubscription = null;
    }
  }
  detach() {
    this.disable();
    this._overlayRef = null;
  }
};
var ScrollStrategyOptions = class _ScrollStrategyOptions {
  _scrollDispatcher = inject(ScrollDispatcher);
  _viewportRuler = inject(ViewportRuler);
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  constructor() {
  }
  /** Do nothing on scroll. */
  noop = () => new NoopScrollStrategy();
  /**
   * Close the overlay as soon as the user scrolls.
   * @param config Configuration to be used inside the scroll strategy.
   */
  close = (config) => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);
  /** Block scrolling. */
  block = () => new BlockScrollStrategy(this._viewportRuler, this._document);
  /**
   * Update the overlay's position on scroll.
   * @param config Configuration to be used inside the scroll strategy.
   * Allows debouncing the reposition calls.
   */
  reposition = (config) => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);
  static ɵfac = function ScrollStrategyOptions_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollStrategyOptions)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollStrategyOptions,
    factory: _ScrollStrategyOptions.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollStrategyOptions, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var OverlayConfig = class {
  /** Strategy with which to position the overlay. */
  positionStrategy;
  /** Strategy to be used when handling scroll events while the overlay is open. */
  scrollStrategy = new NoopScrollStrategy();
  /** Custom class to add to the overlay pane. */
  panelClass = "";
  /** Whether the overlay has a backdrop. */
  hasBackdrop = false;
  /** Custom class to add to the backdrop */
  backdropClass = "cdk-overlay-dark-backdrop";
  /** The width of the overlay panel. If a number is provided, pixel units are assumed. */
  width;
  /** The height of the overlay panel. If a number is provided, pixel units are assumed. */
  height;
  /** The min-width of the overlay panel. If a number is provided, pixel units are assumed. */
  minWidth;
  /** The min-height of the overlay panel. If a number is provided, pixel units are assumed. */
  minHeight;
  /** The max-width of the overlay panel. If a number is provided, pixel units are assumed. */
  maxWidth;
  /** The max-height of the overlay panel. If a number is provided, pixel units are assumed. */
  maxHeight;
  /**
   * Direction of the text in the overlay panel. If a `Directionality` instance
   * is passed in, the overlay will handle changes to its value automatically.
   */
  direction;
  /**
   * Whether the overlay should be disposed of when the user goes backwards/forwards in history.
   * Note that this usually doesn't include clicking on links (unless the user is using
   * the `HashLocationStrategy`).
   */
  disposeOnNavigation = false;
  constructor(config) {
    if (config) {
      const configKeys = Object.keys(config);
      for (const key of configKeys) {
        if (config[key] !== void 0) {
          this[key] = config[key];
        }
      }
    }
  }
};
var ConnectedOverlayPositionChange = class {
  connectionPair;
  scrollableViewProperties;
  constructor(connectionPair, scrollableViewProperties) {
    this.connectionPair = connectionPair;
    this.scrollableViewProperties = scrollableViewProperties;
  }
};
function validateVerticalPosition(property, value) {
  if (value !== "top" && value !== "bottom" && value !== "center") {
    throw Error(`ConnectedPosition: Invalid ${property} "${value}". Expected "top", "bottom" or "center".`);
  }
}
function validateHorizontalPosition(property, value) {
  if (value !== "start" && value !== "end" && value !== "center") {
    throw Error(`ConnectedPosition: Invalid ${property} "${value}". Expected "start", "end" or "center".`);
  }
}
var BaseOverlayDispatcher = class _BaseOverlayDispatcher {
  /** Currently attached overlays in the order they were attached. */
  _attachedOverlays = [];
  _document = inject(DOCUMENT);
  _isAttached;
  constructor() {
  }
  ngOnDestroy() {
    this.detach();
  }
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    this.remove(overlayRef);
    this._attachedOverlays.push(overlayRef);
  }
  /** Remove an overlay from the list of attached overlay refs. */
  remove(overlayRef) {
    const index = this._attachedOverlays.indexOf(overlayRef);
    if (index > -1) {
      this._attachedOverlays.splice(index, 1);
    }
    if (this._attachedOverlays.length === 0) {
      this.detach();
    }
  }
  static ɵfac = function BaseOverlayDispatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseOverlayDispatcher)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _BaseOverlayDispatcher,
    factory: _BaseOverlayDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseOverlayDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var OverlayKeyboardDispatcher = class _OverlayKeyboardDispatcher extends BaseOverlayDispatcher {
  _ngZone = inject(NgZone);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cleanupKeydown;
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    super.add(overlayRef);
    if (!this._isAttached) {
      this._ngZone.runOutsideAngular(() => {
        this._cleanupKeydown = this._renderer.listen("body", "keydown", this._keydownListener);
      });
      this._isAttached = true;
    }
  }
  /** Detaches the global keyboard event listener. */
  detach() {
    if (this._isAttached) {
      this._cleanupKeydown?.();
      this._isAttached = false;
    }
  }
  /** Keyboard event listener that will be attached to the body. */
  _keydownListener = (event) => {
    const overlays = this._attachedOverlays;
    for (let i = overlays.length - 1; i > -1; i--) {
      if (overlays[i]._keydownEvents.observers.length > 0) {
        this._ngZone.run(() => overlays[i]._keydownEvents.next(event));
        break;
      }
    }
  };
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵOverlayKeyboardDispatcher_BaseFactory;
    return function OverlayKeyboardDispatcher_Factory(__ngFactoryType__) {
      return (ɵOverlayKeyboardDispatcher_BaseFactory || (ɵOverlayKeyboardDispatcher_BaseFactory = ɵɵgetInheritedFactory(_OverlayKeyboardDispatcher)))(__ngFactoryType__ || _OverlayKeyboardDispatcher);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({
    token: _OverlayKeyboardDispatcher,
    factory: _OverlayKeyboardDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayKeyboardDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var OverlayOutsideClickDispatcher = class _OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {
  _platform = inject(Platform);
  _ngZone = inject(NgZone);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cursorOriginalValue;
  _cursorStyleIsSet = false;
  _pointerDownEventTarget;
  _cleanups;
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    super.add(overlayRef);
    if (!this._isAttached) {
      const body = this._document.body;
      const eventOptions = {
        capture: true
      };
      this._cleanups = this._ngZone.runOutsideAngular(() => [_bindEventWithOptions(this._renderer, body, "pointerdown", this._pointerDownListener, eventOptions), _bindEventWithOptions(this._renderer, body, "click", this._clickListener, eventOptions), _bindEventWithOptions(this._renderer, body, "auxclick", this._clickListener, eventOptions), _bindEventWithOptions(this._renderer, body, "contextmenu", this._clickListener, eventOptions)]);
      if (this._platform.IOS && !this._cursorStyleIsSet) {
        this._cursorOriginalValue = body.style.cursor;
        body.style.cursor = "pointer";
        this._cursorStyleIsSet = true;
      }
      this._isAttached = true;
    }
  }
  /** Detaches the global keyboard event listener. */
  detach() {
    if (this._isAttached) {
      this._cleanups?.forEach((cleanup) => cleanup());
      this._cleanups = void 0;
      if (this._platform.IOS && this._cursorStyleIsSet) {
        this._document.body.style.cursor = this._cursorOriginalValue;
        this._cursorStyleIsSet = false;
      }
      this._isAttached = false;
    }
  }
  /** Store pointerdown event target to track origin of click. */
  _pointerDownListener = (event) => {
    this._pointerDownEventTarget = _getEventTarget(event);
  };
  /** Click event listener that will be attached to the body propagate phase. */
  _clickListener = (event) => {
    const target = _getEventTarget(event);
    const origin = event.type === "click" && this._pointerDownEventTarget ? this._pointerDownEventTarget : target;
    this._pointerDownEventTarget = null;
    const overlays = this._attachedOverlays.slice();
    for (let i = overlays.length - 1; i > -1; i--) {
      const overlayRef = overlays[i];
      if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {
        continue;
      }
      if (containsPierceShadowDom(overlayRef.overlayElement, target) || containsPierceShadowDom(overlayRef.overlayElement, origin)) {
        break;
      }
      const outsidePointerEvents = overlayRef._outsidePointerEvents;
      if (this._ngZone) {
        this._ngZone.run(() => outsidePointerEvents.next(event));
      } else {
        outsidePointerEvents.next(event);
      }
    }
  };
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵOverlayOutsideClickDispatcher_BaseFactory;
    return function OverlayOutsideClickDispatcher_Factory(__ngFactoryType__) {
      return (ɵOverlayOutsideClickDispatcher_BaseFactory || (ɵOverlayOutsideClickDispatcher_BaseFactory = ɵɵgetInheritedFactory(_OverlayOutsideClickDispatcher)))(__ngFactoryType__ || _OverlayOutsideClickDispatcher);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({
    token: _OverlayOutsideClickDispatcher,
    factory: _OverlayOutsideClickDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayOutsideClickDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function containsPierceShadowDom(parent, child) {
  const supportsShadowRoot = typeof ShadowRoot !== "undefined" && ShadowRoot;
  let current = child;
  while (current) {
    if (current === parent) {
      return true;
    }
    current = supportsShadowRoot && current instanceof ShadowRoot ? current.host : current.parentNode;
  }
  return false;
}
var _CdkOverlayStyleLoader = class __CdkOverlayStyleLoader {
  static ɵfac = function _CdkOverlayStyleLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __CdkOverlayStyleLoader)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: __CdkOverlayStyleLoader,
    selectors: [["ng-component"]],
    hostAttrs: ["cdk-overlay-style-loader", ""],
    decls: 0,
    vars: 0,
    template: function _CdkOverlayStyleLoader_Template(rf, ctx) {
    },
    styles: [".cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed}@layer cdk-overlay{.cdk-overlay-container{z-index:1000}}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute}@layer cdk-overlay{.cdk-global-overlay-wrapper{z-index:1000}}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;display:flex;max-width:100%;max-height:100%}@layer cdk-overlay{.cdk-overlay-pane{z-index:1000}}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:auto;-webkit-tap-highlight-color:rgba(0,0,0,0);opacity:0}@layer cdk-overlay{.cdk-overlay-backdrop{z-index:1000;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}}@media(prefers-reduced-motion){.cdk-overlay-backdrop{transition-duration:1ms}}.cdk-overlay-backdrop-showing{opacity:1}@media(forced-colors: active){.cdk-overlay-backdrop-showing{opacity:.6}}@layer cdk-overlay{.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing,.cdk-high-contrast-active .cdk-overlay-transparent-backdrop{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;display:flex;flex-direction:column;min-width:1px;min-height:1px}@layer cdk-overlay{.cdk-overlay-connected-position-bounding-box{z-index:1000}}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}\n"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CdkOverlayStyleLoader, [{
    type: Component,
    args: [{
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "cdk-overlay-style-loader": ""
      },
      styles: [".cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed}@layer cdk-overlay{.cdk-overlay-container{z-index:1000}}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute}@layer cdk-overlay{.cdk-global-overlay-wrapper{z-index:1000}}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;display:flex;max-width:100%;max-height:100%}@layer cdk-overlay{.cdk-overlay-pane{z-index:1000}}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:auto;-webkit-tap-highlight-color:rgba(0,0,0,0);opacity:0}@layer cdk-overlay{.cdk-overlay-backdrop{z-index:1000;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}}@media(prefers-reduced-motion){.cdk-overlay-backdrop{transition-duration:1ms}}.cdk-overlay-backdrop-showing{opacity:1}@media(forced-colors: active){.cdk-overlay-backdrop-showing{opacity:.6}}@layer cdk-overlay{.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing,.cdk-high-contrast-active .cdk-overlay-transparent-backdrop{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;display:flex;flex-direction:column;min-width:1px;min-height:1px}@layer cdk-overlay{.cdk-overlay-connected-position-bounding-box{z-index:1000}}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}\n"]
    }]
  }], null, null);
})();
var OverlayContainer = class _OverlayContainer {
  _platform = inject(Platform);
  _containerElement;
  _document = inject(DOCUMENT);
  _styleLoader = inject(_CdkPrivateStyleLoader);
  constructor() {
  }
  ngOnDestroy() {
    this._containerElement?.remove();
  }
  /**
   * This method returns the overlay container element. It will lazily
   * create the element the first time it is called to facilitate using
   * the container in non-browser environments.
   * @returns the container element
   */
  getContainerElement() {
    this._loadStyles();
    if (!this._containerElement) {
      this._createContainer();
    }
    return this._containerElement;
  }
  /**
   * Create the overlay container element, which is simply a div
   * with the 'cdk-overlay-container' class on the document body.
   */
  _createContainer() {
    const containerClass = "cdk-overlay-container";
    if (this._platform.isBrowser || _isTestEnvironment()) {
      const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform="server"], .${containerClass}[platform="test"]`);
      for (let i = 0; i < oppositePlatformContainers.length; i++) {
        oppositePlatformContainers[i].remove();
      }
    }
    const container = this._document.createElement("div");
    container.classList.add(containerClass);
    if (_isTestEnvironment()) {
      container.setAttribute("platform", "test");
    } else if (!this._platform.isBrowser) {
      container.setAttribute("platform", "server");
    }
    this._document.body.appendChild(container);
    this._containerElement = container;
  }
  /** Loads the structural styles necessary for the overlay to work. */
  _loadStyles() {
    this._styleLoader.load(_CdkOverlayStyleLoader);
  }
  static ɵfac = function OverlayContainer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OverlayContainer)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _OverlayContainer,
    factory: _OverlayContainer.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayContainer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var BackdropRef = class {
  _renderer;
  _ngZone;
  element;
  _cleanupClick;
  _cleanupTransitionEnd;
  _fallbackTimeout;
  constructor(document2, _renderer, _ngZone, onClick) {
    this._renderer = _renderer;
    this._ngZone = _ngZone;
    this.element = document2.createElement("div");
    this.element.classList.add("cdk-overlay-backdrop");
    this._cleanupClick = _renderer.listen(this.element, "click", onClick);
  }
  detach() {
    this._ngZone.runOutsideAngular(() => {
      const element = this.element;
      clearTimeout(this._fallbackTimeout);
      this._cleanupTransitionEnd?.();
      this._cleanupTransitionEnd = this._renderer.listen(element, "transitionend", this.dispose);
      this._fallbackTimeout = setTimeout(this.dispose, 500);
      element.style.pointerEvents = "none";
      element.classList.remove("cdk-overlay-backdrop-showing");
    });
  }
  dispose = () => {
    clearTimeout(this._fallbackTimeout);
    this._cleanupClick?.();
    this._cleanupTransitionEnd?.();
    this._cleanupClick = this._cleanupTransitionEnd = this._fallbackTimeout = void 0;
    this.element.remove();
  };
};
var OverlayRef = class {
  _portalOutlet;
  _host;
  _pane;
  _config;
  _ngZone;
  _keyboardDispatcher;
  _document;
  _location;
  _outsideClickDispatcher;
  _animationsDisabled;
  _injector;
  _renderer;
  _backdropClick = new Subject();
  _attachments = new Subject();
  _detachments = new Subject();
  _positionStrategy;
  _scrollStrategy;
  _locationChanges = Subscription.EMPTY;
  _backdropRef = null;
  /**
   * Reference to the parent of the `_host` at the time it was detached. Used to restore
   * the `_host` to its original position in the DOM when it gets re-attached.
   */
  _previousHostParent;
  /** Stream of keydown events dispatched to this overlay. */
  _keydownEvents = new Subject();
  /** Stream of mouse outside events dispatched to this overlay. */
  _outsidePointerEvents = new Subject();
  _renders = new Subject();
  _afterRenderRef;
  /** Reference to the currently-running `afterNextRender` call. */
  _afterNextRenderRef;
  constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location, _outsideClickDispatcher, _animationsDisabled = false, _injector, _renderer) {
    this._portalOutlet = _portalOutlet;
    this._host = _host;
    this._pane = _pane;
    this._config = _config;
    this._ngZone = _ngZone;
    this._keyboardDispatcher = _keyboardDispatcher;
    this._document = _document;
    this._location = _location;
    this._outsideClickDispatcher = _outsideClickDispatcher;
    this._animationsDisabled = _animationsDisabled;
    this._injector = _injector;
    this._renderer = _renderer;
    if (_config.scrollStrategy) {
      this._scrollStrategy = _config.scrollStrategy;
      this._scrollStrategy.attach(this);
    }
    this._positionStrategy = _config.positionStrategy;
    this._afterRenderRef = untracked(() => afterRender(() => {
      this._renders.next();
    }, {
      injector: this._injector
    }));
  }
  /** The overlay's HTML element */
  get overlayElement() {
    return this._pane;
  }
  /** The overlay's backdrop HTML element. */
  get backdropElement() {
    return this._backdropRef?.element || null;
  }
  /**
   * Wrapper around the panel element. Can be used for advanced
   * positioning where a wrapper with specific styling is
   * required around the overlay pane.
   */
  get hostElement() {
    return this._host;
  }
  /**
   * Attaches content, given via a Portal, to the overlay.
   * If the overlay is configured to have a backdrop, it will be created.
   *
   * @param portal Portal instance to which to attach the overlay.
   * @returns The portal attachment result.
   */
  attach(portal) {
    if (!this._host.parentElement && this._previousHostParent) {
      this._previousHostParent.appendChild(this._host);
    }
    const attachResult = this._portalOutlet.attach(portal);
    if (this._positionStrategy) {
      this._positionStrategy.attach(this);
    }
    this._updateStackingOrder();
    this._updateElementSize();
    this._updateElementDirection();
    if (this._scrollStrategy) {
      this._scrollStrategy.enable();
    }
    this._afterNextRenderRef?.destroy();
    this._afterNextRenderRef = afterNextRender(() => {
      if (this.hasAttached()) {
        this.updatePosition();
      }
    }, {
      injector: this._injector
    });
    this._togglePointerEvents(true);
    if (this._config.hasBackdrop) {
      this._attachBackdrop();
    }
    if (this._config.panelClass) {
      this._toggleClasses(this._pane, this._config.panelClass, true);
    }
    this._attachments.next();
    this._keyboardDispatcher.add(this);
    if (this._config.disposeOnNavigation) {
      this._locationChanges = this._location.subscribe(() => this.dispose());
    }
    this._outsideClickDispatcher.add(this);
    if (typeof attachResult?.onDestroy === "function") {
      attachResult.onDestroy(() => {
        if (this.hasAttached()) {
          this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()));
        }
      });
    }
    return attachResult;
  }
  /**
   * Detaches an overlay from a portal.
   * @returns The portal detachment result.
   */
  detach() {
    if (!this.hasAttached()) {
      return;
    }
    this.detachBackdrop();
    this._togglePointerEvents(false);
    if (this._positionStrategy && this._positionStrategy.detach) {
      this._positionStrategy.detach();
    }
    if (this._scrollStrategy) {
      this._scrollStrategy.disable();
    }
    const detachmentResult = this._portalOutlet.detach();
    this._detachments.next();
    this._keyboardDispatcher.remove(this);
    this._detachContentWhenEmpty();
    this._locationChanges.unsubscribe();
    this._outsideClickDispatcher.remove(this);
    return detachmentResult;
  }
  /** Cleans up the overlay from the DOM. */
  dispose() {
    const isAttached = this.hasAttached();
    if (this._positionStrategy) {
      this._positionStrategy.dispose();
    }
    this._disposeScrollStrategy();
    this._backdropRef?.dispose();
    this._locationChanges.unsubscribe();
    this._keyboardDispatcher.remove(this);
    this._portalOutlet.dispose();
    this._attachments.complete();
    this._backdropClick.complete();
    this._keydownEvents.complete();
    this._outsidePointerEvents.complete();
    this._outsideClickDispatcher.remove(this);
    this._host?.remove();
    this._afterNextRenderRef?.destroy();
    this._previousHostParent = this._pane = this._host = this._backdropRef = null;
    if (isAttached) {
      this._detachments.next();
    }
    this._detachments.complete();
    this._afterRenderRef.destroy();
    this._renders.complete();
  }
  /** Whether the overlay has attached content. */
  hasAttached() {
    return this._portalOutlet.hasAttached();
  }
  /** Gets an observable that emits when the backdrop has been clicked. */
  backdropClick() {
    return this._backdropClick;
  }
  /** Gets an observable that emits when the overlay has been attached. */
  attachments() {
    return this._attachments;
  }
  /** Gets an observable that emits when the overlay has been detached. */
  detachments() {
    return this._detachments;
  }
  /** Gets an observable of keydown events targeted to this overlay. */
  keydownEvents() {
    return this._keydownEvents;
  }
  /** Gets an observable of pointer events targeted outside this overlay. */
  outsidePointerEvents() {
    return this._outsidePointerEvents;
  }
  /** Gets the current overlay configuration, which is immutable. */
  getConfig() {
    return this._config;
  }
  /** Updates the position of the overlay based on the position strategy. */
  updatePosition() {
    if (this._positionStrategy) {
      this._positionStrategy.apply();
    }
  }
  /** Switches to a new position strategy and updates the overlay position. */
  updatePositionStrategy(strategy) {
    if (strategy === this._positionStrategy) {
      return;
    }
    if (this._positionStrategy) {
      this._positionStrategy.dispose();
    }
    this._positionStrategy = strategy;
    if (this.hasAttached()) {
      strategy.attach(this);
      this.updatePosition();
    }
  }
  /** Update the size properties of the overlay. */
  updateSize(sizeConfig) {
    this._config = __spreadValues(__spreadValues({}, this._config), sizeConfig);
    this._updateElementSize();
  }
  /** Sets the LTR/RTL direction for the overlay. */
  setDirection(dir) {
    this._config = __spreadProps(__spreadValues({}, this._config), {
      direction: dir
    });
    this._updateElementDirection();
  }
  /** Add a CSS class or an array of classes to the overlay pane. */
  addPanelClass(classes) {
    if (this._pane) {
      this._toggleClasses(this._pane, classes, true);
    }
  }
  /** Remove a CSS class or an array of classes from the overlay pane. */
  removePanelClass(classes) {
    if (this._pane) {
      this._toggleClasses(this._pane, classes, false);
    }
  }
  /**
   * Returns the layout direction of the overlay panel.
   */
  getDirection() {
    const direction = this._config.direction;
    if (!direction) {
      return "ltr";
    }
    return typeof direction === "string" ? direction : direction.value;
  }
  /** Switches to a new scroll strategy. */
  updateScrollStrategy(strategy) {
    if (strategy === this._scrollStrategy) {
      return;
    }
    this._disposeScrollStrategy();
    this._scrollStrategy = strategy;
    if (this.hasAttached()) {
      strategy.attach(this);
      strategy.enable();
    }
  }
  /** Updates the text direction of the overlay panel. */
  _updateElementDirection() {
    this._host.setAttribute("dir", this.getDirection());
  }
  /** Updates the size of the overlay element based on the overlay config. */
  _updateElementSize() {
    if (!this._pane) {
      return;
    }
    const style2 = this._pane.style;
    style2.width = coerceCssPixelValue(this._config.width);
    style2.height = coerceCssPixelValue(this._config.height);
    style2.minWidth = coerceCssPixelValue(this._config.minWidth);
    style2.minHeight = coerceCssPixelValue(this._config.minHeight);
    style2.maxWidth = coerceCssPixelValue(this._config.maxWidth);
    style2.maxHeight = coerceCssPixelValue(this._config.maxHeight);
  }
  /** Toggles the pointer events for the overlay pane element. */
  _togglePointerEvents(enablePointer) {
    this._pane.style.pointerEvents = enablePointer ? "" : "none";
  }
  /** Attaches a backdrop for this overlay. */
  _attachBackdrop() {
    const showingClass = "cdk-overlay-backdrop-showing";
    this._backdropRef?.dispose();
    this._backdropRef = new BackdropRef(this._document, this._renderer, this._ngZone, (event) => {
      this._backdropClick.next(event);
    });
    if (this._animationsDisabled) {
      this._backdropRef.element.classList.add("cdk-overlay-backdrop-noop-animation");
    }
    if (this._config.backdropClass) {
      this._toggleClasses(this._backdropRef.element, this._config.backdropClass, true);
    }
    this._host.parentElement.insertBefore(this._backdropRef.element, this._host);
    if (!this._animationsDisabled && typeof requestAnimationFrame !== "undefined") {
      this._ngZone.runOutsideAngular(() => {
        requestAnimationFrame(() => this._backdropRef?.element.classList.add(showingClass));
      });
    } else {
      this._backdropRef.element.classList.add(showingClass);
    }
  }
  /**
   * Updates the stacking order of the element, moving it to the top if necessary.
   * This is required in cases where one overlay was detached, while another one,
   * that should be behind it, was destroyed. The next time both of them are opened,
   * the stacking will be wrong, because the detached element's pane will still be
   * in its original DOM position.
   */
  _updateStackingOrder() {
    if (this._host.nextSibling) {
      this._host.parentNode.appendChild(this._host);
    }
  }
  /** Detaches the backdrop (if any) associated with the overlay. */
  detachBackdrop() {
    if (this._animationsDisabled) {
      this._backdropRef?.dispose();
      this._backdropRef = null;
    } else {
      this._backdropRef?.detach();
    }
  }
  /** Toggles a single CSS class or an array of classes on an element. */
  _toggleClasses(element, cssClasses, isAdd) {
    const classes = coerceArray(cssClasses || []).filter((c) => !!c);
    if (classes.length) {
      isAdd ? element.classList.add(...classes) : element.classList.remove(...classes);
    }
  }
  /** Detaches the overlay content next time the zone stabilizes. */
  _detachContentWhenEmpty() {
    this._ngZone.runOutsideAngular(() => {
      const subscription = this._renders.pipe(takeUntil(merge(this._attachments, this._detachments))).subscribe(() => {
        if (!this._pane || !this._host || this._pane.children.length === 0) {
          if (this._pane && this._config.panelClass) {
            this._toggleClasses(this._pane, this._config.panelClass, false);
          }
          if (this._host && this._host.parentElement) {
            this._previousHostParent = this._host.parentElement;
            this._host.remove();
          }
          subscription.unsubscribe();
        }
      });
    });
  }
  /** Disposes of a scroll strategy. */
  _disposeScrollStrategy() {
    const scrollStrategy = this._scrollStrategy;
    scrollStrategy?.disable();
    scrollStrategy?.detach?.();
  }
};
var boundingBoxClass = "cdk-overlay-connected-position-bounding-box";
var cssUnitPattern = /([A-Za-z%]+)$/;
var FlexibleConnectedPositionStrategy = class {
  _viewportRuler;
  _document;
  _platform;
  _overlayContainer;
  /** The overlay to which this strategy is attached. */
  _overlayRef;
  /** Whether we're performing the very first positioning of the overlay. */
  _isInitialRender;
  /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */
  _lastBoundingBoxSize = {
    width: 0,
    height: 0
  };
  /** Whether the overlay was pushed in a previous positioning. */
  _isPushed = false;
  /** Whether the overlay can be pushed on-screen on the initial open. */
  _canPush = true;
  /** Whether the overlay can grow via flexible width/height after the initial open. */
  _growAfterOpen = false;
  /** Whether the overlay's width and height can be constrained to fit within the viewport. */
  _hasFlexibleDimensions = true;
  /** Whether the overlay position is locked. */
  _positionLocked = false;
  /** Cached origin dimensions */
  _originRect;
  /** Cached overlay dimensions */
  _overlayRect;
  /** Cached viewport dimensions */
  _viewportRect;
  /** Cached container dimensions */
  _containerRect;
  /** Amount of space that must be maintained between the overlay and the edge of the viewport. */
  _viewportMargin = 0;
  /** The Scrollable containers used to check scrollable view properties on position change. */
  _scrollables = [];
  /** Ordered list of preferred positions, from most to least desirable. */
  _preferredPositions = [];
  /** The origin element against which the overlay will be positioned. */
  _origin;
  /** The overlay pane element. */
  _pane;
  /** Whether the strategy has been disposed of already. */
  _isDisposed;
  /**
   * Parent element for the overlay panel used to constrain the overlay panel's size to fit
   * within the viewport.
   */
  _boundingBox;
  /** The last position to have been calculated as the best fit position. */
  _lastPosition;
  /** The last calculated scroll visibility. Only tracked  */
  _lastScrollVisibility;
  /** Subject that emits whenever the position changes. */
  _positionChanges = new Subject();
  /** Subscription to viewport size changes. */
  _resizeSubscription = Subscription.EMPTY;
  /** Default offset for the overlay along the x axis. */
  _offsetX = 0;
  /** Default offset for the overlay along the y axis. */
  _offsetY = 0;
  /** Selector to be used when finding the elements on which to set the transform origin. */
  _transformOriginSelector;
  /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */
  _appliedPanelClasses = [];
  /** Amount by which the overlay was pushed in each axis during the last time it was positioned. */
  _previousPushAmount;
  /** Observable sequence of position changes. */
  positionChanges = this._positionChanges;
  /** Ordered list of preferred positions, from most to least desirable. */
  get positions() {
    return this._preferredPositions;
  }
  constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {
    this._viewportRuler = _viewportRuler;
    this._document = _document;
    this._platform = _platform;
    this._overlayContainer = _overlayContainer;
    this.setOrigin(connectedTo);
  }
  /** Attaches this position strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && overlayRef !== this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("This position strategy is already attached to an overlay");
    }
    this._validatePositions();
    overlayRef.hostElement.classList.add(boundingBoxClass);
    this._overlayRef = overlayRef;
    this._boundingBox = overlayRef.hostElement;
    this._pane = overlayRef.overlayElement;
    this._isDisposed = false;
    this._isInitialRender = true;
    this._lastPosition = null;
    this._resizeSubscription.unsubscribe();
    this._resizeSubscription = this._viewportRuler.change().subscribe(() => {
      this._isInitialRender = true;
      this.apply();
    });
  }
  /**
   * Updates the position of the overlay element, using whichever preferred position relative
   * to the origin best fits on-screen.
   *
   * The selection of a position goes as follows:
   *  - If any positions fit completely within the viewport as-is,
   *      choose the first position that does so.
   *  - If flexible dimensions are enabled and at least one satisfies the given minimum width/height,
   *      choose the position with the greatest available size modified by the positions' weight.
   *  - If pushing is enabled, take the position that went off-screen the least and push it
   *      on-screen.
   *  - If none of the previous criteria were met, use the position that goes off-screen the least.
   * @docs-private
   */
  apply() {
    if (this._isDisposed || !this._platform.isBrowser) {
      return;
    }
    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
      this.reapplyLastPosition();
      return;
    }
    this._clearPanelClasses();
    this._resetOverlayElementStyles();
    this._resetBoundingBoxStyles();
    this._viewportRect = this._getNarrowedViewportRect();
    this._originRect = this._getOriginRect();
    this._overlayRect = this._pane.getBoundingClientRect();
    this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
    const originRect = this._originRect;
    const overlayRect = this._overlayRect;
    const viewportRect = this._viewportRect;
    const containerRect = this._containerRect;
    const flexibleFits = [];
    let fallback;
    for (let pos of this._preferredPositions) {
      let originPoint = this._getOriginPoint(originRect, containerRect, pos);
      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);
      let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);
      if (overlayFit.isCompletelyWithinViewport) {
        this._isPushed = false;
        this._applyPosition(pos, originPoint);
        return;
      }
      if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {
        flexibleFits.push({
          position: pos,
          origin: originPoint,
          overlayRect,
          boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)
        });
        continue;
      }
      if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {
        fallback = {
          overlayFit,
          overlayPoint,
          originPoint,
          position: pos,
          overlayRect
        };
      }
    }
    if (flexibleFits.length) {
      let bestFit = null;
      let bestScore = -1;
      for (const fit of flexibleFits) {
        const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);
        if (score > bestScore) {
          bestScore = score;
          bestFit = fit;
        }
      }
      this._isPushed = false;
      this._applyPosition(bestFit.position, bestFit.origin);
      return;
    }
    if (this._canPush) {
      this._isPushed = true;
      this._applyPosition(fallback.position, fallback.originPoint);
      return;
    }
    this._applyPosition(fallback.position, fallback.originPoint);
  }
  detach() {
    this._clearPanelClasses();
    this._lastPosition = null;
    this._previousPushAmount = null;
    this._resizeSubscription.unsubscribe();
  }
  /** Cleanup after the element gets destroyed. */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    if (this._boundingBox) {
      extendStyles(this._boundingBox.style, {
        top: "",
        left: "",
        right: "",
        bottom: "",
        height: "",
        width: "",
        alignItems: "",
        justifyContent: ""
      });
    }
    if (this._pane) {
      this._resetOverlayElementStyles();
    }
    if (this._overlayRef) {
      this._overlayRef.hostElement.classList.remove(boundingBoxClass);
    }
    this.detach();
    this._positionChanges.complete();
    this._overlayRef = this._boundingBox = null;
    this._isDisposed = true;
  }
  /**
   * This re-aligns the overlay element with the trigger in its last calculated position,
   * even if a position higher in the "preferred positions" list would now fit. This
   * allows one to re-align the panel without changing the orientation of the panel.
   */
  reapplyLastPosition() {
    if (this._isDisposed || !this._platform.isBrowser) {
      return;
    }
    const lastPosition = this._lastPosition;
    if (lastPosition) {
      this._originRect = this._getOriginRect();
      this._overlayRect = this._pane.getBoundingClientRect();
      this._viewportRect = this._getNarrowedViewportRect();
      this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
      const originPoint = this._getOriginPoint(this._originRect, this._containerRect, lastPosition);
      this._applyPosition(lastPosition, originPoint);
    } else {
      this.apply();
    }
  }
  /**
   * Sets the list of Scrollable containers that host the origin element so that
   * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
   * Scrollable must be an ancestor element of the strategy's origin element.
   */
  withScrollableContainers(scrollables) {
    this._scrollables = scrollables;
    return this;
  }
  /**
   * Adds new preferred positions.
   * @param positions List of positions options for this overlay.
   */
  withPositions(positions) {
    this._preferredPositions = positions;
    if (positions.indexOf(this._lastPosition) === -1) {
      this._lastPosition = null;
    }
    this._validatePositions();
    return this;
  }
  /**
   * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
   * @param margin Required margin between the overlay and the viewport edge in pixels.
   */
  withViewportMargin(margin) {
    this._viewportMargin = margin;
    return this;
  }
  /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */
  withFlexibleDimensions(flexibleDimensions = true) {
    this._hasFlexibleDimensions = flexibleDimensions;
    return this;
  }
  /** Sets whether the overlay can grow after the initial open via flexible width/height. */
  withGrowAfterOpen(growAfterOpen = true) {
    this._growAfterOpen = growAfterOpen;
    return this;
  }
  /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */
  withPush(canPush = true) {
    this._canPush = canPush;
    return this;
  }
  /**
   * Sets whether the overlay's position should be locked in after it is positioned
   * initially. When an overlay is locked in, it won't attempt to reposition itself
   * when the position is re-applied (e.g. when the user scrolls away).
   * @param isLocked Whether the overlay should locked in.
   */
  withLockedPosition(isLocked = true) {
    this._positionLocked = isLocked;
    return this;
  }
  /**
   * Sets the origin, relative to which to position the overlay.
   * Using an element origin is useful for building components that need to be positioned
   * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be
   * used for cases like contextual menus which open relative to the user's pointer.
   * @param origin Reference to the new origin.
   */
  setOrigin(origin) {
    this._origin = origin;
    return this;
  }
  /**
   * Sets the default offset for the overlay's connection point on the x-axis.
   * @param offset New offset in the X axis.
   */
  withDefaultOffsetX(offset) {
    this._offsetX = offset;
    return this;
  }
  /**
   * Sets the default offset for the overlay's connection point on the y-axis.
   * @param offset New offset in the Y axis.
   */
  withDefaultOffsetY(offset) {
    this._offsetY = offset;
    return this;
  }
  /**
   * Configures that the position strategy should set a `transform-origin` on some elements
   * inside the overlay, depending on the current position that is being applied. This is
   * useful for the cases where the origin of an animation can change depending on the
   * alignment of the overlay.
   * @param selector CSS selector that will be used to find the target
   *    elements onto which to set the transform origin.
   */
  withTransformOriginOn(selector) {
    this._transformOriginSelector = selector;
    return this;
  }
  /**
   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
   */
  _getOriginPoint(originRect, containerRect, pos) {
    let x;
    if (pos.originX == "center") {
      x = originRect.left + originRect.width / 2;
    } else {
      const startX = this._isRtl() ? originRect.right : originRect.left;
      const endX = this._isRtl() ? originRect.left : originRect.right;
      x = pos.originX == "start" ? startX : endX;
    }
    if (containerRect.left < 0) {
      x -= containerRect.left;
    }
    let y;
    if (pos.originY == "center") {
      y = originRect.top + originRect.height / 2;
    } else {
      y = pos.originY == "top" ? originRect.top : originRect.bottom;
    }
    if (containerRect.top < 0) {
      y -= containerRect.top;
    }
    return {
      x,
      y
    };
  }
  /**
   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
   * origin point to which the overlay should be connected.
   */
  _getOverlayPoint(originPoint, overlayRect, pos) {
    let overlayStartX;
    if (pos.overlayX == "center") {
      overlayStartX = -overlayRect.width / 2;
    } else if (pos.overlayX === "start") {
      overlayStartX = this._isRtl() ? -overlayRect.width : 0;
    } else {
      overlayStartX = this._isRtl() ? 0 : -overlayRect.width;
    }
    let overlayStartY;
    if (pos.overlayY == "center") {
      overlayStartY = -overlayRect.height / 2;
    } else {
      overlayStartY = pos.overlayY == "top" ? 0 : -overlayRect.height;
    }
    return {
      x: originPoint.x + overlayStartX,
      y: originPoint.y + overlayStartY
    };
  }
  /** Gets how well an overlay at the given point will fit within the viewport. */
  _getOverlayFit(point, rawOverlayRect, viewport, position) {
    const overlay = getRoundedBoundingClientRect(rawOverlayRect);
    let {
      x,
      y
    } = point;
    let offsetX = this._getOffset(position, "x");
    let offsetY = this._getOffset(position, "y");
    if (offsetX) {
      x += offsetX;
    }
    if (offsetY) {
      y += offsetY;
    }
    let leftOverflow = 0 - x;
    let rightOverflow = x + overlay.width - viewport.width;
    let topOverflow = 0 - y;
    let bottomOverflow = y + overlay.height - viewport.height;
    let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);
    let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);
    let visibleArea = visibleWidth * visibleHeight;
    return {
      visibleArea,
      isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,
      fitsInViewportVertically: visibleHeight === overlay.height,
      fitsInViewportHorizontally: visibleWidth == overlay.width
    };
  }
  /**
   * Whether the overlay can fit within the viewport when it may resize either its width or height.
   * @param fit How well the overlay fits in the viewport at some position.
   * @param point The (x, y) coordinates of the overlay at some position.
   * @param viewport The geometry of the viewport.
   */
  _canFitWithFlexibleDimensions(fit, point, viewport) {
    if (this._hasFlexibleDimensions) {
      const availableHeight = viewport.bottom - point.y;
      const availableWidth = viewport.right - point.x;
      const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);
      const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);
      const verticalFit = fit.fitsInViewportVertically || minHeight != null && minHeight <= availableHeight;
      const horizontalFit = fit.fitsInViewportHorizontally || minWidth != null && minWidth <= availableWidth;
      return verticalFit && horizontalFit;
    }
    return false;
  }
  /**
   * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
   * the viewport, the top-left corner will be pushed on-screen (with overflow occurring on the
   * right and bottom).
   *
   * @param start Starting point from which the overlay is pushed.
   * @param rawOverlayRect Dimensions of the overlay.
   * @param scrollPosition Current viewport scroll position.
   * @returns The point at which to position the overlay after pushing. This is effectively a new
   *     originPoint.
   */
  _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {
    if (this._previousPushAmount && this._positionLocked) {
      return {
        x: start.x + this._previousPushAmount.x,
        y: start.y + this._previousPushAmount.y
      };
    }
    const overlay = getRoundedBoundingClientRect(rawOverlayRect);
    const viewport = this._viewportRect;
    const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);
    const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);
    const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);
    const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);
    let pushX = 0;
    let pushY = 0;
    if (overlay.width <= viewport.width) {
      pushX = overflowLeft || -overflowRight;
    } else {
      pushX = start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0;
    }
    if (overlay.height <= viewport.height) {
      pushY = overflowTop || -overflowBottom;
    } else {
      pushY = start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0;
    }
    this._previousPushAmount = {
      x: pushX,
      y: pushY
    };
    return {
      x: start.x + pushX,
      y: start.y + pushY
    };
  }
  /**
   * Applies a computed position to the overlay and emits a position change.
   * @param position The position preference
   * @param originPoint The point on the origin element where the overlay is connected.
   */
  _applyPosition(position, originPoint) {
    this._setTransformOrigin(position);
    this._setOverlayElementStyles(originPoint, position);
    this._setBoundingBoxStyles(originPoint, position);
    if (position.panelClass) {
      this._addPanelClasses(position.panelClass);
    }
    if (this._positionChanges.observers.length) {
      const scrollVisibility = this._getScrollVisibility();
      if (position !== this._lastPosition || !this._lastScrollVisibility || !compareScrollVisibility(this._lastScrollVisibility, scrollVisibility)) {
        const changeEvent = new ConnectedOverlayPositionChange(position, scrollVisibility);
        this._positionChanges.next(changeEvent);
      }
      this._lastScrollVisibility = scrollVisibility;
    }
    this._lastPosition = position;
    this._isInitialRender = false;
  }
  /** Sets the transform origin based on the configured selector and the passed-in position.  */
  _setTransformOrigin(position) {
    if (!this._transformOriginSelector) {
      return;
    }
    const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);
    let xOrigin;
    let yOrigin = position.overlayY;
    if (position.overlayX === "center") {
      xOrigin = "center";
    } else if (this._isRtl()) {
      xOrigin = position.overlayX === "start" ? "right" : "left";
    } else {
      xOrigin = position.overlayX === "start" ? "left" : "right";
    }
    for (let i = 0; i < elements.length; i++) {
      elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;
    }
  }
  /**
   * Gets the position and size of the overlay's sizing container.
   *
   * This method does no measuring and applies no styles so that we can cheaply compute the
   * bounds for all positions and choose the best fit based on these results.
   */
  _calculateBoundingBoxRect(origin, position) {
    const viewport = this._viewportRect;
    const isRtl = this._isRtl();
    let height, top, bottom;
    if (position.overlayY === "top") {
      top = origin.y;
      height = viewport.height - top + this._viewportMargin;
    } else if (position.overlayY === "bottom") {
      bottom = viewport.height - origin.y + this._viewportMargin * 2;
      height = viewport.height - bottom + this._viewportMargin;
    } else {
      const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);
      const previousHeight = this._lastBoundingBoxSize.height;
      height = smallestDistanceToViewportEdge * 2;
      top = origin.y - smallestDistanceToViewportEdge;
      if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {
        top = origin.y - previousHeight / 2;
      }
    }
    const isBoundedByRightViewportEdge = position.overlayX === "start" && !isRtl || position.overlayX === "end" && isRtl;
    const isBoundedByLeftViewportEdge = position.overlayX === "end" && !isRtl || position.overlayX === "start" && isRtl;
    let width, left, right;
    if (isBoundedByLeftViewportEdge) {
      right = viewport.width - origin.x + this._viewportMargin * 2;
      width = origin.x - this._viewportMargin;
    } else if (isBoundedByRightViewportEdge) {
      left = origin.x;
      width = viewport.right - origin.x;
    } else {
      const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);
      const previousWidth = this._lastBoundingBoxSize.width;
      width = smallestDistanceToViewportEdge * 2;
      left = origin.x - smallestDistanceToViewportEdge;
      if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {
        left = origin.x - previousWidth / 2;
      }
    }
    return {
      top,
      left,
      bottom,
      right,
      width,
      height
    };
  }
  /**
   * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
   * origin's connection point and stretches to the bounds of the viewport.
   *
   * @param origin The point on the origin element where the overlay is connected.
   * @param position The position preference
   */
  _setBoundingBoxStyles(origin, position) {
    const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);
    if (!this._isInitialRender && !this._growAfterOpen) {
      boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);
      boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);
    }
    const styles = {};
    if (this._hasExactPosition()) {
      styles.top = styles.left = "0";
      styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = "";
      styles.width = styles.height = "100%";
    } else {
      const maxHeight = this._overlayRef.getConfig().maxHeight;
      const maxWidth = this._overlayRef.getConfig().maxWidth;
      styles.height = coerceCssPixelValue(boundingBoxRect.height);
      styles.top = coerceCssPixelValue(boundingBoxRect.top);
      styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);
      styles.width = coerceCssPixelValue(boundingBoxRect.width);
      styles.left = coerceCssPixelValue(boundingBoxRect.left);
      styles.right = coerceCssPixelValue(boundingBoxRect.right);
      if (position.overlayX === "center") {
        styles.alignItems = "center";
      } else {
        styles.alignItems = position.overlayX === "end" ? "flex-end" : "flex-start";
      }
      if (position.overlayY === "center") {
        styles.justifyContent = "center";
      } else {
        styles.justifyContent = position.overlayY === "bottom" ? "flex-end" : "flex-start";
      }
      if (maxHeight) {
        styles.maxHeight = coerceCssPixelValue(maxHeight);
      }
      if (maxWidth) {
        styles.maxWidth = coerceCssPixelValue(maxWidth);
      }
    }
    this._lastBoundingBoxSize = boundingBoxRect;
    extendStyles(this._boundingBox.style, styles);
  }
  /** Resets the styles for the bounding box so that a new positioning can be computed. */
  _resetBoundingBoxStyles() {
    extendStyles(this._boundingBox.style, {
      top: "0",
      left: "0",
      right: "0",
      bottom: "0",
      height: "",
      width: "",
      alignItems: "",
      justifyContent: ""
    });
  }
  /** Resets the styles for the overlay pane so that a new positioning can be computed. */
  _resetOverlayElementStyles() {
    extendStyles(this._pane.style, {
      top: "",
      left: "",
      bottom: "",
      right: "",
      position: "",
      transform: ""
    });
  }
  /** Sets positioning styles to the overlay element. */
  _setOverlayElementStyles(originPoint, position) {
    const styles = {};
    const hasExactPosition = this._hasExactPosition();
    const hasFlexibleDimensions = this._hasFlexibleDimensions;
    const config = this._overlayRef.getConfig();
    if (hasExactPosition) {
      const scrollPosition = this._viewportRuler.getViewportScrollPosition();
      extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));
      extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));
    } else {
      styles.position = "static";
    }
    let transformString = "";
    let offsetX = this._getOffset(position, "x");
    let offsetY = this._getOffset(position, "y");
    if (offsetX) {
      transformString += `translateX(${offsetX}px) `;
    }
    if (offsetY) {
      transformString += `translateY(${offsetY}px)`;
    }
    styles.transform = transformString.trim();
    if (config.maxHeight) {
      if (hasExactPosition) {
        styles.maxHeight = coerceCssPixelValue(config.maxHeight);
      } else if (hasFlexibleDimensions) {
        styles.maxHeight = "";
      }
    }
    if (config.maxWidth) {
      if (hasExactPosition) {
        styles.maxWidth = coerceCssPixelValue(config.maxWidth);
      } else if (hasFlexibleDimensions) {
        styles.maxWidth = "";
      }
    }
    extendStyles(this._pane.style, styles);
  }
  /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */
  _getExactOverlayY(position, originPoint, scrollPosition) {
    let styles = {
      top: "",
      bottom: ""
    };
    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
    if (this._isPushed) {
      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
    }
    if (position.overlayY === "bottom") {
      const documentHeight = this._document.documentElement.clientHeight;
      styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;
    } else {
      styles.top = coerceCssPixelValue(overlayPoint.y);
    }
    return styles;
  }
  /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */
  _getExactOverlayX(position, originPoint, scrollPosition) {
    let styles = {
      left: "",
      right: ""
    };
    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
    if (this._isPushed) {
      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
    }
    let horizontalStyleProperty;
    if (this._isRtl()) {
      horizontalStyleProperty = position.overlayX === "end" ? "left" : "right";
    } else {
      horizontalStyleProperty = position.overlayX === "end" ? "right" : "left";
    }
    if (horizontalStyleProperty === "right") {
      const documentWidth = this._document.documentElement.clientWidth;
      styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;
    } else {
      styles.left = coerceCssPixelValue(overlayPoint.x);
    }
    return styles;
  }
  /**
   * Gets the view properties of the trigger and overlay, including whether they are clipped
   * or completely outside the view of any of the strategy's scrollables.
   */
  _getScrollVisibility() {
    const originBounds = this._getOriginRect();
    const overlayBounds = this._pane.getBoundingClientRect();
    const scrollContainerBounds = this._scrollables.map((scrollable) => {
      return scrollable.getElementRef().nativeElement.getBoundingClientRect();
    });
    return {
      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),
      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),
      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),
      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds)
    };
  }
  /** Subtracts the amount that an element is overflowing on an axis from its length. */
  _subtractOverflows(length, ...overflows) {
    return overflows.reduce((currentValue, currentOverflow) => {
      return currentValue - Math.max(currentOverflow, 0);
    }, length);
  }
  /** Narrows the given viewport rect by the current _viewportMargin. */
  _getNarrowedViewportRect() {
    const width = this._document.documentElement.clientWidth;
    const height = this._document.documentElement.clientHeight;
    const scrollPosition = this._viewportRuler.getViewportScrollPosition();
    return {
      top: scrollPosition.top + this._viewportMargin,
      left: scrollPosition.left + this._viewportMargin,
      right: scrollPosition.left + width - this._viewportMargin,
      bottom: scrollPosition.top + height - this._viewportMargin,
      width: width - 2 * this._viewportMargin,
      height: height - 2 * this._viewportMargin
    };
  }
  /** Whether the we're dealing with an RTL context */
  _isRtl() {
    return this._overlayRef.getDirection() === "rtl";
  }
  /** Determines whether the overlay uses exact or flexible positioning. */
  _hasExactPosition() {
    return !this._hasFlexibleDimensions || this._isPushed;
  }
  /** Retrieves the offset of a position along the x or y axis. */
  _getOffset(position, axis) {
    if (axis === "x") {
      return position.offsetX == null ? this._offsetX : position.offsetX;
    }
    return position.offsetY == null ? this._offsetY : position.offsetY;
  }
  /** Validates that the current position match the expected values. */
  _validatePositions() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!this._preferredPositions.length) {
        throw Error("FlexibleConnectedPositionStrategy: At least one position is required.");
      }
      this._preferredPositions.forEach((pair) => {
        validateHorizontalPosition("originX", pair.originX);
        validateVerticalPosition("originY", pair.originY);
        validateHorizontalPosition("overlayX", pair.overlayX);
        validateVerticalPosition("overlayY", pair.overlayY);
      });
    }
  }
  /** Adds a single CSS class or an array of classes on the overlay panel. */
  _addPanelClasses(cssClasses) {
    if (this._pane) {
      coerceArray(cssClasses).forEach((cssClass) => {
        if (cssClass !== "" && this._appliedPanelClasses.indexOf(cssClass) === -1) {
          this._appliedPanelClasses.push(cssClass);
          this._pane.classList.add(cssClass);
        }
      });
    }
  }
  /** Clears the classes that the position strategy has applied from the overlay panel. */
  _clearPanelClasses() {
    if (this._pane) {
      this._appliedPanelClasses.forEach((cssClass) => {
        this._pane.classList.remove(cssClass);
      });
      this._appliedPanelClasses = [];
    }
  }
  /** Returns the DOMRect of the current origin. */
  _getOriginRect() {
    const origin = this._origin;
    if (origin instanceof ElementRef) {
      return origin.nativeElement.getBoundingClientRect();
    }
    if (origin instanceof Element) {
      return origin.getBoundingClientRect();
    }
    const width = origin.width || 0;
    const height = origin.height || 0;
    return {
      top: origin.y,
      bottom: origin.y + height,
      left: origin.x,
      right: origin.x + width,
      height,
      width
    };
  }
};
function extendStyles(destination, source) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      destination[key] = source[key];
    }
  }
  return destination;
}
function getPixelValue(input) {
  if (typeof input !== "number" && input != null) {
    const [value, units] = input.split(cssUnitPattern);
    return !units || units === "px" ? parseFloat(value) : null;
  }
  return input || null;
}
function getRoundedBoundingClientRect(clientRect) {
  return {
    top: Math.floor(clientRect.top),
    right: Math.floor(clientRect.right),
    bottom: Math.floor(clientRect.bottom),
    left: Math.floor(clientRect.left),
    width: Math.floor(clientRect.width),
    height: Math.floor(clientRect.height)
  };
}
function compareScrollVisibility(a, b) {
  if (a === b) {
    return true;
  }
  return a.isOriginClipped === b.isOriginClipped && a.isOriginOutsideView === b.isOriginOutsideView && a.isOverlayClipped === b.isOverlayClipped && a.isOverlayOutsideView === b.isOverlayOutsideView;
}
var wrapperClass = "cdk-global-overlay-wrapper";
var GlobalPositionStrategy = class {
  /** The overlay to which this strategy is attached. */
  _overlayRef;
  _cssPosition = "static";
  _topOffset = "";
  _bottomOffset = "";
  _alignItems = "";
  _xPosition = "";
  _xOffset = "";
  _width = "";
  _height = "";
  _isDisposed = false;
  attach(overlayRef) {
    const config = overlayRef.getConfig();
    this._overlayRef = overlayRef;
    if (this._width && !config.width) {
      overlayRef.updateSize({
        width: this._width
      });
    }
    if (this._height && !config.height) {
      overlayRef.updateSize({
        height: this._height
      });
    }
    overlayRef.hostElement.classList.add(wrapperClass);
    this._isDisposed = false;
  }
  /**
   * Sets the top position of the overlay. Clears any previously set vertical position.
   * @param value New top offset.
   */
  top(value = "") {
    this._bottomOffset = "";
    this._topOffset = value;
    this._alignItems = "flex-start";
    return this;
  }
  /**
   * Sets the left position of the overlay. Clears any previously set horizontal position.
   * @param value New left offset.
   */
  left(value = "") {
    this._xOffset = value;
    this._xPosition = "left";
    return this;
  }
  /**
   * Sets the bottom position of the overlay. Clears any previously set vertical position.
   * @param value New bottom offset.
   */
  bottom(value = "") {
    this._topOffset = "";
    this._bottomOffset = value;
    this._alignItems = "flex-end";
    return this;
  }
  /**
   * Sets the right position of the overlay. Clears any previously set horizontal position.
   * @param value New right offset.
   */
  right(value = "") {
    this._xOffset = value;
    this._xPosition = "right";
    return this;
  }
  /**
   * Sets the overlay to the start of the viewport, depending on the overlay direction.
   * This will be to the left in LTR layouts and to the right in RTL.
   * @param offset Offset from the edge of the screen.
   */
  start(value = "") {
    this._xOffset = value;
    this._xPosition = "start";
    return this;
  }
  /**
   * Sets the overlay to the end of the viewport, depending on the overlay direction.
   * This will be to the right in LTR layouts and to the left in RTL.
   * @param offset Offset from the edge of the screen.
   */
  end(value = "") {
    this._xOffset = value;
    this._xPosition = "end";
    return this;
  }
  /**
   * Sets the overlay width and clears any previously set width.
   * @param value New width for the overlay
   * @deprecated Pass the `width` through the `OverlayConfig`.
   * @breaking-change 8.0.0
   */
  width(value = "") {
    if (this._overlayRef) {
      this._overlayRef.updateSize({
        width: value
      });
    } else {
      this._width = value;
    }
    return this;
  }
  /**
   * Sets the overlay height and clears any previously set height.
   * @param value New height for the overlay
   * @deprecated Pass the `height` through the `OverlayConfig`.
   * @breaking-change 8.0.0
   */
  height(value = "") {
    if (this._overlayRef) {
      this._overlayRef.updateSize({
        height: value
      });
    } else {
      this._height = value;
    }
    return this;
  }
  /**
   * Centers the overlay horizontally with an optional offset.
   * Clears any previously set horizontal position.
   *
   * @param offset Overlay offset from the horizontal center.
   */
  centerHorizontally(offset = "") {
    this.left(offset);
    this._xPosition = "center";
    return this;
  }
  /**
   * Centers the overlay vertically with an optional offset.
   * Clears any previously set vertical position.
   *
   * @param offset Overlay offset from the vertical center.
   */
  centerVertically(offset = "") {
    this.top(offset);
    this._alignItems = "center";
    return this;
  }
  /**
   * Apply the position to the element.
   * @docs-private
   */
  apply() {
    if (!this._overlayRef || !this._overlayRef.hasAttached()) {
      return;
    }
    const styles = this._overlayRef.overlayElement.style;
    const parentStyles = this._overlayRef.hostElement.style;
    const config = this._overlayRef.getConfig();
    const {
      width,
      height,
      maxWidth,
      maxHeight
    } = config;
    const shouldBeFlushHorizontally = (width === "100%" || width === "100vw") && (!maxWidth || maxWidth === "100%" || maxWidth === "100vw");
    const shouldBeFlushVertically = (height === "100%" || height === "100vh") && (!maxHeight || maxHeight === "100%" || maxHeight === "100vh");
    const xPosition = this._xPosition;
    const xOffset = this._xOffset;
    const isRtl = this._overlayRef.getConfig().direction === "rtl";
    let marginLeft = "";
    let marginRight = "";
    let justifyContent = "";
    if (shouldBeFlushHorizontally) {
      justifyContent = "flex-start";
    } else if (xPosition === "center") {
      justifyContent = "center";
      if (isRtl) {
        marginRight = xOffset;
      } else {
        marginLeft = xOffset;
      }
    } else if (isRtl) {
      if (xPosition === "left" || xPosition === "end") {
        justifyContent = "flex-end";
        marginLeft = xOffset;
      } else if (xPosition === "right" || xPosition === "start") {
        justifyContent = "flex-start";
        marginRight = xOffset;
      }
    } else if (xPosition === "left" || xPosition === "start") {
      justifyContent = "flex-start";
      marginLeft = xOffset;
    } else if (xPosition === "right" || xPosition === "end") {
      justifyContent = "flex-end";
      marginRight = xOffset;
    }
    styles.position = this._cssPosition;
    styles.marginLeft = shouldBeFlushHorizontally ? "0" : marginLeft;
    styles.marginTop = shouldBeFlushVertically ? "0" : this._topOffset;
    styles.marginBottom = this._bottomOffset;
    styles.marginRight = shouldBeFlushHorizontally ? "0" : marginRight;
    parentStyles.justifyContent = justifyContent;
    parentStyles.alignItems = shouldBeFlushVertically ? "flex-start" : this._alignItems;
  }
  /**
   * Cleans up the DOM changes from the position strategy.
   * @docs-private
   */
  dispose() {
    if (this._isDisposed || !this._overlayRef) {
      return;
    }
    const styles = this._overlayRef.overlayElement.style;
    const parent = this._overlayRef.hostElement;
    const parentStyles = parent.style;
    parent.classList.remove(wrapperClass);
    parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop = styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = "";
    this._overlayRef = null;
    this._isDisposed = true;
  }
};
var OverlayPositionBuilder = class _OverlayPositionBuilder {
  _viewportRuler = inject(ViewportRuler);
  _document = inject(DOCUMENT);
  _platform = inject(Platform);
  _overlayContainer = inject(OverlayContainer);
  constructor() {
  }
  /**
   * Creates a global position strategy.
   */
  global() {
    return new GlobalPositionStrategy();
  }
  /**
   * Creates a flexible position strategy.
   * @param origin Origin relative to which to position the overlay.
   */
  flexibleConnectedTo(origin) {
    return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
  }
  static ɵfac = function OverlayPositionBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OverlayPositionBuilder)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _OverlayPositionBuilder,
    factory: _OverlayPositionBuilder.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayPositionBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var Overlay = class _Overlay {
  scrollStrategies = inject(ScrollStrategyOptions);
  _overlayContainer = inject(OverlayContainer);
  _positionBuilder = inject(OverlayPositionBuilder);
  _keyboardDispatcher = inject(OverlayKeyboardDispatcher);
  _injector = inject(Injector);
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  _directionality = inject(Directionality);
  _location = inject(Location);
  _outsideClickDispatcher = inject(OverlayOutsideClickDispatcher);
  _animationsModuleType = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  _idGenerator = inject(_IdGenerator);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _appRef;
  _styleLoader = inject(_CdkPrivateStyleLoader);
  constructor() {
  }
  /**
   * Creates an overlay.
   * @param config Configuration applied to the overlay.
   * @returns Reference to the created overlay.
   */
  create(config) {
    this._styleLoader.load(_CdkOverlayStyleLoader);
    const host = this._createHostElement();
    const pane = this._createPaneElement(host);
    const portalOutlet = this._createPortalOutlet(pane);
    const overlayConfig = new OverlayConfig(config);
    overlayConfig.direction = overlayConfig.direction || this._directionality.value;
    return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher, this._animationsModuleType === "NoopAnimations", this._injector.get(EnvironmentInjector), this._renderer);
  }
  /**
   * Gets a position builder that can be used, via fluent API,
   * to construct and configure a position strategy.
   * @returns An overlay position builder.
   */
  position() {
    return this._positionBuilder;
  }
  /**
   * Creates the DOM element for an overlay and appends it to the overlay container.
   * @returns Newly-created pane element
   */
  _createPaneElement(host) {
    const pane = this._document.createElement("div");
    pane.id = this._idGenerator.getId("cdk-overlay-");
    pane.classList.add("cdk-overlay-pane");
    host.appendChild(pane);
    return pane;
  }
  /**
   * Creates the host element that wraps around an overlay
   * and can be used for advanced positioning.
   * @returns Newly-create host element.
   */
  _createHostElement() {
    const host = this._document.createElement("div");
    this._overlayContainer.getContainerElement().appendChild(host);
    return host;
  }
  /**
   * Create a DomPortalOutlet into which the overlay content can be loaded.
   * @param pane The DOM element to turn into a portal outlet.
   * @returns A portal outlet for the given DOM element.
   */
  _createPortalOutlet(pane) {
    if (!this._appRef) {
      this._appRef = this._injector.get(ApplicationRef);
    }
    return new DomPortalOutlet(pane, null, this._appRef, this._injector, this._document);
  }
  static ɵfac = function Overlay_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Overlay)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _Overlay,
    factory: _Overlay.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Overlay, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var defaultPositionList = [{
  originX: "start",
  originY: "bottom",
  overlayX: "start",
  overlayY: "top"
}, {
  originX: "start",
  originY: "top",
  overlayX: "start",
  overlayY: "bottom"
}, {
  originX: "end",
  originY: "top",
  overlayX: "end",
  overlayY: "bottom"
}, {
  originX: "end",
  originY: "bottom",
  overlayX: "end",
  overlayY: "top"
}];
var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken("cdk-connected-overlay-scroll-strategy", {
  providedIn: "root",
  factory: () => {
    const overlay = inject(Overlay);
    return () => overlay.scrollStrategies.reposition();
  }
});
var CdkOverlayOrigin = class _CdkOverlayOrigin {
  elementRef = inject(ElementRef);
  constructor() {
  }
  static ɵfac = function CdkOverlayOrigin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkOverlayOrigin)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkOverlayOrigin,
    selectors: [["", "cdk-overlay-origin", ""], ["", "overlay-origin", ""], ["", "cdkOverlayOrigin", ""]],
    exportAs: ["cdkOverlayOrigin"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkOverlayOrigin, [{
    type: Directive,
    args: [{
      selector: "[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]",
      exportAs: "cdkOverlayOrigin"
    }]
  }], () => [], null);
})();
var CdkConnectedOverlay = class _CdkConnectedOverlay {
  _overlay = inject(Overlay);
  _dir = inject(Directionality, {
    optional: true
  });
  _overlayRef;
  _templatePortal;
  _backdropSubscription = Subscription.EMPTY;
  _attachSubscription = Subscription.EMPTY;
  _detachSubscription = Subscription.EMPTY;
  _positionSubscription = Subscription.EMPTY;
  _offsetX;
  _offsetY;
  _position;
  _scrollStrategyFactory = inject(CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY);
  _disposeOnNavigation = false;
  _ngZone = inject(NgZone);
  /** Origin for the connected overlay. */
  origin;
  /** Registered connected position pairs. */
  positions;
  /**
   * This input overrides the positions input if specified. It lets users pass
   * in arbitrary positioning strategies.
   */
  positionStrategy;
  /** The offset in pixels for the overlay connection point on the x-axis */
  get offsetX() {
    return this._offsetX;
  }
  set offsetX(offsetX) {
    this._offsetX = offsetX;
    if (this._position) {
      this._updatePositionStrategy(this._position);
    }
  }
  /** The offset in pixels for the overlay connection point on the y-axis */
  get offsetY() {
    return this._offsetY;
  }
  set offsetY(offsetY) {
    this._offsetY = offsetY;
    if (this._position) {
      this._updatePositionStrategy(this._position);
    }
  }
  /** The width of the overlay panel. */
  width;
  /** The height of the overlay panel. */
  height;
  /** The min width of the overlay panel. */
  minWidth;
  /** The min height of the overlay panel. */
  minHeight;
  /** The custom class to be set on the backdrop element. */
  backdropClass;
  /** The custom class to add to the overlay pane element. */
  panelClass;
  /** Margin between the overlay and the viewport edges. */
  viewportMargin = 0;
  /** Strategy to be used when handling scroll events while the overlay is open. */
  scrollStrategy;
  /** Whether the overlay is open. */
  open = false;
  /** Whether the overlay can be closed by user interaction. */
  disableClose = false;
  /** CSS selector which to set the transform origin. */
  transformOriginSelector;
  /** Whether or not the overlay should attach a backdrop. */
  hasBackdrop = false;
  /** Whether or not the overlay should be locked when scrolling. */
  lockPosition = false;
  /** Whether the overlay's width and height can be constrained to fit within the viewport. */
  flexibleDimensions = false;
  /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */
  growAfterOpen = false;
  /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */
  push = false;
  /** Whether the overlay should be disposed of when the user goes backwards/forwards in history. */
  get disposeOnNavigation() {
    return this._disposeOnNavigation;
  }
  set disposeOnNavigation(value) {
    this._disposeOnNavigation = value;
  }
  /** Event emitted when the backdrop is clicked. */
  backdropClick = new EventEmitter();
  /** Event emitted when the position has changed. */
  positionChange = new EventEmitter();
  /** Event emitted when the overlay has been attached. */
  attach = new EventEmitter();
  /** Event emitted when the overlay has been detached. */
  detach = new EventEmitter();
  /** Emits when there are keyboard events that are targeted at the overlay. */
  overlayKeydown = new EventEmitter();
  /** Emits when there are mouse outside click events that are targeted at the overlay. */
  overlayOutsideClick = new EventEmitter();
  // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.
  constructor() {
    const templateRef = inject(TemplateRef);
    const viewContainerRef = inject(ViewContainerRef);
    this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);
    this.scrollStrategy = this._scrollStrategyFactory();
  }
  /** The associated overlay reference. */
  get overlayRef() {
    return this._overlayRef;
  }
  /** The element's layout direction. */
  get dir() {
    return this._dir ? this._dir.value : "ltr";
  }
  ngOnDestroy() {
    this._attachSubscription.unsubscribe();
    this._detachSubscription.unsubscribe();
    this._backdropSubscription.unsubscribe();
    this._positionSubscription.unsubscribe();
    this._overlayRef?.dispose();
  }
  ngOnChanges(changes) {
    if (this._position) {
      this._updatePositionStrategy(this._position);
      this._overlayRef?.updateSize({
        width: this.width,
        minWidth: this.minWidth,
        height: this.height,
        minHeight: this.minHeight
      });
      if (changes["origin"] && this.open) {
        this._position.apply();
      }
    }
    if (changes["open"]) {
      this.open ? this.attachOverlay() : this.detachOverlay();
    }
  }
  /** Creates an overlay */
  _createOverlay() {
    if (!this.positions || !this.positions.length) {
      this.positions = defaultPositionList;
    }
    const overlayRef = this._overlayRef = this._overlay.create(this._buildConfig());
    this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());
    this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());
    overlayRef.keydownEvents().subscribe((event) => {
      this.overlayKeydown.next(event);
      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {
        event.preventDefault();
        this.detachOverlay();
      }
    });
    this._overlayRef.outsidePointerEvents().subscribe((event) => {
      const origin = this._getOriginElement();
      const target = _getEventTarget(event);
      if (!origin || origin !== target && !origin.contains(target)) {
        this.overlayOutsideClick.next(event);
      }
    });
  }
  /** Builds the overlay config based on the directive's inputs */
  _buildConfig() {
    const positionStrategy = this._position = this.positionStrategy || this._createPositionStrategy();
    const overlayConfig = new OverlayConfig({
      direction: this._dir || "ltr",
      positionStrategy,
      scrollStrategy: this.scrollStrategy,
      hasBackdrop: this.hasBackdrop,
      disposeOnNavigation: this.disposeOnNavigation
    });
    if (this.width || this.width === 0) {
      overlayConfig.width = this.width;
    }
    if (this.height || this.height === 0) {
      overlayConfig.height = this.height;
    }
    if (this.minWidth || this.minWidth === 0) {
      overlayConfig.minWidth = this.minWidth;
    }
    if (this.minHeight || this.minHeight === 0) {
      overlayConfig.minHeight = this.minHeight;
    }
    if (this.backdropClass) {
      overlayConfig.backdropClass = this.backdropClass;
    }
    if (this.panelClass) {
      overlayConfig.panelClass = this.panelClass;
    }
    return overlayConfig;
  }
  /** Updates the state of a position strategy, based on the values of the directive inputs. */
  _updatePositionStrategy(positionStrategy) {
    const positions = this.positions.map((currentPosition) => ({
      originX: currentPosition.originX,
      originY: currentPosition.originY,
      overlayX: currentPosition.overlayX,
      overlayY: currentPosition.overlayY,
      offsetX: currentPosition.offsetX || this.offsetX,
      offsetY: currentPosition.offsetY || this.offsetY,
      panelClass: currentPosition.panelClass || void 0
    }));
    return positionStrategy.setOrigin(this._getOrigin()).withPositions(positions).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector);
  }
  /** Returns the position strategy of the overlay to be set on the overlay config */
  _createPositionStrategy() {
    const strategy = this._overlay.position().flexibleConnectedTo(this._getOrigin());
    this._updatePositionStrategy(strategy);
    return strategy;
  }
  _getOrigin() {
    if (this.origin instanceof CdkOverlayOrigin) {
      return this.origin.elementRef;
    } else {
      return this.origin;
    }
  }
  _getOriginElement() {
    if (this.origin instanceof CdkOverlayOrigin) {
      return this.origin.elementRef.nativeElement;
    }
    if (this.origin instanceof ElementRef) {
      return this.origin.nativeElement;
    }
    if (typeof Element !== "undefined" && this.origin instanceof Element) {
      return this.origin;
    }
    return null;
  }
  /** Attaches the overlay. */
  attachOverlay() {
    if (!this._overlayRef) {
      this._createOverlay();
    } else {
      this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;
    }
    if (!this._overlayRef.hasAttached()) {
      this._overlayRef.attach(this._templatePortal);
    }
    if (this.hasBackdrop) {
      this._backdropSubscription = this._overlayRef.backdropClick().subscribe((event) => {
        this.backdropClick.emit(event);
      });
    } else {
      this._backdropSubscription.unsubscribe();
    }
    this._positionSubscription.unsubscribe();
    if (this.positionChange.observers.length > 0) {
      this._positionSubscription = this._position.positionChanges.pipe(takeWhile(() => this.positionChange.observers.length > 0)).subscribe((position) => {
        this._ngZone.run(() => this.positionChange.emit(position));
        if (this.positionChange.observers.length === 0) {
          this._positionSubscription.unsubscribe();
        }
      });
    }
    this.open = true;
  }
  /** Detaches the overlay. */
  detachOverlay() {
    this._overlayRef?.detach();
    this._backdropSubscription.unsubscribe();
    this._positionSubscription.unsubscribe();
    this.open = false;
  }
  static ɵfac = function CdkConnectedOverlay_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkConnectedOverlay)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkConnectedOverlay,
    selectors: [["", "cdk-connected-overlay", ""], ["", "connected-overlay", ""], ["", "cdkConnectedOverlay", ""]],
    inputs: {
      origin: [0, "cdkConnectedOverlayOrigin", "origin"],
      positions: [0, "cdkConnectedOverlayPositions", "positions"],
      positionStrategy: [0, "cdkConnectedOverlayPositionStrategy", "positionStrategy"],
      offsetX: [0, "cdkConnectedOverlayOffsetX", "offsetX"],
      offsetY: [0, "cdkConnectedOverlayOffsetY", "offsetY"],
      width: [0, "cdkConnectedOverlayWidth", "width"],
      height: [0, "cdkConnectedOverlayHeight", "height"],
      minWidth: [0, "cdkConnectedOverlayMinWidth", "minWidth"],
      minHeight: [0, "cdkConnectedOverlayMinHeight", "minHeight"],
      backdropClass: [0, "cdkConnectedOverlayBackdropClass", "backdropClass"],
      panelClass: [0, "cdkConnectedOverlayPanelClass", "panelClass"],
      viewportMargin: [0, "cdkConnectedOverlayViewportMargin", "viewportMargin"],
      scrollStrategy: [0, "cdkConnectedOverlayScrollStrategy", "scrollStrategy"],
      open: [0, "cdkConnectedOverlayOpen", "open"],
      disableClose: [0, "cdkConnectedOverlayDisableClose", "disableClose"],
      transformOriginSelector: [0, "cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"],
      hasBackdrop: [2, "cdkConnectedOverlayHasBackdrop", "hasBackdrop", booleanAttribute],
      lockPosition: [2, "cdkConnectedOverlayLockPosition", "lockPosition", booleanAttribute],
      flexibleDimensions: [2, "cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions", booleanAttribute],
      growAfterOpen: [2, "cdkConnectedOverlayGrowAfterOpen", "growAfterOpen", booleanAttribute],
      push: [2, "cdkConnectedOverlayPush", "push", booleanAttribute],
      disposeOnNavigation: [2, "cdkConnectedOverlayDisposeOnNavigation", "disposeOnNavigation", booleanAttribute]
    },
    outputs: {
      backdropClick: "backdropClick",
      positionChange: "positionChange",
      attach: "attach",
      detach: "detach",
      overlayKeydown: "overlayKeydown",
      overlayOutsideClick: "overlayOutsideClick"
    },
    exportAs: ["cdkConnectedOverlay"],
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkConnectedOverlay, [{
    type: Directive,
    args: [{
      selector: "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]",
      exportAs: "cdkConnectedOverlay"
    }]
  }], () => [], {
    origin: [{
      type: Input,
      args: ["cdkConnectedOverlayOrigin"]
    }],
    positions: [{
      type: Input,
      args: ["cdkConnectedOverlayPositions"]
    }],
    positionStrategy: [{
      type: Input,
      args: ["cdkConnectedOverlayPositionStrategy"]
    }],
    offsetX: [{
      type: Input,
      args: ["cdkConnectedOverlayOffsetX"]
    }],
    offsetY: [{
      type: Input,
      args: ["cdkConnectedOverlayOffsetY"]
    }],
    width: [{
      type: Input,
      args: ["cdkConnectedOverlayWidth"]
    }],
    height: [{
      type: Input,
      args: ["cdkConnectedOverlayHeight"]
    }],
    minWidth: [{
      type: Input,
      args: ["cdkConnectedOverlayMinWidth"]
    }],
    minHeight: [{
      type: Input,
      args: ["cdkConnectedOverlayMinHeight"]
    }],
    backdropClass: [{
      type: Input,
      args: ["cdkConnectedOverlayBackdropClass"]
    }],
    panelClass: [{
      type: Input,
      args: ["cdkConnectedOverlayPanelClass"]
    }],
    viewportMargin: [{
      type: Input,
      args: ["cdkConnectedOverlayViewportMargin"]
    }],
    scrollStrategy: [{
      type: Input,
      args: ["cdkConnectedOverlayScrollStrategy"]
    }],
    open: [{
      type: Input,
      args: ["cdkConnectedOverlayOpen"]
    }],
    disableClose: [{
      type: Input,
      args: ["cdkConnectedOverlayDisableClose"]
    }],
    transformOriginSelector: [{
      type: Input,
      args: ["cdkConnectedOverlayTransformOriginOn"]
    }],
    hasBackdrop: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayHasBackdrop",
        transform: booleanAttribute
      }]
    }],
    lockPosition: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayLockPosition",
        transform: booleanAttribute
      }]
    }],
    flexibleDimensions: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayFlexibleDimensions",
        transform: booleanAttribute
      }]
    }],
    growAfterOpen: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayGrowAfterOpen",
        transform: booleanAttribute
      }]
    }],
    push: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayPush",
        transform: booleanAttribute
      }]
    }],
    disposeOnNavigation: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayDisposeOnNavigation",
        transform: booleanAttribute
      }]
    }],
    backdropClick: [{
      type: Output
    }],
    positionChange: [{
      type: Output
    }],
    attach: [{
      type: Output
    }],
    detach: [{
      type: Output
    }],
    overlayKeydown: [{
      type: Output
    }],
    overlayOutsideClick: [{
      type: Output
    }]
  });
})();
function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
  return () => overlay.scrollStrategies.reposition();
}
var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
  provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,
  deps: [Overlay],
  useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY
};
var OverlayModule = class _OverlayModule {
  static ɵfac = function OverlayModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OverlayModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _OverlayModule,
    imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],
    exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER],
    imports: [BidiModule, PortalModule, ScrollingModule, ScrollingModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],
      exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],
      providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/overlay.mjs
var FullscreenOverlayContainer = class _FullscreenOverlayContainer extends OverlayContainer {
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _fullScreenEventName;
  _cleanupFullScreenListener;
  constructor() {
    super();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this._cleanupFullScreenListener?.();
  }
  _createContainer() {
    const eventName = this._getEventName();
    super._createContainer();
    this._adjustParentForFullscreenChange();
    if (eventName) {
      this._cleanupFullScreenListener?.();
      this._cleanupFullScreenListener = this._renderer.listen("document", eventName, () => {
        this._adjustParentForFullscreenChange();
      });
    }
  }
  _adjustParentForFullscreenChange() {
    if (this._containerElement) {
      const fullscreenElement = this.getFullscreenElement();
      const parent = fullscreenElement || this._document.body;
      parent.appendChild(this._containerElement);
    }
  }
  _getEventName() {
    if (!this._fullScreenEventName) {
      const _document = this._document;
      if (_document.fullscreenEnabled) {
        this._fullScreenEventName = "fullscreenchange";
      } else if (_document.webkitFullscreenEnabled) {
        this._fullScreenEventName = "webkitfullscreenchange";
      } else if (_document.mozFullScreenEnabled) {
        this._fullScreenEventName = "mozfullscreenchange";
      } else if (_document.msFullscreenEnabled) {
        this._fullScreenEventName = "MSFullscreenChange";
      }
    }
    return this._fullScreenEventName;
  }
  /**
   * When the page is put into fullscreen mode, a specific element is specified.
   * Only that element and its children are visible when in fullscreen mode.
   */
  getFullscreenElement() {
    const _document = this._document;
    return _document.fullscreenElement || _document.webkitFullscreenElement || _document.mozFullScreenElement || _document.msFullscreenElement || null;
  }
  static ɵfac = function FullscreenOverlayContainer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FullscreenOverlayContainer)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FullscreenOverlayContainer,
    factory: _FullscreenOverlayContainer.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FullscreenOverlayContainer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/platform.mjs
var PlatformModule = class _PlatformModule {
  static ɵfac = function PlatformModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PlatformModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PlatformModule
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();

// node_modules/@angular/animations/fesm2022/animations.mjs
var AnimationBuilder = class _AnimationBuilder {
  static ɵfac = function AnimationBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AnimationBuilder)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AnimationBuilder,
    factory: () => (() => inject(BrowserAnimationBuilder))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnimationBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(BrowserAnimationBuilder)
    }]
  }], null, null);
})();
var AnimationFactory = class {
};
var BrowserAnimationBuilder = class _BrowserAnimationBuilder extends AnimationBuilder {
  animationModuleType = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  _nextAnimationId = 0;
  _renderer;
  constructor(rootRenderer, doc) {
    super();
    const typeData = {
      id: "0",
      encapsulation: ViewEncapsulation.None,
      styles: [],
      data: {
        animation: []
      }
    };
    this._renderer = rootRenderer.createRenderer(doc.body, typeData);
    if (this.animationModuleType === null && !isAnimationRenderer(this._renderer)) {
      throw new RuntimeError(3600, (typeof ngDevMode === "undefined" || ngDevMode) && "Angular detected that the `AnimationBuilder` was injected, but animation support was not enabled. Please make sure that you enable animations in your application by calling `provideAnimations()` or `provideAnimationsAsync()` function.");
    }
  }
  build(animation2) {
    const id = this._nextAnimationId;
    this._nextAnimationId++;
    const entry = Array.isArray(animation2) ? sequence(animation2) : animation2;
    issueAnimationCommand(this._renderer, null, id, "register", [entry]);
    return new BrowserAnimationFactory(id, this._renderer);
  }
  static ɵfac = function BrowserAnimationBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserAnimationBuilder)(ɵɵinject(RendererFactory2), ɵɵinject(DOCUMENT));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _BrowserAnimationBuilder,
    factory: _BrowserAnimationBuilder.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserAnimationBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RendererFactory2
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var BrowserAnimationFactory = class extends AnimationFactory {
  _id;
  _renderer;
  constructor(_id, _renderer) {
    super();
    this._id = _id;
    this._renderer = _renderer;
  }
  create(element, options) {
    return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
  }
};
var RendererAnimationPlayer = class {
  id;
  element;
  _renderer;
  parentPlayer = null;
  _started = false;
  constructor(id, element, options, _renderer) {
    this.id = id;
    this.element = element;
    this._renderer = _renderer;
    this._command("create", options);
  }
  _listen(eventName, callback) {
    return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);
  }
  _command(command, ...args) {
    issueAnimationCommand(this._renderer, this.element, this.id, command, args);
  }
  onDone(fn) {
    this._listen("done", fn);
  }
  onStart(fn) {
    this._listen("start", fn);
  }
  onDestroy(fn) {
    this._listen("destroy", fn);
  }
  init() {
    this._command("init");
  }
  hasStarted() {
    return this._started;
  }
  play() {
    this._command("play");
    this._started = true;
  }
  pause() {
    this._command("pause");
  }
  restart() {
    this._command("restart");
  }
  finish() {
    this._command("finish");
  }
  destroy() {
    this._command("destroy");
  }
  reset() {
    this._command("reset");
    this._started = false;
  }
  setPosition(p) {
    this._command("setPosition", p);
  }
  getPosition() {
    return unwrapAnimationRenderer(this._renderer)?.engine?.players[this.id]?.getPosition() ?? 0;
  }
  totalTime = 0;
};
function issueAnimationCommand(renderer, element, id, command, args) {
  renderer.setProperty(element, `@@${id}:${command}`, args);
}
function unwrapAnimationRenderer(renderer) {
  const type = renderer.ɵtype;
  if (type === 0) {
    return renderer;
  } else if (type === 1) {
    return renderer.animationRenderer;
  }
  return null;
}
function isAnimationRenderer(renderer) {
  const type = renderer.ɵtype;
  return type === 0 || type === 1;
}

// node_modules/@angular/cdk/fesm2022/dispose-view-repeater-strategy-BLw1RSwm.mjs
var _DisposeViewRepeaterStrategy = class {
  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
      let view;
      let operation;
      if (record.previousIndex == null) {
        const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);
        view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);
        operation = _ViewRepeaterOperation.INSERTED;
      } else if (currentIndex == null) {
        viewContainerRef.remove(adjustedPreviousIndex);
        operation = _ViewRepeaterOperation.REMOVED;
      } else {
        view = viewContainerRef.get(adjustedPreviousIndex);
        viewContainerRef.move(view, currentIndex);
        operation = _ViewRepeaterOperation.MOVED;
      }
      if (itemViewChanged) {
        itemViewChanged({
          context: view?.context,
          operation,
          record
        });
      }
    });
  }
  detach() {
  }
};

// node_modules/@angular/cdk/fesm2022/boolean-property-_aCfQwp8.mjs
function coerceBooleanProperty(value) {
  return value != null && `${value}` !== "false";
}

// node_modules/@angular/cdk/fesm2022/table.mjs
var _c02 = [[["caption"]], [["colgroup"], ["col"]], "*"];
var _c12 = ["caption", "colgroup, col", "*"];
function CdkTable_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2);
  }
}
function CdkTable_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "thead", 0);
    ɵɵelementContainer(1, 1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "tbody", 0);
    ɵɵelementContainer(3, 2)(4, 3);
    ɵɵelementEnd();
    ɵɵelementStart(5, "tfoot", 0);
    ɵɵelementContainer(6, 4);
    ɵɵelementEnd();
  }
}
function CdkTable_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 1)(1, 2)(2, 3)(3, 4);
  }
}
function CdkTextColumn_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("text-align", ctx_r0.justify);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.headerText, " ");
  }
}
function CdkTextColumn_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("text-align", ctx_r0.justify);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.dataAccessor(data_r2, ctx_r0.name), " ");
  }
}
var CDK_TABLE = new InjectionToken("CDK_TABLE");
var TEXT_COLUMN_OPTIONS = new InjectionToken("text-column-options");
var CdkCellDef = class _CdkCellDef {
  /** @docs-private */
  template = inject(TemplateRef);
  constructor() {
  }
  static ɵfac = function CdkCellDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkCellDef)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkCellDef,
    selectors: [["", "cdkCellDef", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkCellDef]"
    }]
  }], () => [], null);
})();
var CdkHeaderCellDef = class _CdkHeaderCellDef {
  /** @docs-private */
  template = inject(TemplateRef);
  constructor() {
  }
  static ɵfac = function CdkHeaderCellDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkHeaderCellDef)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkHeaderCellDef,
    selectors: [["", "cdkHeaderCellDef", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkHeaderCellDef]"
    }]
  }], () => [], null);
})();
var CdkFooterCellDef = class _CdkFooterCellDef {
  /** @docs-private */
  template = inject(TemplateRef);
  constructor() {
  }
  static ɵfac = function CdkFooterCellDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFooterCellDef)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkFooterCellDef,
    selectors: [["", "cdkFooterCellDef", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkFooterCellDef]"
    }]
  }], () => [], null);
})();
var CdkColumnDef = class _CdkColumnDef {
  _table = inject(CDK_TABLE, {
    optional: true
  });
  _hasStickyChanged = false;
  /** Unique name for this column. */
  get name() {
    return this._name;
  }
  set name(name) {
    this._setNameInput(name);
  }
  _name;
  /** Whether the cell is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  _sticky = false;
  /**
   * Whether this column should be sticky positioned on the end of the row. Should make sure
   * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
   * has been changed.
   */
  get stickyEnd() {
    return this._stickyEnd;
  }
  set stickyEnd(value) {
    if (value !== this._stickyEnd) {
      this._stickyEnd = value;
      this._hasStickyChanged = true;
    }
  }
  _stickyEnd = false;
  /** @docs-private */
  cell;
  /** @docs-private */
  headerCell;
  /** @docs-private */
  footerCell;
  /**
   * Transformed version of the column name that can be used as part of a CSS classname. Excludes
   * all non-alphanumeric characters and the special characters '-' and '_'. Any characters that
   * do not match are replaced by the '-' character.
   */
  cssClassFriendlyName;
  /**
   * Class name for cells in this column.
   * @docs-private
   */
  _columnCssClassName;
  constructor() {
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
  /**
   * Overridable method that sets the css classes that will be added to every cell in this
   * column.
   * In the future, columnCssClassName will change from type string[] to string and this
   * will set a single string value.
   * @docs-private
   */
  _updateColumnCssClassName() {
    this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`];
  }
  /**
   * This has been extracted to a util because of TS 4 and VE.
   * View Engine doesn't support property rename inheritance.
   * TS 4.0 doesn't allow properties to override accessors or vice-versa.
   * @docs-private
   */
  _setNameInput(value) {
    if (value) {
      this._name = value;
      this.cssClassFriendlyName = value.replace(/[^a-z0-9_-]/gi, "-");
      this._updateColumnCssClassName();
    }
  }
  static ɵfac = function CdkColumnDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkColumnDef)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkColumnDef,
    selectors: [["", "cdkColumnDef", ""]],
    contentQueries: function CdkColumnDef_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CdkCellDef, 5);
        ɵɵcontentQuery(dirIndex, CdkHeaderCellDef, 5);
        ɵɵcontentQuery(dirIndex, CdkFooterCellDef, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cell = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerCell = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerCell = _t.first);
      }
    },
    inputs: {
      name: [0, "cdkColumnDef", "name"],
      sticky: [2, "sticky", "sticky", booleanAttribute],
      stickyEnd: [2, "stickyEnd", "stickyEnd", booleanAttribute]
    },
    features: [ɵɵProvidersFeature([{
      provide: "MAT_SORT_HEADER_COLUMN_DEF",
      useExisting: _CdkColumnDef
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkColumnDef, [{
    type: Directive,
    args: [{
      selector: "[cdkColumnDef]",
      providers: [{
        provide: "MAT_SORT_HEADER_COLUMN_DEF",
        useExisting: CdkColumnDef
      }]
    }]
  }], () => [], {
    name: [{
      type: Input,
      args: ["cdkColumnDef"]
    }],
    sticky: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    stickyEnd: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    cell: [{
      type: ContentChild,
      args: [CdkCellDef]
    }],
    headerCell: [{
      type: ContentChild,
      args: [CdkHeaderCellDef]
    }],
    footerCell: [{
      type: ContentChild,
      args: [CdkFooterCellDef]
    }]
  });
})();
var BaseCdkCell = class {
  constructor(columnDef, elementRef) {
    elementRef.nativeElement.classList.add(...columnDef._columnCssClassName);
  }
};
var CdkHeaderCell = class _CdkHeaderCell extends BaseCdkCell {
  constructor() {
    super(inject(CdkColumnDef), inject(ElementRef));
  }
  static ɵfac = function CdkHeaderCell_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkHeaderCell)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkHeaderCell,
    selectors: [["cdk-header-cell"], ["th", "cdk-header-cell", ""]],
    hostAttrs: ["role", "columnheader", 1, "cdk-header-cell"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderCell, [{
    type: Directive,
    args: [{
      selector: "cdk-header-cell, th[cdk-header-cell]",
      host: {
        "class": "cdk-header-cell",
        "role": "columnheader"
      }
    }]
  }], () => [], null);
})();
var CdkFooterCell = class _CdkFooterCell extends BaseCdkCell {
  constructor() {
    const columnDef = inject(CdkColumnDef);
    const elementRef = inject(ElementRef);
    super(columnDef, elementRef);
    const role = columnDef._table?._getCellRole();
    if (role) {
      elementRef.nativeElement.setAttribute("role", role);
    }
  }
  static ɵfac = function CdkFooterCell_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFooterCell)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkFooterCell,
    selectors: [["cdk-footer-cell"], ["td", "cdk-footer-cell", ""]],
    hostAttrs: [1, "cdk-footer-cell"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterCell, [{
    type: Directive,
    args: [{
      selector: "cdk-footer-cell, td[cdk-footer-cell]",
      host: {
        "class": "cdk-footer-cell"
      }
    }]
  }], () => [], null);
})();
var CdkCell = class _CdkCell extends BaseCdkCell {
  constructor() {
    const columnDef = inject(CdkColumnDef);
    const elementRef = inject(ElementRef);
    super(columnDef, elementRef);
    const role = columnDef._table?._getCellRole();
    if (role) {
      elementRef.nativeElement.setAttribute("role", role);
    }
  }
  static ɵfac = function CdkCell_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkCell)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkCell,
    selectors: [["cdk-cell"], ["td", "cdk-cell", ""]],
    hostAttrs: [1, "cdk-cell"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCell, [{
    type: Directive,
    args: [{
      selector: "cdk-cell, td[cdk-cell]",
      host: {
        "class": "cdk-cell"
      }
    }]
  }], () => [], null);
})();
var _Schedule = class {
  tasks = [];
  endTasks = [];
};
var _COALESCED_STYLE_SCHEDULER = new InjectionToken("_COALESCED_STYLE_SCHEDULER");
var _CoalescedStyleScheduler = class __CoalescedStyleScheduler {
  _currentSchedule = null;
  _ngZone = inject(NgZone);
  constructor() {
  }
  /**
   * Schedules the specified task to run at the end of the current VM turn.
   */
  schedule(task) {
    this._createScheduleIfNeeded();
    this._currentSchedule.tasks.push(task);
  }
  /**
   * Schedules the specified task to run after other scheduled tasks at the end of the current
   * VM turn.
   */
  scheduleEnd(task) {
    this._createScheduleIfNeeded();
    this._currentSchedule.endTasks.push(task);
  }
  _createScheduleIfNeeded() {
    if (this._currentSchedule) {
      return;
    }
    this._currentSchedule = new _Schedule();
    this._ngZone.runOutsideAngular(() => (
      // TODO(mmalerba): Scheduling this using something that runs less frequently
      //  (e.g. requestAnimationFrame, setTimeout, etc.) causes noticeable jank with the column
      //  resizer. We should audit the usages of schedule / scheduleEnd in that component and see
      //  if we can refactor it so that we don't need to flush the tasks quite so frequently.
      queueMicrotask(() => {
        while (this._currentSchedule.tasks.length || this._currentSchedule.endTasks.length) {
          const schedule = this._currentSchedule;
          this._currentSchedule = new _Schedule();
          for (const task of schedule.tasks) {
            task();
          }
          for (const task of schedule.endTasks) {
            task();
          }
        }
        this._currentSchedule = null;
      })
    ));
  }
  static ɵfac = function _CoalescedStyleScheduler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __CoalescedStyleScheduler)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: __CoalescedStyleScheduler,
    factory: __CoalescedStyleScheduler.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CoalescedStyleScheduler, [{
    type: Injectable
  }], () => [], null);
})();
var CDK_ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;
var BaseRowDef = class _BaseRowDef {
  template = inject(TemplateRef);
  _differs = inject(IterableDiffers);
  /** The columns to be displayed on this row. */
  columns;
  /** Differ used to check if any changes were made to the columns. */
  _columnsDiffer;
  constructor() {
  }
  ngOnChanges(changes) {
    if (!this._columnsDiffer) {
      const columns = changes["columns"] && changes["columns"].currentValue || [];
      this._columnsDiffer = this._differs.find(columns).create();
      this._columnsDiffer.diff(columns);
    }
  }
  /**
   * Returns the difference between the current columns and the columns from the last diff, or null
   * if there is no difference.
   */
  getColumnsDiff() {
    return this._columnsDiffer.diff(this.columns);
  }
  /** Gets this row def's relevant cell template from the provided column def. */
  extractCellTemplate(column) {
    if (this instanceof CdkHeaderRowDef) {
      return column.headerCell.template;
    }
    if (this instanceof CdkFooterRowDef) {
      return column.footerCell.template;
    } else {
      return column.cell.template;
    }
  }
  static ɵfac = function BaseRowDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseRowDef)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseRowDef,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseRowDef, [{
    type: Directive
  }], () => [], null);
})();
var CdkHeaderRowDef = class _CdkHeaderRowDef extends BaseRowDef {
  _table = inject(CDK_TABLE, {
    optional: true
  });
  _hasStickyChanged = false;
  /** Whether the row is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  _sticky = false;
  constructor() {
    super(inject(TemplateRef), inject(IterableDiffers));
  }
  // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
  // Explicitly define it so that the method is called as part of the Angular lifecycle.
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
  static ɵfac = function CdkHeaderRowDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkHeaderRowDef)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkHeaderRowDef,
    selectors: [["", "cdkHeaderRowDef", ""]],
    inputs: {
      columns: [0, "cdkHeaderRowDef", "columns"],
      sticky: [2, "cdkHeaderRowDefSticky", "sticky", booleanAttribute]
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkHeaderRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkHeaderRowDef"
      }]
    }]
  }], () => [], {
    sticky: [{
      type: Input,
      args: [{
        alias: "cdkHeaderRowDefSticky",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CdkFooterRowDef = class _CdkFooterRowDef extends BaseRowDef {
  _table = inject(CDK_TABLE, {
    optional: true
  });
  _hasStickyChanged = false;
  /** Whether the row is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  _sticky = false;
  constructor() {
    super(inject(TemplateRef), inject(IterableDiffers));
  }
  // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
  // Explicitly define it so that the method is called as part of the Angular lifecycle.
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
  static ɵfac = function CdkFooterRowDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFooterRowDef)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkFooterRowDef,
    selectors: [["", "cdkFooterRowDef", ""]],
    inputs: {
      columns: [0, "cdkFooterRowDef", "columns"],
      sticky: [2, "cdkFooterRowDefSticky", "sticky", booleanAttribute]
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkFooterRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkFooterRowDef"
      }]
    }]
  }], () => [], {
    sticky: [{
      type: Input,
      args: [{
        alias: "cdkFooterRowDefSticky",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CdkRowDef = class _CdkRowDef extends BaseRowDef {
  _table = inject(CDK_TABLE, {
    optional: true
  });
  /**
   * Function that should return true if this row template should be used for the provided index
   * and row data. If left undefined, this row will be considered the default row template to use
   * when no other when functions return true for the data.
   * For every row, there must be at least one when function that passes or an undefined to default.
   */
  when;
  constructor() {
    super(inject(TemplateRef), inject(IterableDiffers));
  }
  static ɵfac = function CdkRowDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkRowDef)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkRowDef,
    selectors: [["", "cdkRowDef", ""]],
    inputs: {
      columns: [0, "cdkRowDefColumns", "columns"],
      when: [0, "cdkRowDefWhen", "when"]
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkRowDefColumns"
      }, {
        name: "when",
        alias: "cdkRowDefWhen"
      }]
    }]
  }], () => [], null);
})();
var CdkCellOutlet = class _CdkCellOutlet {
  _viewContainer = inject(ViewContainerRef);
  /** The ordered list of cells to render within this outlet's view container */
  cells;
  /** The data context to be provided to each cell */
  context;
  /**
   * Static property containing the latest constructed instance of this class.
   * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using
   * createEmbeddedView. After one of these components are created, this property will provide
   * a handle to provide that component's cells and context. After init, the CdkCellOutlet will
   * construct the cells with the provided context.
   */
  static mostRecentCellOutlet = null;
  constructor() {
    _CdkCellOutlet.mostRecentCellOutlet = this;
  }
  ngOnDestroy() {
    if (_CdkCellOutlet.mostRecentCellOutlet === this) {
      _CdkCellOutlet.mostRecentCellOutlet = null;
    }
  }
  static ɵfac = function CdkCellOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkCellOutlet)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkCellOutlet,
    selectors: [["", "cdkCellOutlet", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCellOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkCellOutlet]"
    }]
  }], () => [], null);
})();
var CdkHeaderRow = class _CdkHeaderRow {
  static ɵfac = function CdkHeaderRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkHeaderRow)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CdkHeaderRow,
    selectors: [["cdk-header-row"], ["tr", "cdk-header-row", ""]],
    hostAttrs: ["role", "row", 1, "cdk-header-row"],
    decls: 1,
    vars: 0,
    consts: [["cdkCellOutlet", ""]],
    template: function CdkHeaderRow_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
    },
    dependencies: [CdkCellOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderRow, [{
    type: Component,
    args: [{
      selector: "cdk-header-row, tr[cdk-header-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-header-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation.None,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var CdkFooterRow = class _CdkFooterRow {
  static ɵfac = function CdkFooterRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFooterRow)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CdkFooterRow,
    selectors: [["cdk-footer-row"], ["tr", "cdk-footer-row", ""]],
    hostAttrs: ["role", "row", 1, "cdk-footer-row"],
    decls: 1,
    vars: 0,
    consts: [["cdkCellOutlet", ""]],
    template: function CdkFooterRow_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
    },
    dependencies: [CdkCellOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterRow, [{
    type: Component,
    args: [{
      selector: "cdk-footer-row, tr[cdk-footer-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-footer-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation.None,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var CdkRow = class _CdkRow {
  static ɵfac = function CdkRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkRow)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CdkRow,
    selectors: [["cdk-row"], ["tr", "cdk-row", ""]],
    hostAttrs: ["role", "row", 1, "cdk-row"],
    decls: 1,
    vars: 0,
    consts: [["cdkCellOutlet", ""]],
    template: function CdkRow_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
    },
    dependencies: [CdkCellOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRow, [{
    type: Component,
    args: [{
      selector: "cdk-row, tr[cdk-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation.None,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var CdkNoDataRow = class _CdkNoDataRow {
  templateRef = inject(TemplateRef);
  _contentClassName = "cdk-no-data-row";
  constructor() {
  }
  static ɵfac = function CdkNoDataRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkNoDataRow)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkNoDataRow,
    selectors: [["ng-template", "cdkNoDataRow", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkNoDataRow, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkNoDataRow]"
    }]
  }], () => [], null);
})();
var STICKY_DIRECTIONS = ["top", "bottom", "left", "right"];
var StickyStyler = class {
  _isNativeHtmlTable;
  _stickCellCss;
  direction;
  _coalescedStyleScheduler;
  _isBrowser;
  _needsPositionStickyOnElement;
  _positionListener;
  _tableInjector;
  _elemSizeCache = /* @__PURE__ */ new WeakMap();
  _resizeObserver = globalThis?.ResizeObserver ? new globalThis.ResizeObserver((entries) => this._updateCachedSizes(entries)) : null;
  _updatedStickyColumnsParamsToReplay = [];
  _stickyColumnsReplayTimeout = null;
  _cachedCellWidths = [];
  _borderCellCss;
  _destroyed = false;
  /**
   * @param _isNativeHtmlTable Whether the sticky logic should be based on a table
   *     that uses the native `<table>` element.
   * @param _stickCellCss The CSS class that will be applied to every row/cell that has
   *     sticky positioning applied.
   * @param direction The directionality context of the table (ltr/rtl); affects column positioning
   *     by reversing left/right positions.
   * @param _isBrowser Whether the table is currently being rendered on the server or the client.
   * @param _needsPositionStickyOnElement Whether we need to specify position: sticky on cells
   *     using inline styles. If false, it is assumed that position: sticky is included in
   *     the component stylesheet for _stickCellCss.
   * @param _positionListener A listener that is notified of changes to sticky rows/columns
   *     and their dimensions.
   * @param _tableInjector The table's Injector.
   */
  constructor(_isNativeHtmlTable, _stickCellCss, direction, _coalescedStyleScheduler, _isBrowser = true, _needsPositionStickyOnElement = true, _positionListener, _tableInjector) {
    this._isNativeHtmlTable = _isNativeHtmlTable;
    this._stickCellCss = _stickCellCss;
    this.direction = direction;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._isBrowser = _isBrowser;
    this._needsPositionStickyOnElement = _needsPositionStickyOnElement;
    this._positionListener = _positionListener;
    this._tableInjector = _tableInjector;
    this._borderCellCss = {
      "top": `${_stickCellCss}-border-elem-top`,
      "bottom": `${_stickCellCss}-border-elem-bottom`,
      "left": `${_stickCellCss}-border-elem-left`,
      "right": `${_stickCellCss}-border-elem-right`
    };
  }
  /**
   * Clears the sticky positioning styles from the row and its cells by resetting the `position`
   * style, setting the zIndex to 0, and unsetting each provided sticky direction.
   * @param rows The list of rows that should be cleared from sticking in the provided directions
   * @param stickyDirections The directions that should no longer be set as sticky on the rows.
   */
  clearStickyPositioning(rows, stickyDirections) {
    if (stickyDirections.includes("left") || stickyDirections.includes("right")) {
      this._removeFromStickyColumnReplayQueue(rows);
    }
    const elementsToClear = [];
    for (const row of rows) {
      if (row.nodeType !== row.ELEMENT_NODE) {
        continue;
      }
      elementsToClear.push(row, ...Array.from(row.children));
    }
    this._afterNextRender({
      write: () => {
        for (const element of elementsToClear) {
          this._removeStickyStyle(element, stickyDirections);
        }
      }
    });
  }
  /**
   * Applies sticky left and right positions to the cells of each row according to the sticky
   * states of the rendered column definitions.
   * @param rows The rows that should have its set of cells stuck according to the sticky states.
   * @param stickyStartStates A list of boolean states where each state represents whether the cell
   *     in this index position should be stuck to the start of the row.
   * @param stickyEndStates A list of boolean states where each state represents whether the cell
   *     in this index position should be stuck to the end of the row.
   * @param recalculateCellWidths Whether the sticky styler should recalculate the width of each
   *     column cell. If `false` cached widths will be used instead.
   * @param replay Whether to enqueue this call for replay after a ResizeObserver update.
   */
  updateStickyColumns(rows, stickyStartStates, stickyEndStates, recalculateCellWidths = true, replay = true) {
    if (!rows.length || !this._isBrowser || !(stickyStartStates.some((state2) => state2) || stickyEndStates.some((state2) => state2))) {
      this._positionListener?.stickyColumnsUpdated({
        sizes: []
      });
      this._positionListener?.stickyEndColumnsUpdated({
        sizes: []
      });
      return;
    }
    const firstRow = rows[0];
    const numCells = firstRow.children.length;
    const isRtl = this.direction === "rtl";
    const start = isRtl ? "right" : "left";
    const end = isRtl ? "left" : "right";
    const lastStickyStart = stickyStartStates.lastIndexOf(true);
    const firstStickyEnd = stickyEndStates.indexOf(true);
    let cellWidths;
    let startPositions;
    let endPositions;
    if (replay) {
      this._updateStickyColumnReplayQueue({
        rows: [...rows],
        stickyStartStates: [...stickyStartStates],
        stickyEndStates: [...stickyEndStates]
      });
    }
    this._afterNextRender({
      earlyRead: () => {
        cellWidths = this._getCellWidths(firstRow, recalculateCellWidths);
        startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);
        endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);
      },
      write: () => {
        for (const row of rows) {
          for (let i = 0; i < numCells; i++) {
            const cell = row.children[i];
            if (stickyStartStates[i]) {
              this._addStickyStyle(cell, start, startPositions[i], i === lastStickyStart);
            }
            if (stickyEndStates[i]) {
              this._addStickyStyle(cell, end, endPositions[i], i === firstStickyEnd);
            }
          }
        }
        if (this._positionListener && cellWidths.some((w) => !!w)) {
          this._positionListener.stickyColumnsUpdated({
            sizes: lastStickyStart === -1 ? [] : cellWidths.slice(0, lastStickyStart + 1).map((width, index) => stickyStartStates[index] ? width : null)
          });
          this._positionListener.stickyEndColumnsUpdated({
            sizes: firstStickyEnd === -1 ? [] : cellWidths.slice(firstStickyEnd).map((width, index) => stickyEndStates[index + firstStickyEnd] ? width : null).reverse()
          });
        }
      }
    });
  }
  /**
   * Applies sticky positioning to the row's cells if using the native table layout, and to the
   * row itself otherwise.
   * @param rowsToStick The list of rows that should be stuck according to their corresponding
   *     sticky state and to the provided top or bottom position.
   * @param stickyStates A list of boolean states where each state represents whether the row
   *     should be stuck in the particular top or bottom position.
   * @param position The position direction in which the row should be stuck if that row should be
   *     sticky.
   *
   */
  stickRows(rowsToStick, stickyStates, position) {
    if (!this._isBrowser) {
      return;
    }
    const rows = position === "bottom" ? rowsToStick.slice().reverse() : rowsToStick;
    const states = position === "bottom" ? stickyStates.slice().reverse() : stickyStates;
    const stickyOffsets = [];
    const stickyCellHeights = [];
    const elementsToStick = [];
    this._afterNextRender({
      earlyRead: () => {
        for (let rowIndex = 0, stickyOffset = 0; rowIndex < rows.length; rowIndex++) {
          if (!states[rowIndex]) {
            continue;
          }
          stickyOffsets[rowIndex] = stickyOffset;
          const row = rows[rowIndex];
          elementsToStick[rowIndex] = this._isNativeHtmlTable ? Array.from(row.children) : [row];
          const height = this._retrieveElementSize(row).height;
          stickyOffset += height;
          stickyCellHeights[rowIndex] = height;
        }
      },
      write: () => {
        const borderedRowIndex = states.lastIndexOf(true);
        for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
          if (!states[rowIndex]) {
            continue;
          }
          const offset = stickyOffsets[rowIndex];
          const isBorderedRowIndex = rowIndex === borderedRowIndex;
          for (const element of elementsToStick[rowIndex]) {
            this._addStickyStyle(element, position, offset, isBorderedRowIndex);
          }
        }
        if (position === "top") {
          this._positionListener?.stickyHeaderRowsUpdated({
            sizes: stickyCellHeights,
            offsets: stickyOffsets,
            elements: elementsToStick
          });
        } else {
          this._positionListener?.stickyFooterRowsUpdated({
            sizes: stickyCellHeights,
            offsets: stickyOffsets,
            elements: elementsToStick
          });
        }
      }
    });
  }
  /**
   * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
   * footer rows is to apply sticky styling to the tfoot container. This should only be done if
   * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
   * the tfoot element.
   */
  updateStickyFooterContainer(tableElement, stickyStates) {
    if (!this._isNativeHtmlTable) {
      return;
    }
    this._afterNextRender({
      write: () => {
        const tfoot = tableElement.querySelector("tfoot");
        if (tfoot) {
          if (stickyStates.some((state2) => !state2)) {
            this._removeStickyStyle(tfoot, ["bottom"]);
          } else {
            this._addStickyStyle(tfoot, "bottom", 0, false);
          }
        }
      }
    });
  }
  /** Triggered by the table's OnDestroy hook. */
  destroy() {
    if (this._stickyColumnsReplayTimeout) {
      clearTimeout(this._stickyColumnsReplayTimeout);
    }
    this._resizeObserver?.disconnect();
    this._destroyed = true;
  }
  /**
   * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
   * the zIndex, removing each of the provided sticky directions, and removing the
   * sticky position if there are no more directions.
   */
  _removeStickyStyle(element, stickyDirections) {
    if (!element.classList.contains(this._stickCellCss)) {
      return;
    }
    for (const dir of stickyDirections) {
      element.style[dir] = "";
      element.classList.remove(this._borderCellCss[dir]);
    }
    const hasDirection = STICKY_DIRECTIONS.some((dir) => stickyDirections.indexOf(dir) === -1 && element.style[dir]);
    if (hasDirection) {
      element.style.zIndex = this._getCalculatedZIndex(element);
    } else {
      element.style.zIndex = "";
      if (this._needsPositionStickyOnElement) {
        element.style.position = "";
      }
      element.classList.remove(this._stickCellCss);
    }
  }
  /**
   * Adds the sticky styling to the element by adding the sticky style class, changing position
   * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
   * direction and value.
   */
  _addStickyStyle(element, dir, dirValue, isBorderElement) {
    element.classList.add(this._stickCellCss);
    if (isBorderElement) {
      element.classList.add(this._borderCellCss[dir]);
    }
    element.style[dir] = `${dirValue}px`;
    element.style.zIndex = this._getCalculatedZIndex(element);
    if (this._needsPositionStickyOnElement) {
      element.style.cssText += "position: -webkit-sticky; position: sticky; ";
    }
  }
  /**
   * Calculate what the z-index should be for the element, depending on what directions (top,
   * bottom, left, right) have been set. It should be true that elements with a top direction
   * should have the highest index since these are elements like a table header. If any of those
   * elements are also sticky in another direction, then they should appear above other elements
   * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
   * (e.g. footer rows) should then be next in the ordering such that they are below the header
   * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
   * should minimally increment so that they are above non-sticky elements but below top and bottom
   * elements.
   */
  _getCalculatedZIndex(element) {
    const zIndexIncrements = {
      top: 100,
      bottom: 10,
      left: 1,
      right: 1
    };
    let zIndex = 0;
    for (const dir of STICKY_DIRECTIONS) {
      if (element.style[dir]) {
        zIndex += zIndexIncrements[dir];
      }
    }
    return zIndex ? `${zIndex}` : "";
  }
  /** Gets the widths for each cell in the provided row. */
  _getCellWidths(row, recalculateCellWidths = true) {
    if (!recalculateCellWidths && this._cachedCellWidths.length) {
      return this._cachedCellWidths;
    }
    const cellWidths = [];
    const firstRowCells = row.children;
    for (let i = 0; i < firstRowCells.length; i++) {
      const cell = firstRowCells[i];
      cellWidths.push(this._retrieveElementSize(cell).width);
    }
    this._cachedCellWidths = cellWidths;
    return cellWidths;
  }
  /**
   * Determines the left and right positions of each sticky column cell, which will be the
   * accumulation of all sticky column cell widths to the left and right, respectively.
   * Non-sticky cells do not need to have a value set since their positions will not be applied.
   */
  _getStickyStartColumnPositions(widths, stickyStates) {
    const positions = [];
    let nextPosition = 0;
    for (let i = 0; i < widths.length; i++) {
      if (stickyStates[i]) {
        positions[i] = nextPosition;
        nextPosition += widths[i];
      }
    }
    return positions;
  }
  /**
   * Determines the left and right positions of each sticky column cell, which will be the
   * accumulation of all sticky column cell widths to the left and right, respectively.
   * Non-sticky cells do not need to have a value set since their positions will not be applied.
   */
  _getStickyEndColumnPositions(widths, stickyStates) {
    const positions = [];
    let nextPosition = 0;
    for (let i = widths.length; i > 0; i--) {
      if (stickyStates[i]) {
        positions[i] = nextPosition;
        nextPosition += widths[i];
      }
    }
    return positions;
  }
  /**
   * Retreives the most recently observed size of the specified element from the cache, or
   * meaures it directly if not yet cached.
   */
  _retrieveElementSize(element) {
    const cachedSize = this._elemSizeCache.get(element);
    if (cachedSize) {
      return cachedSize;
    }
    const clientRect = element.getBoundingClientRect();
    const size = {
      width: clientRect.width,
      height: clientRect.height
    };
    if (!this._resizeObserver) {
      return size;
    }
    this._elemSizeCache.set(element, size);
    this._resizeObserver.observe(element, {
      box: "border-box"
    });
    return size;
  }
  /**
   * Conditionally enqueue the requested sticky update and clear previously queued updates
   * for the same rows.
   */
  _updateStickyColumnReplayQueue(params) {
    this._removeFromStickyColumnReplayQueue(params.rows);
    if (!this._stickyColumnsReplayTimeout) {
      this._updatedStickyColumnsParamsToReplay.push(params);
    }
  }
  /** Remove updates for the specified rows from the queue. */
  _removeFromStickyColumnReplayQueue(rows) {
    const rowsSet = new Set(rows);
    for (const update of this._updatedStickyColumnsParamsToReplay) {
      update.rows = update.rows.filter((row) => !rowsSet.has(row));
    }
    this._updatedStickyColumnsParamsToReplay = this._updatedStickyColumnsParamsToReplay.filter((update) => !!update.rows.length);
  }
  /** Update _elemSizeCache with the observed sizes. */
  _updateCachedSizes(entries) {
    let needsColumnUpdate = false;
    for (const entry of entries) {
      const newEntry = entry.borderBoxSize?.length ? {
        width: entry.borderBoxSize[0].inlineSize,
        height: entry.borderBoxSize[0].blockSize
      } : {
        width: entry.contentRect.width,
        height: entry.contentRect.height
      };
      if (newEntry.width !== this._elemSizeCache.get(entry.target)?.width && isCell(entry.target)) {
        needsColumnUpdate = true;
      }
      this._elemSizeCache.set(entry.target, newEntry);
    }
    if (needsColumnUpdate && this._updatedStickyColumnsParamsToReplay.length) {
      if (this._stickyColumnsReplayTimeout) {
        clearTimeout(this._stickyColumnsReplayTimeout);
      }
      this._stickyColumnsReplayTimeout = setTimeout(() => {
        if (this._destroyed) {
          return;
        }
        for (const update of this._updatedStickyColumnsParamsToReplay) {
          this.updateStickyColumns(update.rows, update.stickyStartStates, update.stickyEndStates, true, false);
        }
        this._updatedStickyColumnsParamsToReplay = [];
        this._stickyColumnsReplayTimeout = null;
      }, 0);
    }
  }
  /**
   * Invoke afterNextRender with the table's injector, falling back to CoalescedStyleScheduler
   * if the injector was not provided.
   */
  _afterNextRender(spec) {
    if (this._tableInjector) {
      afterNextRender(spec, {
        injector: this._tableInjector
      });
    } else {
      this._coalescedStyleScheduler.schedule(() => {
        spec.earlyRead?.();
        spec.write();
      });
    }
  }
};
function isCell(element) {
  return ["cdk-cell", "cdk-header-cell", "cdk-footer-cell"].some((klass) => element.classList.contains(klass));
}
function getTableUnknownColumnError(id) {
  return Error(`Could not find column with id "${id}".`);
}
function getTableDuplicateColumnNameError(name) {
  return Error(`Duplicate column definition name provided: "${name}".`);
}
function getTableMultipleDefaultRowDefsError() {
  return Error(`There can only be one default row without a when predicate function.`);
}
function getTableMissingMatchingRowDefError(data) {
  return Error(`Could not find a matching row definition for theprovided row data: ${JSON.stringify(data)}`);
}
function getTableMissingRowDefsError() {
  return Error("Missing definitions for header, footer, and row; cannot determine which columns should be rendered.");
}
function getTableUnknownDataSourceError() {
  return Error(`Provided data source did not match an array, Observable, or DataSource`);
}
function getTableTextColumnMissingParentTableError() {
  return Error(`Text column could not find a parent table for registration.`);
}
function getTableTextColumnMissingNameError() {
  return Error(`Table text column must have a name.`);
}
var STICKY_POSITIONING_LISTENER = new InjectionToken("CDK_SPL");
var CdkRecycleRows = class _CdkRecycleRows {
  static ɵfac = function CdkRecycleRows_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkRecycleRows)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkRecycleRows,
    selectors: [["cdk-table", "recycleRows", ""], ["table", "cdk-table", "", "recycleRows", ""]],
    features: [ɵɵProvidersFeature([{
      provide: _VIEW_REPEATER_STRATEGY,
      useClass: _RecycleViewRepeaterStrategy
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRecycleRows, [{
    type: Directive,
    args: [{
      selector: "cdk-table[recycleRows], table[cdk-table][recycleRows]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }]
    }]
  }], null, null);
})();
var DataRowOutlet = class _DataRowOutlet {
  viewContainer = inject(ViewContainerRef);
  elementRef = inject(ElementRef);
  constructor() {
    const table = inject(CDK_TABLE);
    table._rowOutlet = this;
    table._outletAssigned();
  }
  static ɵfac = function DataRowOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DataRowOutlet)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DataRowOutlet,
    selectors: [["", "rowOutlet", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[rowOutlet]"
    }]
  }], () => [], null);
})();
var HeaderRowOutlet = class _HeaderRowOutlet {
  viewContainer = inject(ViewContainerRef);
  elementRef = inject(ElementRef);
  constructor() {
    const table = inject(CDK_TABLE);
    table._headerRowOutlet = this;
    table._outletAssigned();
  }
  static ɵfac = function HeaderRowOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderRowOutlet)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HeaderRowOutlet,
    selectors: [["", "headerRowOutlet", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[headerRowOutlet]"
    }]
  }], () => [], null);
})();
var FooterRowOutlet = class _FooterRowOutlet {
  viewContainer = inject(ViewContainerRef);
  elementRef = inject(ElementRef);
  constructor() {
    const table = inject(CDK_TABLE);
    table._footerRowOutlet = this;
    table._outletAssigned();
  }
  static ɵfac = function FooterRowOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FooterRowOutlet)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FooterRowOutlet,
    selectors: [["", "footerRowOutlet", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[footerRowOutlet]"
    }]
  }], () => [], null);
})();
var NoDataRowOutlet = class _NoDataRowOutlet {
  viewContainer = inject(ViewContainerRef);
  elementRef = inject(ElementRef);
  constructor() {
    const table = inject(CDK_TABLE);
    table._noDataRowOutlet = this;
    table._outletAssigned();
  }
  static ɵfac = function NoDataRowOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoDataRowOutlet)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NoDataRowOutlet,
    selectors: [["", "noDataRowOutlet", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoDataRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[noDataRowOutlet]"
    }]
  }], () => [], null);
})();
var CDK_TABLE_TEMPLATE = (
  // Note that according to MDN, the `caption` element has to be projected as the **first**
  // element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption
  `
  <ng-content select="caption"/>
  <ng-content select="colgroup, col"/>

  <!--
    Unprojected content throws a hydration error so we need this to capture it.
    It gets removed on the client so it doesn't affect the layout.
  -->
  @if (_isServer) {
    <ng-content/>
  }

  @if (_isNativeHtmlTable) {
    <thead role="rowgroup">
      <ng-container headerRowOutlet/>
    </thead>
    <tbody role="rowgroup">
      <ng-container rowOutlet/>
      <ng-container noDataRowOutlet/>
    </tbody>
    <tfoot role="rowgroup">
      <ng-container footerRowOutlet/>
    </tfoot>
  } @else {
    <ng-container headerRowOutlet/>
    <ng-container rowOutlet/>
    <ng-container noDataRowOutlet/>
    <ng-container footerRowOutlet/>
  }
`
);
var CdkTable = class _CdkTable {
  _differs = inject(IterableDiffers);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _elementRef = inject(ElementRef);
  _dir = inject(Directionality, {
    optional: true
  });
  _platform = inject(Platform);
  _viewRepeater = inject(_VIEW_REPEATER_STRATEGY);
  _coalescedStyleScheduler = inject(_COALESCED_STYLE_SCHEDULER);
  _viewportRuler = inject(ViewportRuler);
  _stickyPositioningListener = inject(STICKY_POSITIONING_LISTENER, {
    optional: true,
    skipSelf: true
  });
  _document = inject(DOCUMENT);
  /** Latest data provided by the data source. */
  _data;
  /** Subject that emits when the component has been destroyed. */
  _onDestroy = new Subject();
  /** List of the rendered rows as identified by their `RenderRow` object. */
  _renderRows;
  /** Subscription that listens for the data provided by the data source. */
  _renderChangeSubscription;
  /**
   * Map of all the user's defined columns (header, data, and footer cell template) identified by
   * name. Collection populated by the column definitions gathered by `ContentChildren` as well as
   * any custom column definitions added to `_customColumnDefs`.
   */
  _columnDefsByName = /* @__PURE__ */ new Map();
  /**
   * Set of all row definitions that can be used by this table. Populated by the rows gathered by
   * using `ContentChildren` as well as any custom row definitions added to `_customRowDefs`.
   */
  _rowDefs;
  /**
   * Set of all header row definitions that can be used by this table. Populated by the rows
   * gathered by using `ContentChildren` as well as any custom row definitions added to
   * `_customHeaderRowDefs`.
   */
  _headerRowDefs;
  /**
   * Set of all row definitions that can be used by this table. Populated by the rows gathered by
   * using `ContentChildren` as well as any custom row definitions added to
   * `_customFooterRowDefs`.
   */
  _footerRowDefs;
  /** Differ used to find the changes in the data provided by the data source. */
  _dataDiffer;
  /** Stores the row definition that does not have a when predicate. */
  _defaultRowDef;
  /**
   * Column definitions that were defined outside of the direct content children of the table.
   * These will be defined when, e.g., creating a wrapper around the cdkTable that has
   * column definitions as *its* content child.
   */
  _customColumnDefs = /* @__PURE__ */ new Set();
  /**
   * Data row definitions that were defined outside of the direct content children of the table.
   * These will be defined when, e.g., creating a wrapper around the cdkTable that has
   * built-in data rows as *its* content child.
   */
  _customRowDefs = /* @__PURE__ */ new Set();
  /**
   * Header row definitions that were defined outside of the direct content children of the table.
   * These will be defined when, e.g., creating a wrapper around the cdkTable that has
   * built-in header rows as *its* content child.
   */
  _customHeaderRowDefs = /* @__PURE__ */ new Set();
  /**
   * Footer row definitions that were defined outside of the direct content children of the table.
   * These will be defined when, e.g., creating a wrapper around the cdkTable that has a
   * built-in footer row as *its* content child.
   */
  _customFooterRowDefs = /* @__PURE__ */ new Set();
  /** No data row that was defined outside of the direct content children of the table. */
  _customNoDataRow;
  /**
   * Whether the header row definition has been changed. Triggers an update to the header row after
   * content is checked. Initialized as true so that the table renders the initial set of rows.
   */
  _headerRowDefChanged = true;
  /**
   * Whether the footer row definition has been changed. Triggers an update to the footer row after
   * content is checked. Initialized as true so that the table renders the initial set of rows.
   */
  _footerRowDefChanged = true;
  /**
   * Whether the sticky column styles need to be updated. Set to `true` when the visible columns
   * change.
   */
  _stickyColumnStylesNeedReset = true;
  /**
   * Whether the sticky styler should recalculate cell widths when applying sticky styles. If
   * `false`, cached values will be used instead. This is only applicable to tables with
   * {@link fixedLayout} enabled. For other tables, cell widths will always be recalculated.
   */
  _forceRecalculateCellWidths = true;
  /**
   * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing
   * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with
   * the cached `RenderRow` objects when possible, the row identity is preserved when the data
   * and row template matches, which allows the `IterableDiffer` to check rows by reference
   * and understand which rows are added/moved/removed.
   *
   * Implemented as a map of maps where the first key is the `data: T` object and the second is the
   * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that
   * contains an array of created pairs. The array is necessary to handle cases where the data
   * array contains multiple duplicate data objects and each instantiated `RenderRow` must be
   * stored.
   */
  _cachedRenderRowsMap = /* @__PURE__ */ new Map();
  /** Whether the table is applied to a native `<table>`. */
  _isNativeHtmlTable;
  /**
   * Utility class that is responsible for applying the appropriate sticky positioning styles to
   * the table's rows and cells.
   */
  _stickyStyler;
  /**
   * CSS class added to any row or cell that has sticky positioning applied. May be overridden by
   * table subclasses.
   */
  stickyCssClass = "cdk-table-sticky";
  /**
   * Whether to manually add position: sticky to all sticky cell elements. Not needed if
   * the position is set in a selector associated with the value of stickyCssClass. May be
   * overridden by table subclasses
   */
  needsPositionStickyOnElement = true;
  /** Whether the component is being rendered on the server. */
  _isServer;
  /** Whether the no data row is currently showing anything. */
  _isShowingNoDataRow = false;
  /** Whether the table has rendered out all the outlets for the first time. */
  _hasAllOutlets = false;
  /** Whether the table is done initializing. */
  _hasInitialized = false;
  /** Aria role to apply to the table's cells based on the table's own role. */
  _getCellRole() {
    if (this._cellRoleInternal === void 0) {
      const tableRole = this._elementRef.nativeElement.getAttribute("role");
      return tableRole === "grid" || tableRole === "treegrid" ? "gridcell" : "cell";
    }
    return this._cellRoleInternal;
  }
  _cellRoleInternal = void 0;
  /**
   * Tracking function that will be used to check the differences in data changes. Used similarly
   * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data
   * relative to the function to know if a row should be added/removed/moved.
   * Accepts a function that takes two parameters, `index` and `item`.
   */
  get trackBy() {
    return this._trackByFn;
  }
  set trackBy(fn) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && fn != null && typeof fn !== "function") {
      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._trackByFn = fn;
  }
  _trackByFn;
  /**
   * The table's source of data, which can be provided in three ways (in order of complexity):
   *   - Simple data array (each object represents one table row)
   *   - Stream that emits a data array each time the array changes
   *   - `DataSource` object that implements the connect/disconnect interface.
   *
   * If a data array is provided, the table must be notified when the array's objects are
   * added, removed, or moved. This can be done by calling the `renderRows()` function which will
   * render the diff since the last table render. If the data array reference is changed, the table
   * will automatically trigger an update to the rows.
   *
   * When providing an Observable stream, the table will trigger an update automatically when the
   * stream emits a new array of data.
   *
   * Finally, when providing a `DataSource` object, the table will use the Observable stream
   * provided by the connect function and trigger updates when that stream emits new data array
   * values. During the table's ngOnDestroy or when the data source is removed from the table, the
   * table will call the DataSource's `disconnect` function (may be useful for cleaning up any
   * subscriptions registered during the connect process).
   */
  get dataSource() {
    return this._dataSource;
  }
  set dataSource(dataSource) {
    if (this._dataSource !== dataSource) {
      this._switchDataSource(dataSource);
    }
  }
  _dataSource;
  /**
   * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'
   * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each
   * dataobject will render the first row that evaluates its when predicate to true, in the order
   * defined in the table, or otherwise the default row which does not have a when predicate.
   */
  get multiTemplateDataRows() {
    return this._multiTemplateDataRows;
  }
  set multiTemplateDataRows(value) {
    this._multiTemplateDataRows = value;
    if (this._rowOutlet && this._rowOutlet.viewContainer.length) {
      this._forceRenderDataRows();
      this.updateStickyColumnStyles();
    }
  }
  _multiTemplateDataRows = false;
  /**
   * Whether to use a fixed table layout. Enabling this option will enforce consistent column widths
   * and optimize rendering sticky styles for native tables. No-op for flex tables.
   */
  get fixedLayout() {
    return this._fixedLayout;
  }
  set fixedLayout(value) {
    this._fixedLayout = value;
    this._forceRecalculateCellWidths = true;
    this._stickyColumnStylesNeedReset = true;
  }
  _fixedLayout = false;
  /**
   * Emits when the table completes rendering a set of data rows based on the latest data from the
   * data source, even if the set of rows is empty.
   */
  contentChanged = new EventEmitter();
  // TODO(andrewseguin): Remove max value as the end index
  //   and instead calculate the view on init and scroll.
  /**
   * Stream containing the latest information on what rows are being displayed on screen.
   * Can be used by the data source to as a heuristic of what data should be provided.
   *
   * @docs-private
   */
  viewChange = new BehaviorSubject({
    start: 0,
    end: Number.MAX_VALUE
  });
  // Outlets in the table's template where the header, data rows, and footer will be inserted.
  _rowOutlet;
  _headerRowOutlet;
  _footerRowOutlet;
  _noDataRowOutlet;
  /**
   * The column definitions provided by the user that contain what the header, data, and footer
   * cells should render for each column.
   */
  _contentColumnDefs;
  /** Set of data row definitions that were provided to the table as content children. */
  _contentRowDefs;
  /** Set of header row definitions that were provided to the table as content children. */
  _contentHeaderRowDefs;
  /** Set of footer row definitions that were provided to the table as content children. */
  _contentFooterRowDefs;
  /** Row definition that will only be rendered if there's no data in the table. */
  _noDataRow;
  _injector = inject(Injector);
  constructor() {
    const role = inject(new HostAttributeToken("role"), {
      optional: true
    });
    if (!role) {
      this._elementRef.nativeElement.setAttribute("role", "table");
    }
    this._isServer = !this._platform.isBrowser;
    this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === "TABLE";
    this._dataDiffer = this._differs.find([]).create((_i, dataRow) => {
      return this.trackBy ? this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;
    });
  }
  ngOnInit() {
    this._setupStickyStyler();
    this._viewportRuler.change().pipe(takeUntil(this._onDestroy)).subscribe(() => {
      this._forceRecalculateCellWidths = true;
    });
  }
  ngAfterContentInit() {
    this._hasInitialized = true;
  }
  ngAfterContentChecked() {
    if (this._canRender()) {
      this._render();
    }
  }
  ngOnDestroy() {
    this._stickyStyler?.destroy();
    [this._rowOutlet?.viewContainer, this._headerRowOutlet?.viewContainer, this._footerRowOutlet?.viewContainer, this._cachedRenderRowsMap, this._customColumnDefs, this._customRowDefs, this._customHeaderRowDefs, this._customFooterRowDefs, this._columnDefsByName].forEach((def) => {
      def?.clear();
    });
    this._headerRowDefs = [];
    this._footerRowDefs = [];
    this._defaultRowDef = null;
    this._onDestroy.next();
    this._onDestroy.complete();
    if (isDataSource(this.dataSource)) {
      this.dataSource.disconnect(this);
    }
  }
  /**
   * Renders rows based on the table's latest set of data, which was either provided directly as an
   * input or retrieved through an Observable stream (directly or from a DataSource).
   * Checks for differences in the data since the last diff to perform only the necessary
   * changes (add/remove/move rows).
   *
   * If the table's data source is a DataSource or Observable, this will be invoked automatically
   * each time the provided Observable stream emits a new data array. Otherwise if your data is
   * an array, this function will need to be called to render any changes.
   */
  renderRows() {
    this._renderRows = this._getAllRenderRows();
    const changes = this._dataDiffer.diff(this._renderRows);
    if (!changes) {
      this._updateNoDataRow();
      this.contentChanged.next();
      return;
    }
    const viewContainer = this._rowOutlet.viewContainer;
    this._viewRepeater.applyChanges(changes, viewContainer, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record.item, currentIndex), (record) => record.item.data, (change) => {
      if (change.operation === _ViewRepeaterOperation.INSERTED && change.context) {
        this._renderCellTemplateForItem(change.record.item.rowDef, change.context);
      }
    });
    this._updateRowIndexContext();
    changes.forEachIdentityChange((record) => {
      const rowView = viewContainer.get(record.currentIndex);
      rowView.context.$implicit = record.item.data;
    });
    this._updateNoDataRow();
    this.contentChanged.next();
    this.updateStickyColumnStyles();
  }
  /** Adds a column definition that was not included as part of the content children. */
  addColumnDef(columnDef) {
    this._customColumnDefs.add(columnDef);
  }
  /** Removes a column definition that was not included as part of the content children. */
  removeColumnDef(columnDef) {
    this._customColumnDefs.delete(columnDef);
  }
  /** Adds a row definition that was not included as part of the content children. */
  addRowDef(rowDef) {
    this._customRowDefs.add(rowDef);
  }
  /** Removes a row definition that was not included as part of the content children. */
  removeRowDef(rowDef) {
    this._customRowDefs.delete(rowDef);
  }
  /** Adds a header row definition that was not included as part of the content children. */
  addHeaderRowDef(headerRowDef) {
    this._customHeaderRowDefs.add(headerRowDef);
    this._headerRowDefChanged = true;
  }
  /** Removes a header row definition that was not included as part of the content children. */
  removeHeaderRowDef(headerRowDef) {
    this._customHeaderRowDefs.delete(headerRowDef);
    this._headerRowDefChanged = true;
  }
  /** Adds a footer row definition that was not included as part of the content children. */
  addFooterRowDef(footerRowDef) {
    this._customFooterRowDefs.add(footerRowDef);
    this._footerRowDefChanged = true;
  }
  /** Removes a footer row definition that was not included as part of the content children. */
  removeFooterRowDef(footerRowDef) {
    this._customFooterRowDefs.delete(footerRowDef);
    this._footerRowDefChanged = true;
  }
  /** Sets a no data row definition that was not included as a part of the content children. */
  setNoDataRow(noDataRow) {
    this._customNoDataRow = noDataRow;
  }
  /**
   * Updates the header sticky styles. First resets all applied styles with respect to the cells
   * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
   * automatically called when the header row changes its displayed set of columns, or if its
   * sticky input changes. May be called manually for cases where the cell content changes outside
   * of these events.
   */
  updateStickyHeaderRowStyles() {
    const headerRows = this._getRenderedRows(this._headerRowOutlet);
    if (this._isNativeHtmlTable) {
      const thead = closestTableSection(this._headerRowOutlet, "thead");
      if (thead) {
        thead.style.display = headerRows.length ? "" : "none";
      }
    }
    const stickyStates = this._headerRowDefs.map((def) => def.sticky);
    this._stickyStyler.clearStickyPositioning(headerRows, ["top"]);
    this._stickyStyler.stickRows(headerRows, stickyStates, "top");
    this._headerRowDefs.forEach((def) => def.resetStickyChanged());
  }
  /**
   * Updates the footer sticky styles. First resets all applied styles with respect to the cells
   * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
   * automatically called when the footer row changes its displayed set of columns, or if its
   * sticky input changes. May be called manually for cases where the cell content changes outside
   * of these events.
   */
  updateStickyFooterRowStyles() {
    const footerRows = this._getRenderedRows(this._footerRowOutlet);
    if (this._isNativeHtmlTable) {
      const tfoot = closestTableSection(this._footerRowOutlet, "tfoot");
      if (tfoot) {
        tfoot.style.display = footerRows.length ? "" : "none";
      }
    }
    const stickyStates = this._footerRowDefs.map((def) => def.sticky);
    this._stickyStyler.clearStickyPositioning(footerRows, ["bottom"]);
    this._stickyStyler.stickRows(footerRows, stickyStates, "bottom");
    this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);
    this._footerRowDefs.forEach((def) => def.resetStickyChanged());
  }
  /**
   * Updates the column sticky styles. First resets all applied styles with respect to the cells
   * sticking to the left and right. Then sticky styles are added for the left and right according
   * to the column definitions for each cell in each row. This is automatically called when
   * the data source provides a new set of data or when a column definition changes its sticky
   * input. May be called manually for cases where the cell content changes outside of these events.
   */
  updateStickyColumnStyles() {
    const headerRows = this._getRenderedRows(this._headerRowOutlet);
    const dataRows = this._getRenderedRows(this._rowOutlet);
    const footerRows = this._getRenderedRows(this._footerRowOutlet);
    if (this._isNativeHtmlTable && !this._fixedLayout || this._stickyColumnStylesNeedReset) {
      this._stickyStyler.clearStickyPositioning([...headerRows, ...dataRows, ...footerRows], ["left", "right"]);
      this._stickyColumnStylesNeedReset = false;
    }
    headerRows.forEach((headerRow, i) => {
      this._addStickyColumnStyles([headerRow], this._headerRowDefs[i]);
    });
    this._rowDefs.forEach((rowDef) => {
      const rows = [];
      for (let i = 0; i < dataRows.length; i++) {
        if (this._renderRows[i].rowDef === rowDef) {
          rows.push(dataRows[i]);
        }
      }
      this._addStickyColumnStyles(rows, rowDef);
    });
    footerRows.forEach((footerRow, i) => {
      this._addStickyColumnStyles([footerRow], this._footerRowDefs[i]);
    });
    Array.from(this._columnDefsByName.values()).forEach((def) => def.resetStickyChanged());
  }
  /** Invoked whenever an outlet is created and has been assigned to the table. */
  _outletAssigned() {
    if (!this._hasAllOutlets && this._rowOutlet && this._headerRowOutlet && this._footerRowOutlet && this._noDataRowOutlet) {
      this._hasAllOutlets = true;
      if (this._canRender()) {
        this._render();
      }
    }
  }
  /** Whether the table has all the information to start rendering. */
  _canRender() {
    return this._hasAllOutlets && this._hasInitialized;
  }
  /** Renders the table if its state has changed. */
  _render() {
    this._cacheRowDefs();
    this._cacheColumnDefs();
    if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMissingRowDefsError();
    }
    const columnsChanged = this._renderUpdatedColumns();
    const rowDefsChanged = columnsChanged || this._headerRowDefChanged || this._footerRowDefChanged;
    this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || rowDefsChanged;
    this._forceRecalculateCellWidths = rowDefsChanged;
    if (this._headerRowDefChanged) {
      this._forceRenderHeaderRows();
      this._headerRowDefChanged = false;
    }
    if (this._footerRowDefChanged) {
      this._forceRenderFooterRows();
      this._footerRowDefChanged = false;
    }
    if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {
      this._observeRenderChanges();
    } else if (this._stickyColumnStylesNeedReset) {
      this.updateStickyColumnStyles();
    }
    this._checkStickyStates();
  }
  /**
   * Get the list of RenderRow objects to render according to the current list of data and defined
   * row definitions. If the previous list already contained a particular pair, it should be reused
   * so that the differ equates their references.
   */
  _getAllRenderRows() {
    const renderRows = [];
    const prevCachedRenderRows = this._cachedRenderRowsMap;
    this._cachedRenderRowsMap = /* @__PURE__ */ new Map();
    if (!this._data) {
      return renderRows;
    }
    for (let i = 0; i < this._data.length; i++) {
      let data = this._data[i];
      const renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));
      if (!this._cachedRenderRowsMap.has(data)) {
        this._cachedRenderRowsMap.set(data, /* @__PURE__ */ new WeakMap());
      }
      for (let j = 0; j < renderRowsForData.length; j++) {
        let renderRow = renderRowsForData[j];
        const cache = this._cachedRenderRowsMap.get(renderRow.data);
        if (cache.has(renderRow.rowDef)) {
          cache.get(renderRow.rowDef).push(renderRow);
        } else {
          cache.set(renderRow.rowDef, [renderRow]);
        }
        renderRows.push(renderRow);
      }
    }
    return renderRows;
  }
  /**
   * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
   * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
   * `(T, CdkRowDef)` pair.
   */
  _getRenderRowsForData(data, dataIndex, cache) {
    const rowDefs = this._getRowDefs(data, dataIndex);
    return rowDefs.map((rowDef) => {
      const cachedRenderRows = cache && cache.has(rowDef) ? cache.get(rowDef) : [];
      if (cachedRenderRows.length) {
        const dataRow = cachedRenderRows.shift();
        dataRow.dataIndex = dataIndex;
        return dataRow;
      } else {
        return {
          data,
          rowDef,
          dataIndex
        };
      }
    });
  }
  /** Update the map containing the content's column definitions. */
  _cacheColumnDefs() {
    this._columnDefsByName.clear();
    const columnDefs = mergeArrayAndSet(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs);
    columnDefs.forEach((columnDef) => {
      if (this._columnDefsByName.has(columnDef.name) && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableDuplicateColumnNameError(columnDef.name);
      }
      this._columnDefsByName.set(columnDef.name, columnDef);
    });
  }
  /** Update the list of all available row definitions that can be used. */
  _cacheRowDefs() {
    this._headerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs);
    this._footerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs);
    this._rowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentRowDefs), this._customRowDefs);
    const defaultRowDefs = this._rowDefs.filter((def) => !def.when);
    if (!this.multiTemplateDataRows && defaultRowDefs.length > 1 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMultipleDefaultRowDefsError();
    }
    this._defaultRowDef = defaultRowDefs[0];
  }
  /**
   * Check if the header, data, or footer rows have changed what columns they want to display or
   * whether the sticky states have changed for the header or footer. If there is a diff, then
   * re-render that section.
   */
  _renderUpdatedColumns() {
    const columnsDiffReducer = (acc, def) => {
      const diff = !!def.getColumnsDiff();
      return acc || diff;
    };
    const dataColumnsChanged = this._rowDefs.reduce(columnsDiffReducer, false);
    if (dataColumnsChanged) {
      this._forceRenderDataRows();
    }
    const headerColumnsChanged = this._headerRowDefs.reduce(columnsDiffReducer, false);
    if (headerColumnsChanged) {
      this._forceRenderHeaderRows();
    }
    const footerColumnsChanged = this._footerRowDefs.reduce(columnsDiffReducer, false);
    if (footerColumnsChanged) {
      this._forceRenderFooterRows();
    }
    return dataColumnsChanged || headerColumnsChanged || footerColumnsChanged;
  }
  /**
   * Switch to the provided data source by resetting the data and unsubscribing from the current
   * render change subscription if one exists. If the data source is null, interpret this by
   * clearing the row outlet. Otherwise start listening for new data.
   */
  _switchDataSource(dataSource) {
    this._data = [];
    if (isDataSource(this.dataSource)) {
      this.dataSource.disconnect(this);
    }
    if (this._renderChangeSubscription) {
      this._renderChangeSubscription.unsubscribe();
      this._renderChangeSubscription = null;
    }
    if (!dataSource) {
      if (this._dataDiffer) {
        this._dataDiffer.diff([]);
      }
      if (this._rowOutlet) {
        this._rowOutlet.viewContainer.clear();
      }
    }
    this._dataSource = dataSource;
  }
  /** Set up a subscription for the data provided by the data source. */
  _observeRenderChanges() {
    if (!this.dataSource) {
      return;
    }
    let dataStream;
    if (isDataSource(this.dataSource)) {
      dataStream = this.dataSource.connect(this);
    } else if (isObservable(this.dataSource)) {
      dataStream = this.dataSource;
    } else if (Array.isArray(this.dataSource)) {
      dataStream = of(this.dataSource);
    }
    if (dataStream === void 0 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableUnknownDataSourceError();
    }
    this._renderChangeSubscription = dataStream.pipe(takeUntil(this._onDestroy)).subscribe((data) => {
      this._data = data || [];
      this.renderRows();
    });
  }
  /**
   * Clears any existing content in the header row outlet and creates a new embedded view
   * in the outlet using the header row definition.
   */
  _forceRenderHeaderRows() {
    if (this._headerRowOutlet.viewContainer.length > 0) {
      this._headerRowOutlet.viewContainer.clear();
    }
    this._headerRowDefs.forEach((def, i) => this._renderRow(this._headerRowOutlet, def, i));
    this.updateStickyHeaderRowStyles();
  }
  /**
   * Clears any existing content in the footer row outlet and creates a new embedded view
   * in the outlet using the footer row definition.
   */
  _forceRenderFooterRows() {
    if (this._footerRowOutlet.viewContainer.length > 0) {
      this._footerRowOutlet.viewContainer.clear();
    }
    this._footerRowDefs.forEach((def, i) => this._renderRow(this._footerRowOutlet, def, i));
    this.updateStickyFooterRowStyles();
  }
  /** Adds the sticky column styles for the rows according to the columns' stick states. */
  _addStickyColumnStyles(rows, rowDef) {
    const columnDefs = Array.from(rowDef?.columns || []).map((columnName) => {
      const columnDef = this._columnDefsByName.get(columnName);
      if (!columnDef && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableUnknownColumnError(columnName);
      }
      return columnDef;
    });
    const stickyStartStates = columnDefs.map((columnDef) => columnDef.sticky);
    const stickyEndStates = columnDefs.map((columnDef) => columnDef.stickyEnd);
    this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates, !this._fixedLayout || this._forceRecalculateCellWidths);
  }
  /** Gets the list of rows that have been rendered in the row outlet. */
  _getRenderedRows(rowOutlet) {
    const renderedRows = [];
    for (let i = 0; i < rowOutlet.viewContainer.length; i++) {
      const viewRef = rowOutlet.viewContainer.get(i);
      renderedRows.push(viewRef.rootNodes[0]);
    }
    return renderedRows;
  }
  /**
   * Get the matching row definitions that should be used for this row data. If there is only
   * one row definition, it is returned. Otherwise, find the row definitions that has a when
   * predicate that returns true with the data. If none return true, return the default row
   * definition.
   */
  _getRowDefs(data, dataIndex) {
    if (this._rowDefs.length == 1) {
      return [this._rowDefs[0]];
    }
    let rowDefs = [];
    if (this.multiTemplateDataRows) {
      rowDefs = this._rowDefs.filter((def) => !def.when || def.when(dataIndex, data));
    } else {
      let rowDef = this._rowDefs.find((def) => def.when && def.when(dataIndex, data)) || this._defaultRowDef;
      if (rowDef) {
        rowDefs.push(rowDef);
      }
    }
    if (!rowDefs.length && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMissingMatchingRowDefError(data);
    }
    return rowDefs;
  }
  _getEmbeddedViewArgs(renderRow, index) {
    const rowDef = renderRow.rowDef;
    const context = {
      $implicit: renderRow.data
    };
    return {
      templateRef: rowDef.template,
      context,
      index
    };
  }
  /**
   * Creates a new row template in the outlet and fills it with the set of cell templates.
   * Optionally takes a context to provide to the row and cells, as well as an optional index
   * of where to place the new row template in the outlet.
   */
  _renderRow(outlet, rowDef, index, context = {}) {
    const view = outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);
    this._renderCellTemplateForItem(rowDef, context);
    return view;
  }
  _renderCellTemplateForItem(rowDef, context) {
    for (let cellTemplate of this._getCellTemplates(rowDef)) {
      if (CdkCellOutlet.mostRecentCellOutlet) {
        CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);
      }
    }
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Updates the index-related context for each row to reflect any changes in the index of the rows,
   * e.g. first/last/even/odd.
   */
  _updateRowIndexContext() {
    const viewContainer = this._rowOutlet.viewContainer;
    for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {
      const viewRef = viewContainer.get(renderIndex);
      const context = viewRef.context;
      context.count = count;
      context.first = renderIndex === 0;
      context.last = renderIndex === count - 1;
      context.even = renderIndex % 2 === 0;
      context.odd = !context.even;
      if (this.multiTemplateDataRows) {
        context.dataIndex = this._renderRows[renderIndex].dataIndex;
        context.renderIndex = renderIndex;
      } else {
        context.index = this._renderRows[renderIndex].dataIndex;
      }
    }
  }
  /** Gets the column definitions for the provided row def. */
  _getCellTemplates(rowDef) {
    if (!rowDef || !rowDef.columns) {
      return [];
    }
    return Array.from(rowDef.columns, (columnId) => {
      const column = this._columnDefsByName.get(columnId);
      if (!column && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableUnknownColumnError(columnId);
      }
      return rowDef.extractCellTemplate(column);
    });
  }
  /**
   * Forces a re-render of the data rows. Should be called in cases where there has been an input
   * change that affects the evaluation of which rows should be rendered, e.g. toggling
   * `multiTemplateDataRows` or adding/removing row definitions.
   */
  _forceRenderDataRows() {
    this._dataDiffer.diff([]);
    this._rowOutlet.viewContainer.clear();
    this.renderRows();
  }
  /**
   * Checks if there has been a change in sticky states since last check and applies the correct
   * sticky styles. Since checking resets the "dirty" state, this should only be performed once
   * during a change detection and after the inputs are settled (after content check).
   */
  _checkStickyStates() {
    const stickyCheckReducer = (acc, d) => {
      return acc || d.hasStickyChanged();
    };
    if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {
      this.updateStickyHeaderRowStyles();
    }
    if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {
      this.updateStickyFooterRowStyles();
    }
    if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {
      this._stickyColumnStylesNeedReset = true;
      this.updateStickyColumnStyles();
    }
  }
  /**
   * Creates the sticky styler that will be used for sticky rows and columns. Listens
   * for directionality changes and provides the latest direction to the styler. Re-applies column
   * stickiness when directionality changes.
   */
  _setupStickyStyler() {
    const direction = this._dir ? this._dir.value : "ltr";
    this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._coalescedStyleScheduler, this._platform.isBrowser, this.needsPositionStickyOnElement, this._stickyPositioningListener, this._injector);
    (this._dir ? this._dir.change : of()).pipe(takeUntil(this._onDestroy)).subscribe((value) => {
      this._stickyStyler.direction = value;
      this.updateStickyColumnStyles();
    });
  }
  /** Filters definitions that belong to this table from a QueryList. */
  _getOwnDefs(items) {
    return items.filter((item) => !item._table || item._table === this);
  }
  /** Creates or removes the no data row, depending on whether any data is being shown. */
  _updateNoDataRow() {
    const noDataRow = this._customNoDataRow || this._noDataRow;
    if (!noDataRow) {
      return;
    }
    const shouldShow = this._rowOutlet.viewContainer.length === 0;
    if (shouldShow === this._isShowingNoDataRow) {
      return;
    }
    const container = this._noDataRowOutlet.viewContainer;
    if (shouldShow) {
      const view = container.createEmbeddedView(noDataRow.templateRef);
      const rootNode = view.rootNodes[0];
      if (view.rootNodes.length === 1 && rootNode?.nodeType === this._document.ELEMENT_NODE) {
        rootNode.setAttribute("role", "row");
        rootNode.classList.add(noDataRow._contentClassName);
      }
    } else {
      container.clear();
    }
    this._isShowingNoDataRow = shouldShow;
    this._changeDetectorRef.markForCheck();
  }
  static ɵfac = function CdkTable_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTable)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CdkTable,
    selectors: [["cdk-table"], ["table", "cdk-table", ""]],
    contentQueries: function CdkTable_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CdkNoDataRow, 5);
        ɵɵcontentQuery(dirIndex, CdkColumnDef, 5);
        ɵɵcontentQuery(dirIndex, CdkRowDef, 5);
        ɵɵcontentQuery(dirIndex, CdkHeaderRowDef, 5);
        ɵɵcontentQuery(dirIndex, CdkFooterRowDef, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._noDataRow = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentColumnDefs = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentRowDefs = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentHeaderRowDefs = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentFooterRowDefs = _t);
      }
    },
    hostAttrs: [1, "cdk-table"],
    hostVars: 2,
    hostBindings: function CdkTable_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("cdk-table-fixed-layout", ctx.fixedLayout);
      }
    },
    inputs: {
      trackBy: "trackBy",
      dataSource: "dataSource",
      multiTemplateDataRows: [2, "multiTemplateDataRows", "multiTemplateDataRows", booleanAttribute],
      fixedLayout: [2, "fixedLayout", "fixedLayout", booleanAttribute]
    },
    outputs: {
      contentChanged: "contentChanged"
    },
    exportAs: ["cdkTable"],
    features: [ɵɵProvidersFeature([
      {
        provide: CDK_TABLE,
        useExisting: _CdkTable
      },
      {
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _DisposeViewRepeaterStrategy
      },
      {
        provide: _COALESCED_STYLE_SCHEDULER,
        useClass: _CoalescedStyleScheduler
      },
      // Prevent nested tables from seeing this table's StickyPositioningListener.
      {
        provide: STICKY_POSITIONING_LISTENER,
        useValue: null
      }
    ])],
    ngContentSelectors: _c12,
    decls: 5,
    vars: 2,
    consts: [["role", "rowgroup"], ["headerRowOutlet", ""], ["rowOutlet", ""], ["noDataRowOutlet", ""], ["footerRowOutlet", ""]],
    template: function CdkTable_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c02);
        ɵɵprojection(0);
        ɵɵprojection(1, 1);
        ɵɵtemplate(2, CdkTable_Conditional_2_Template, 1, 0)(3, CdkTable_Conditional_3_Template, 7, 0)(4, CdkTable_Conditional_4_Template, 4, 0);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵconditional(ctx._isServer ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx._isNativeHtmlTable ? 3 : 4);
      }
    },
    dependencies: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet],
    styles: [".cdk-table-fixed-layout{table-layout:fixed}\n"],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTable, [{
    type: Component,
    args: [{
      selector: "cdk-table, table[cdk-table]",
      exportAs: "cdkTable",
      template: CDK_TABLE_TEMPLATE,
      host: {
        "class": "cdk-table",
        "[class.cdk-table-fixed-layout]": "fixedLayout"
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.Default,
      providers: [
        {
          provide: CDK_TABLE,
          useExisting: CdkTable
        },
        {
          provide: _VIEW_REPEATER_STRATEGY,
          useClass: _DisposeViewRepeaterStrategy
        },
        {
          provide: _COALESCED_STYLE_SCHEDULER,
          useClass: _CoalescedStyleScheduler
        },
        // Prevent nested tables from seeing this table's StickyPositioningListener.
        {
          provide: STICKY_POSITIONING_LISTENER,
          useValue: null
        }
      ],
      imports: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet],
      styles: [".cdk-table-fixed-layout{table-layout:fixed}\n"]
    }]
  }], () => [], {
    trackBy: [{
      type: Input
    }],
    dataSource: [{
      type: Input
    }],
    multiTemplateDataRows: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    fixedLayout: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    contentChanged: [{
      type: Output
    }],
    _contentColumnDefs: [{
      type: ContentChildren,
      args: [CdkColumnDef, {
        descendants: true
      }]
    }],
    _contentRowDefs: [{
      type: ContentChildren,
      args: [CdkRowDef, {
        descendants: true
      }]
    }],
    _contentHeaderRowDefs: [{
      type: ContentChildren,
      args: [CdkHeaderRowDef, {
        descendants: true
      }]
    }],
    _contentFooterRowDefs: [{
      type: ContentChildren,
      args: [CdkFooterRowDef, {
        descendants: true
      }]
    }],
    _noDataRow: [{
      type: ContentChild,
      args: [CdkNoDataRow]
    }]
  });
})();
function mergeArrayAndSet(array, set) {
  return array.concat(Array.from(set));
}
function closestTableSection(outlet, section) {
  const uppercaseSection = section.toUpperCase();
  let current = outlet.viewContainer.element.nativeElement;
  while (current) {
    const nodeName = current.nodeType === 1 ? current.nodeName : null;
    if (nodeName === uppercaseSection) {
      return current;
    } else if (nodeName === "TABLE") {
      break;
    }
    current = current.parentNode;
  }
  return null;
}
var CdkTextColumn = class _CdkTextColumn {
  _table = inject(CdkTable, {
    optional: true
  });
  _options = inject(TEXT_COLUMN_OPTIONS, {
    optional: true
  });
  /** Column name that should be used to reference this column. */
  get name() {
    return this._name;
  }
  set name(name) {
    this._name = name;
    this._syncColumnDefName();
  }
  _name;
  /**
   * Text label that should be used for the column header. If this property is not
   * set, the header text will default to the column name with its first letter capitalized.
   */
  headerText;
  /**
   * Accessor function to retrieve the data rendered for each cell. If this
   * property is not set, the data cells will render the value found in the data's property matching
   * the column's name. For example, if the column is named `id`, then the rendered value will be
   * value defined by the data's `id` property.
   */
  dataAccessor;
  /** Alignment of the cell values. */
  justify = "start";
  /** @docs-private */
  columnDef;
  /**
   * The column cell is provided to the column during `ngOnInit` with a static query.
   * Normally, this will be retrieved by the column using `ContentChild`, but that assumes the
   * column definition was provided in the same view as the table, which is not the case with this
   * component.
   * @docs-private
   */
  cell;
  /**
   * The column headerCell is provided to the column during `ngOnInit` with a static query.
   * Normally, this will be retrieved by the column using `ContentChild`, but that assumes the
   * column definition was provided in the same view as the table, which is not the case with this
   * component.
   * @docs-private
   */
  headerCell;
  constructor() {
    this._options = this._options || {};
  }
  ngOnInit() {
    this._syncColumnDefName();
    if (this.headerText === void 0) {
      this.headerText = this._createDefaultHeaderText();
    }
    if (!this.dataAccessor) {
      this.dataAccessor = this._options.defaultDataAccessor || ((data, name) => data[name]);
    }
    if (this._table) {
      this.columnDef.cell = this.cell;
      this.columnDef.headerCell = this.headerCell;
      this._table.addColumnDef(this.columnDef);
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw getTableTextColumnMissingParentTableError();
    }
  }
  ngOnDestroy() {
    if (this._table) {
      this._table.removeColumnDef(this.columnDef);
    }
  }
  /**
   * Creates a default header text. Use the options' header text transformation function if one
   * has been provided. Otherwise simply capitalize the column name.
   */
  _createDefaultHeaderText() {
    const name = this.name;
    if (!name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableTextColumnMissingNameError();
    }
    if (this._options && this._options.defaultHeaderTextTransform) {
      return this._options.defaultHeaderTextTransform(name);
    }
    return name[0].toUpperCase() + name.slice(1);
  }
  /** Synchronizes the column definition name with the text column name. */
  _syncColumnDefName() {
    if (this.columnDef) {
      this.columnDef.name = this.name;
    }
  }
  static ɵfac = function CdkTextColumn_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTextColumn)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CdkTextColumn,
    selectors: [["cdk-text-column"]],
    viewQuery: function CdkTextColumn_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(CdkColumnDef, 7);
        ɵɵviewQuery(CdkCellDef, 7);
        ɵɵviewQuery(CdkHeaderCellDef, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnDef = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cell = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerCell = _t.first);
      }
    },
    inputs: {
      name: "name",
      headerText: "headerText",
      dataAccessor: "dataAccessor",
      justify: "justify"
    },
    decls: 3,
    vars: 0,
    consts: [["cdkColumnDef", ""], ["cdk-header-cell", "", 3, "text-align", 4, "cdkHeaderCellDef"], ["cdk-cell", "", 3, "text-align", 4, "cdkCellDef"], ["cdk-header-cell", ""], ["cdk-cell", ""]],
    template: function CdkTextColumn_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0, 0);
        ɵɵtemplate(1, CdkTextColumn_th_1_Template, 2, 3, "th", 1)(2, CdkTextColumn_td_2_Template, 2, 3, "td", 2);
        ɵɵelementContainerEnd();
      }
    },
    dependencies: [CdkColumnDef, CdkHeaderCellDef, CdkHeaderCell, CdkCellDef, CdkCell],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTextColumn, [{
    type: Component,
    args: [{
      selector: "cdk-text-column",
      template: `
    <ng-container cdkColumnDef>
      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]="justify">
        {{headerText}}
      </th>
      <td cdk-cell *cdkCellDef="let data" [style.text-align]="justify">
        {{dataAccessor(data, name)}}
      </td>
    </ng-container>
  `,
      encapsulation: ViewEncapsulation.None,
      // Change detection is intentionally not set to OnPush. This component's template will be provided
      // to the table to be inserted into its view. This is problematic when change detection runs since
      // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
      // mean's the template in the table's view will not have the updated value (and in fact will cause
      // an ExpressionChangedAfterItHasBeenCheckedError).
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      imports: [CdkColumnDef, CdkHeaderCellDef, CdkHeaderCell, CdkCellDef, CdkCell]
    }]
  }], () => [], {
    name: [{
      type: Input
    }],
    headerText: [{
      type: Input
    }],
    dataAccessor: [{
      type: Input
    }],
    justify: [{
      type: Input
    }],
    columnDef: [{
      type: ViewChild,
      args: [CdkColumnDef, {
        static: true
      }]
    }],
    cell: [{
      type: ViewChild,
      args: [CdkCellDef, {
        static: true
      }]
    }],
    headerCell: [{
      type: ViewChild,
      args: [CdkHeaderCellDef, {
        static: true
      }]
    }]
  });
})();
var EXPORTED_DECLARATIONS = [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, CdkRecycleRows, NoDataRowOutlet];
var CdkTableModule = class _CdkTableModule {
  static ɵfac = function CdkTableModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTableModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CdkTableModule,
    imports: [ScrollingModule, CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, CdkRecycleRows, NoDataRowOutlet],
    exports: [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, CdkRecycleRows, NoDataRowOutlet]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ScrollingModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTableModule, [{
    type: NgModule,
    args: [{
      exports: EXPORTED_DECLARATIONS,
      imports: [ScrollingModule, ...EXPORTED_DECLARATIONS]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/unique-selection-dispatcher-Cnrf4muk.mjs
var UniqueSelectionDispatcher = class _UniqueSelectionDispatcher {
  _listeners = [];
  /**
   * Notify other items that selection for the given name has been set.
   * @param id ID of the item.
   * @param name Name of the item.
   */
  notify(id, name) {
    for (let listener of this._listeners) {
      listener(id, name);
    }
  }
  /**
   * Listen for future changes to item selection.
   * @return Function used to deregister listener
   */
  listen(listener) {
    this._listeners.push(listener);
    return () => {
      this._listeners = this._listeners.filter((registered) => {
        return listener !== registered;
      });
    };
  }
  ngOnDestroy() {
    this._listeners = [];
  }
  static ɵfac = function UniqueSelectionDispatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UniqueSelectionDispatcher)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _UniqueSelectionDispatcher,
    factory: _UniqueSelectionDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UniqueSelectionDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@nebular/theme/fesm2022/nebular-theme.mjs
function NbOverlayContainerComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.content);
  }
}
function NbOverlayContainerComponent_ng_template_1_Template(rf, ctx) {
}
var _c03 = ["*"];
var _c13 = [[["nb-card-header"]], [["nb-card-body"]], "*", [["nb-card-footer"]]];
var _c2 = ["nb-card-header", "nb-card-body", "*", "nb-card-footer"];
var _c3 = [[["nb-card-front"]], [["nb-card-back"]]];
var _c4 = ["nb-card-front", "nb-card-back"];
function NbRevealCardComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 2);
    ɵɵlistener("click", function NbRevealCardComponent_a_3_Template_a_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggle());
    });
    ɵɵelement(1, "nb-icon", 3);
    ɵɵelementEnd();
  }
}
function NbFlipCardComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 4);
    ɵɵlistener("click", function NbFlipCardComponent_a_3_Template_a_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggle());
    });
    ɵɵelement(1, "nb-icon", 5);
    ɵɵelementEnd();
  }
}
function NbFlipCardComponent_a_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 4);
    ɵɵlistener("click", function NbFlipCardComponent_a_6_Template_a_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggle());
    });
    ɵɵelement(1, "nb-icon", 5);
    ɵɵelementEnd();
  }
}
var _c5 = [[["nb-card"]]];
var _c6 = ["nb-card"];
var _c7 = ["nbButton", ""];
function NbCalendarPickerRowComponent_ng_template_0_Template(rf, ctx) {
}
function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-picker-row", 1);
    ɵɵlistener("select", function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template_nb_calendar_picker_row_select_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.select.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("row", row_r3)("visibleDate", ctx_r1.visibleDate)("selectedValue", ctx_r1.selectedValue)("component", ctx_r1.cellComponent)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("size", ctx_r1.size);
  }
}
function NbCalendarDaysNamesComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r1 = ctx.$implicit;
    ɵɵclassProp("holiday", day_r1.isHoliday);
    ɵɵadvance();
    ɵɵtextInterpolate(day_r1.name);
  }
}
function NbCalendarWeekNumberComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const weekNumber_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(weekNumber_r1);
  }
}
var _c8 = "[_nghost-%COMP%]{display:flex;flex-direction:column}\n\n\n\n\n\n";
function NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-calendar-week-numbers", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("weeks", ctx_r0.weeks)("size", ctx_r0.size)("weekNumberSymbol", ctx_r0.weekNumberSymbol);
  }
}
function NbBaseCalendarComponent_nb_card_header_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-card-header", 5)(1, "nb-calendar-view-mode", 6);
    ɵɵlistener("changeMode", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_view_mode_changeMode_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onChangeViewMode());
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "nb-calendar-pageable-navigation", 7);
    ɵɵlistener("prev", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_pageable_navigation_prev_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigatePrev());
    })("next", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_pageable_navigation_next_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigateNext());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("date", ctx_r1.visibleDate)("viewMode", ctx_r1.activeViewMode);
  }
}
function NbBaseCalendarComponent_nb_calendar_day_picker_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-day-picker", 8);
    ɵɵlistener("dateChange", function NbBaseCalendarComponent_nb_calendar_day_picker_3_Template_nb_calendar_day_picker_dateChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.dateChange.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("boundingMonths", ctx_r1.boundingMonth)("cellComponent", ctx_r1.dayCellComponent)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("visibleDate", ctx_r1.visibleDate)("size", ctx_r1.size)("date", ctx_r1.date)("showWeekNumber", ctx_r1.showWeekNumber)("firstDayOfWeek", ctx_r1.firstDayOfWeek)("weekNumberSymbol", ctx_r1.weekNumberSymbol);
  }
}
function NbBaseCalendarComponent_nb_calendar_year_picker_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-year-picker", 9);
    ɵɵlistener("yearChange", function NbBaseCalendarComponent_nb_calendar_year_picker_4_Template_nb_calendar_year_picker_yearChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ctx_r1.setVisibleDate($event);
      return ɵɵresetView(ctx_r1.setViewMode(ctx_r1.ViewMode.MONTH));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("cellComponent", ctx_r1.yearCellComponent)("date", ctx_r1.date)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("size", ctx_r1.size)("year", ctx_r1.visibleDate);
  }
}
function NbBaseCalendarComponent_nb_calendar_month_picker_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-month-picker", 10);
    ɵɵlistener("monthChange", function NbBaseCalendarComponent_nb_calendar_month_picker_5_Template_nb_calendar_month_picker_monthChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      ctx_r1.setVisibleDate($event);
      return ɵɵresetView(ctx_r1.setViewMode(ctx_r1.ViewMode.DATE));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("cellComponent", ctx_r1.monthCellComponent)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("size", ctx_r1.size)("month", ctx_r1.visibleDate)("date", ctx_r1.date);
  }
}
function NbCalendarActionsComponent_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 2);
    ɵɵlistener("click", function NbCalendarActionsComponent_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.setCurrentTime.emit());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.currentTimeText, "");
  }
}
var _c9 = [[["nb-list-item"]]];
var _c10 = ["nb-list-item"];
var _c11 = ["valueContainer"];
function NbTimePickerComponent_nb_card_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 8);
    ɵɵtext(2, "Time");
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.secondsText);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_5_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵtextInterpolate(ctx_r0.ampmText);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_3_div_5_ng_template_1_Template, 1, 1, "ng-template", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showAmPmLabel);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "div", 8);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbTimePickerComponent_nb_card_0_ng_template_3_div_4_Template, 2, 1, "div", 9)(5, NbTimePickerComponent_nb_card_0_ng_template_3_div_5_Template, 2, 1, "div", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.hoursText);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.minutesText);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.withSeconds);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.twelveHoursFormat);
  }
}
function NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template_nb_timepicker_cell_select_1_listener() {
      const item_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.selectFullTime(item_r3));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassProp("selected", ctx_r0.isSelectedFullTimeValue(item_r3));
    ɵɵadvance();
    ɵɵproperty("value", ctx_r0.getFullTimeString(item_r3))("selected", ctx_r0.isSelectedFullTimeValue(item_r3));
  }
}
function NbTimePickerComponent_nb_card_0_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "nb-list", 11);
    ɵɵtemplate(2, NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r0.fullTimeOptions)("ngForTrackBy", ctx_r0.trackBySingleColumnValue.bind(ctx_r0));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const item_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.setHour(item_r5.value));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassProp("selected", ctx_r0.isSelectedHour(item_r5.value));
    ɵɵadvance();
    ɵɵproperty("value", item_r5.text)("selected", ctx_r0.isSelectedHour(item_r5.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template_nb_timepicker_cell_select_1_listener() {
      const item_r7 = ɵɵrestoreView(_r6).$implicit;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.setMinute(item_r7.value));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r7 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassProp("selected", ctx_r0.isSelectedMinute(item_r7.value));
    ɵɵadvance();
    ɵɵproperty("value", item_r7.text)("selected", ctx_r0.isSelectedMinute(item_r7.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const item_r9 = ɵɵrestoreView(_r8).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0.setSecond(item_r9.value));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r9 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵclassProp("selected", ctx_r0.isSelectedSecond(item_r9.value));
    ɵɵadvance();
    ɵɵproperty("value", item_r9.text)("selected", ctx_r0.isSelectedSecond(item_r9.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-list", 11);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.secondsColumnOptions)("ngForTrackBy", ctx_r0.trackByTimeValues);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 17)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const dayPeriod_r11 = ɵɵrestoreView(_r10).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0.changeDayPeriod(dayPeriod_r11));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const dayPeriod_r11 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵclassProp("selected", ctx_r0.isSelectedDayPeriod(dayPeriod_r11));
    ɵɵadvance();
    ɵɵproperty("value", dayPeriod_r11)("selected", ctx_r0.isSelectedDayPeriod(dayPeriod_r11));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-list", 11);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template, 2, 4, "nb-list-item", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.dayPeriodColumnOptions)("ngForTrackBy", ctx_r0.trackByDayPeriod);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-list", 11);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
    ɵɵelementStart(2, "nb-list", 11);
    ɵɵtemplate(3, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_Template, 2, 2, "nb-list", 15)(5, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_Template, 2, 2, "nb-list", 15);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.hoursColumnOptions)("ngForTrackBy", ctx_r0.trackByTimeValues);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r0.minutesColumnOptions)("ngForTrackBy", ctx_r0.trackByTimeValues);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showSeconds());
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.twelveHoursFormat);
  }
}
function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-card-footer", 18)(1, "nb-calendar-actions", 19);
    ɵɵlistener("setCurrentTime", function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template_nb_calendar_actions_setCurrentTime_1_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.setCurrentTime());
    })("saveValue", function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template_nb_calendar_actions_saveValue_1_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.saveValue());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("applyButtonText", ctx_r0.applyButtonText)("currentTimeButtonText", ctx_r0.currentTimeButtonText);
  }
}
function NbTimePickerComponent_nb_card_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-card", 3)(1, "nb-card-header", 4);
    ɵɵtemplate(2, NbTimePickerComponent_nb_card_0_ng_container_2_Template, 3, 0, "ng-container", 5)(3, NbTimePickerComponent_nb_card_0_ng_template_3_Template, 6, 4, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 6);
    ɵɵtemplate(6, NbTimePickerComponent_nb_card_0_ng_container_6_Template, 3, 2, "ng-container", 5)(7, NbTimePickerComponent_nb_card_0_ng_template_7_Template, 6, 6, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
    ɵɵtemplate(9, NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template, 2, 2, "nb-card-footer", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const fullTimeHeadersBlock_r13 = ɵɵreference(4);
    const fullTimeColumnBlock_r14 = ɵɵreference(8);
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("supports-scrollbar-theming", !ctx_r0.isFirefox());
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.singleColumn)("ngIfElse", fullTimeHeadersBlock_r13);
    ɵɵadvance(4);
    ɵɵproperty("ngIf", ctx_r0.singleColumn)("ngIfElse", fullTimeColumnBlock_r14);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r0.showFooter);
  }
}
var _c122 = ["layoutTopDynamicArea"];
var _c132 = ["scrollableContainer"];
var _c14 = ["layoutContainer"];
var _c15 = [[["nb-layout-header", 3, "subheader", ""]], [["nb-sidebar"]], [["nb-layout-header", "subheader", ""]], [["nb-layout-column"]], [["nb-layout-footer"]]];
var _c16 = ["nb-layout-header:not([subheader])", "nb-sidebar", "nb-layout-header[subheader]", "nb-layout-column", "nb-layout-footer"];
var _c17 = ["nbMenuItem", ""];
function NbMenuItemComponent_span_0_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, NbMenuItemComponent_span_0_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.menuItem.title, "\n");
  }
}
function NbMenuItemComponent_a_1_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const badgeTemplate_r3 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 8);
    ɵɵlistener("mouseenter", function NbMenuItemComponent_a_1_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    })("click", function NbMenuItemComponent_a_1_Template_a_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onItemClick(ctx_r0.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_1_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_1_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r0.menuItem.selected);
    ɵɵproperty("routerLink", ctx_r0.menuItem.link)("queryParams", ctx_r0.menuItem.queryParams)("fragment", ctx_r0.menuItem.fragment)("queryParamsHandling", ctx_r0.menuItem.queryParamsHandling)("preserveFragment", ctx_r0.menuItem.preserveFragment)("skipLocationChange", ctx_r0.menuItem.skipLocationChange);
    ɵɵattribute("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("role", ctx_r0.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badge);
  }
}
function NbMenuItemComponent_a_2_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const badgeTemplate_r3 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 12);
    ɵɵlistener("mouseenter", function NbMenuItemComponent_a_2_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    })("click", function NbMenuItemComponent_a_2_Template_a_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onSelectItem(ctx_r0.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_2_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r0.menuItem.selected);
    ɵɵattribute("href", ctx_r0.menuItem.url, ɵɵsanitizeUrl)("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("role", ctx_r0.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badge);
  }
}
function NbMenuItemComponent_a_3_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_3_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const badgeTemplate_r3 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 12);
    ɵɵlistener("mouseenter", function NbMenuItemComponent_a_3_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    })("click", function NbMenuItemComponent_a_3_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r0 = ɵɵnextContext();
      $event.preventDefault();
      return ɵɵresetView(ctx_r0.onItemClick(ctx_r0.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_3_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_3_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r0.menuItem.selected);
    ɵɵattribute("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("role", ctx_r0.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badge);
  }
}
function NbMenuItemComponent_a_4_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r0.menuItem.icon);
  }
}
function NbMenuItemComponent_a_4_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const badgeTemplate_r3 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r3);
  }
}
function NbMenuItemComponent_a_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 13);
    ɵɵlistener("click", function NbMenuItemComponent_a_4_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r0 = ɵɵnextContext();
      $event.preventDefault();
      return ɵɵresetView(ctx_r0.onToggleSubMenu(ctx_r0.menuItem));
    })("mouseenter", function NbMenuItemComponent_a_4_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onHoverItem(ctx_r0.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_4_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_4_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelement(5, "nb-icon", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    let tmp_5_0;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r0.menuItem.selected);
    ɵɵattribute("target", ctx_r0.menuItem.target)("title", ctx_r0.menuItem.title)("aria-expanded", (tmp_5_0 = ctx_r0.menuItem.expanded) !== null && tmp_5_0 !== void 0 ? tmp_5_0 : false)("role", ctx_r0.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badge);
    ɵɵadvance();
    ɵɵproperty("icon", ctx_r0.getExpandStateIcon());
  }
}
function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 18);
    ɵɵlistener("hoverItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.onHoverItem($event));
    })("toggleSubMenu", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.onToggleSubMenu($event));
    })("selectItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_selectItem_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.onSelectItem($event));
    })("itemClick", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_itemClick_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.onItemClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r8 = ɵɵnextContext().$implicit;
    ɵɵclassProp("menu-group", item_r8.group);
    ɵɵproperty("menuItem", item_r8)("badge", item_r8.badge);
  }
}
function NbMenuItemComponent_ul_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbMenuItemComponent_ul_5_ng_container_1_li_1_Template, 1, 4, "li", 17);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r8 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !item_r8.hidden);
  }
}
function NbMenuItemComponent_ul_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul", 15);
    ɵɵtemplate(1, NbMenuItemComponent_ul_5_ng_container_1_Template, 2, 1, "ng-container", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("collapsed", !(ctx_r0.menuItem.children && ctx_r0.menuItem.expanded))("expanded", ctx_r0.menuItem.expanded);
    ɵɵproperty("@toggle", ctx_r0.toggleState);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.menuItem.children);
  }
}
function NbMenuItemComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 19);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("text", ctx_r0.badge.text)("dotMode", ctx_r0.badge.dotMode)("status", ctx_r0.badge.status);
  }
}
function NbMenuComponent_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 3);
    ɵɵlistener("hoverItem", function NbMenuComponent_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onHoverItem($event));
    })("toggleSubMenu", function NbMenuComponent_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onToggleSubMenu($event));
    })("selectItem", function NbMenuComponent_ng_container_1_li_1_Template_li_selectItem_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelectItem($event));
    })("itemClick", function NbMenuComponent_ng_container_1_li_1_Template_li_itemClick_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onItemClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext().$implicit;
    ɵɵclassProp("menu-group", item_r3.group);
    ɵɵproperty("menuItem", item_r3)("badge", item_r3.badge);
  }
}
function NbMenuComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbMenuComponent_ng_container_1_li_1_Template, 1, 4, "li", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !item_r3.hidden);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("config", tab_r1.icon);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 4)(1, "a", 5);
    ɵɵtemplate(2, NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 6)(3, NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template, 2, 1, "span", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext().$implicit;
    ɵɵclassProp("responsive", tab_r1.responsive);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", tab_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("config", tab_r1.icon);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 10);
    ɵɵpipe(1, "nbMergeConfigs");
    ɵɵelementStart(2, "a", 11);
    ɵɵlistener("click", function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template_a_click_2_listener() {
      ɵɵrestoreView(_r2);
      const tab_r1 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.selectTab(tab_r1));
    });
    ɵɵtemplate(3, NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_3_Template, 1, 1, "nb-icon", 6)(4, NbRouteTabsetComponent_ng_container_1_ng_template_2_span_4_Template, 2, 1, "span", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("routerLinkActiveOptions", ɵɵpipeBind2(1, 13, ctx_r2.activeLinkOptions, tab_r1.activeLinkOptions));
    ɵɵadvance(2);
    ɵɵclassProp("responsive", tab_r1.responsive);
    ɵɵproperty("routerLink", tab_r1.route)("queryParams", tab_r1.queryParams)("queryParamsHandling", tab_r1.queryParamsHandling)("fragment", tab_r1.fragment)("preserveFragment", tab_r1.preserveFragment)("skipLocationChange", tab_r1.skipLocationChange)("replaceUrl", tab_r1.replaceUrl)("state", tab_r1.state);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbRouteTabsetComponent_ng_container_1_li_1_Template, 4, 4, "li", 3)(2, NbRouteTabsetComponent_ng_container_1_ng_template_2_Template, 5, 16, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const tab_r1 = ctx.$implicit;
    const enabled_r4 = ɵɵreference(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.disabled)("ngIfElse", enabled_r4);
  }
}
var _c18 = [[["nb-sidebar-header"]], "*", [["nb-sidebar-footer"]]];
var _c19 = ["nb-sidebar-header", "*", "nb-sidebar-footer"];
function NbTabComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.tabContentDirective.templateRef);
  }
}
function NbTabComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c20 = [[["nb-tab"]]];
var _c21 = ["nb-tab"];
function NbTabsetComponent_li_1_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("config", tab_r2.tabIcon);
  }
}
function NbTabsetComponent_li_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 9);
  }
  if (rf & 2) {
    const tab_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngTemplateOutlet", tab_r2.tabTitleDirective.templateRef);
  }
}
function NbTabsetComponent_li_1_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r2 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(tab_r2.tabTitle);
  }
}
function NbTabsetComponent_li_1_nb_badge_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 11);
  }
  if (rf & 2) {
    const tab_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("text", tab_r2.badgeText)("dotMode", tab_r2.badgeDot)("status", tab_r2.badgeStatus)("position", tab_r2.badgePosition);
  }
}
function NbTabsetComponent_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 3);
    ɵɵlistener("click", function NbTabsetComponent_li_1_Template_li_click_0_listener() {
      const tab_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.selectTab(tab_r2));
    })("keyup.space", function NbTabsetComponent_li_1_Template_li_keyup_space_0_listener() {
      const tab_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.selectTab(tab_r2));
    })("keyup.enter", function NbTabsetComponent_li_1_Template_li_keyup_enter_0_listener() {
      const tab_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.selectTab(tab_r2));
    });
    ɵɵelementStart(1, "a", 4);
    ɵɵlistener("click", function NbTabsetComponent_li_1_Template_a_click_1_listener($event) {
      ɵɵrestoreView(_r1);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵtemplate(2, NbTabsetComponent_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 5)(3, NbTabsetComponent_li_1_ng_container_3_Template, 1, 1, "ng-container", 6)(4, NbTabsetComponent_li_1_ng_template_4_Template, 2, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
    ɵɵtemplate(6, NbTabsetComponent_li_1_nb_badge_6_Template, 1, 4, "nb-badge", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r2 = ctx.$implicit;
    const textTitleTemplate_r4 = ɵɵreference(5);
    ɵɵclassProp("responsive", tab_r2.responsive)("active", tab_r2.active)("disabled", tab_r2.disabled);
    ɵɵattribute("tabindex", tab_r2.disabled ? -1 : 0)("data-tab-id", tab_r2.tabId);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", tab_r2.tabIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r2.tabTitleDirective)("ngIfElse", textTitleTemplate_r4);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", tab_r2.badgeText || tab_r2.badgeDot);
  }
}
function NbUserComponent_div_1_nb_badge_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("text", ctx_r0.badgeText)("status", ctx_r0.badgeStatus)("position", ctx_r0.badgePosition);
  }
}
function NbUserComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, NbUserComponent_div_1_nb_badge_1_Template, 1, 3, "nb-badge", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("background-image", ctx_r0.imageBackgroundStyle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badgeText);
  }
}
function NbUserComponent_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.getInitials(), " ");
  }
}
function NbUserComponent_div_2_nb_badge_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("text", ctx_r0.badgeText)("status", ctx_r0.badgeStatus)("position", ctx_r0.badgePosition);
  }
}
function NbUserComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵtemplate(1, NbUserComponent_div_2_ng_container_1_Template, 2, 1, "ng-container", 10)(2, NbUserComponent_div_2_nb_badge_2_Template, 1, 3, "nb-badge", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("background-color", ctx_r0.color);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showInitials);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badgeText);
  }
}
function NbUserComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.name);
  }
}
function NbUserComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
function NbActionComponent_ng_container_0_a_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 6);
    ɵɵelement(1, "nb-icon", 7);
    ɵɵelementContainer(2, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    const badgeTemplate_r2 = ɵɵreference(4);
    ɵɵproperty("routerLink", ctx_r0.link)("title", ctx_r0.title);
    ɵɵadvance();
    ɵɵproperty("config", ctx_r0.icon);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_container_0_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 9);
    ɵɵelement(1, "nb-icon", 7);
    ɵɵelementContainer(2, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    const badgeTemplate_r2 = ɵɵreference(4);
    ɵɵproperty("href", ctx_r0.href, ɵɵsanitizeUrl)("title", ctx_r0.title);
    ɵɵadvance();
    ɵɵproperty("config", ctx_r0.icon);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_container_0_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 10);
    ɵɵlistener("click", function NbActionComponent_ng_container_0_a_3_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelement(1, "nb-icon", 7);
    ɵɵelementContainer(2, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    const badgeTemplate_r2 = ɵɵreference(4);
    ɵɵproperty("title", ctx_r0.title);
    ɵɵadvance();
    ɵɵproperty("config", ctx_r0.icon);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbActionComponent_ng_container_0_a_1_Template, 3, 4, "a", 3)(2, NbActionComponent_ng_container_0_a_2_Template, 3, 4, "a", 4)(3, NbActionComponent_ng_container_0_a_3_Template, 3, 3, "a", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.link);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.href && !ctx_r0.link);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.href && !ctx_r0.link);
  }
}
function NbActionComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
    ɵɵelementContainer(1, 8);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const badgeTemplate_r2 = ɵɵreference(4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", badgeTemplate_r2);
  }
}
function NbActionComponent_ng_template_3_nb_badge_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("text", ctx_r0.badgeText)("dotMode", ctx_r0.badgeDot)("status", ctx_r0.badgeStatus)("position", ctx_r0.badgePosition);
  }
}
function NbActionComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, NbActionComponent_ng_template_3_nb_badge_0_Template, 1, 4, "nb-badge", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r0.badgeText || ctx_r0.badgeDot);
  }
}
var _c22 = [[["nb-action"]]];
var _c23 = ["nb-action"];
var _c24 = ["searchInput"];
var _c25 = ["searchButton"];
function NbSearchComponent_nb_search_field_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-search-field", 4);
    ɵɵlistener("search", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_search_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.search($event));
    })("searchInput", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_searchInput_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.emitInput($event));
    })("close", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_close_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.emitDeactivate());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("show", ctx_r2.showSearchField)("type", ctx_r2.type)("placeholder", ctx_r2.placeholder)("hint", ctx_r2.hint);
  }
}
function NbCheckboxComponent_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 6);
  }
}
function NbCheckboxComponent_nb_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
}
function NbProgressBarComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.value, "%");
  }
}
function NbAlertComponent_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 1);
    ɵɵlistener("click", function NbAlertComponent_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClose());
    });
    ɵɵelementStart(1, "span", 2);
    ɵɵtext(2, "×");
    ɵɵelementEnd()();
  }
}
function NbChatFormComponent_div_0_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div")(1, "span", 9);
    ɵɵlistener("click", function NbChatFormComponent_div_0_ng_container_1_div_1_Template_span_click_1_listener() {
      ɵɵrestoreView(_r1);
      const file_r2 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.removeFile(file_r2));
    });
    ɵɵtext(2, "×");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const file_r2 = ɵɵnextContext().$implicit;
    ɵɵstyleProp("background-image", file_r2.urlStyle);
  }
}
function NbChatFormComponent_div_0_ng_container_1_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div");
    ɵɵelement(1, "nb-icon", 10);
    ɵɵelementStart(2, "span", 9);
    ɵɵlistener("click", function NbChatFormComponent_div_0_ng_container_1_div_2_Template_span_click_2_listener() {
      ɵɵrestoreView(_r4);
      const file_r2 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.removeFile(file_r2));
    });
    ɵɵtext(3, "×");
    ɵɵelementEnd()();
  }
}
function NbChatFormComponent_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbChatFormComponent_div_0_ng_container_1_div_1_Template, 3, 2, "div", 7)(2, NbChatFormComponent_div_0_ng_container_1_div_2_Template, 4, 0, "div", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const file_r2 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", file_r2.urlStyle);
    ɵɵadvance();
    ɵɵproperty("ngIf", !file_r2.urlStyle);
  }
}
function NbChatFormComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵtemplate(1, NbChatFormComponent_div_0_ng_container_1_Template, 3, 2, "ng-container", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.droppedFiles);
  }
}
function NbChatFormComponent_button_3_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 13);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("icon", ctx_r2.buttonIcon);
  }
}
function NbChatFormComponent_button_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r2.buttonTitle);
  }
}
function NbChatFormComponent_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 11);
    ɵɵlistener("click", function NbChatFormComponent_button_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.sendMessage());
    });
    ɵɵtemplate(1, NbChatFormComponent_button_3_nb_icon_1_Template, 1, 1, "nb-icon", 12)(2, NbChatFormComponent_button_3_ng_template_2_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const title_r6 = ɵɵreference(3);
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("with-icon", !ctx_r2.buttonTitle);
    ɵɵproperty("status", ctx_r2.getButtonStatus());
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.buttonTitle)("ngIfElse", title_r6);
  }
}
function NbChatMessageTextComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 2);
    ɵɵtext(1);
    ɵɵelementStart(2, "time");
    ɵɵtext(3);
    ɵɵpipe(4, "date");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.sender, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind2(4, 2, ctx_r0.date, ctx_r0.dateFormat));
  }
}
function NbChatMessageTextComponent_p_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.message);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const file_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("icon", file_r1.icon);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const file_r1 = ɵɵnextContext().$implicit;
    ɵɵstyleProp("background-image", file_r1.urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 4);
    ɵɵtemplate(1, NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 5)(2, NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template, 1, 2, "div", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const file_r1 = ctx.$implicit;
    ɵɵproperty("href", file_r1.url, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngIf", !file_r1.urlStyle && file_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", file_r1.urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 2);
    ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_a_2_Template, 3, 3, "a", 3);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.readyFiles);
  }
}
function NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("icon", ctx_r1.readyFiles[0].icon);
  }
}
function NbChatMessageFileComponent_ng_container_3_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("background-image", ctx_r1.readyFiles[0].urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "a", 4);
    ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template, 1, 1, "nb-icon", 5)(3, NbChatMessageFileComponent_ng_container_3_div_3_Template, 1, 2, "div", 6);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("href", ctx_r1.readyFiles[0].url, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.readyFiles[0].urlStyle && ctx_r1.readyFiles[0].icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.readyFiles[0].urlStyle);
  }
}
function NbChatMessageQuoteComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 3);
    ɵɵtext(1);
    ɵɵelementStart(2, "time");
    ɵɵtext(3);
    ɵɵpipe(4, "date");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.sender, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind2(4, 2, ctx_r0.date, ctx_r0.dateFormat));
  }
}
var _c26 = (a0) => [a0];
function NbChatAvatarComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.initials, " ");
  }
}
function NbChatMessageComponent_nb_chat_avatar_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-avatar", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("initials", ctx_r0.getInitials())("avatarStyle", ctx_r0.avatarStyle);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_file_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-file", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message)("files", ctx_r0.files);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_quote_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-quote", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message)("quote", ctx_r0.quote);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_map_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-map", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r0.sender)("date", ctx_r0.date)("message", ctx_r0.message)("latitude", ctx_r0.latitude)("longitude", ctx_r0.longitude);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_text_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-text", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message);
  }
}
function NbChatMessageComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 5);
    ɵɵtemplate(1, NbChatMessageComponent_ng_container_2_nb_chat_message_file_1_Template, 1, 5, "nb-chat-message-file", 6)(2, NbChatMessageComponent_ng_container_2_nb_chat_message_quote_2_Template, 1, 5, "nb-chat-message-quote", 7)(3, NbChatMessageComponent_ng_container_2_nb_chat_message_map_3_Template, 1, 5, "nb-chat-message-map", 8)(4, NbChatMessageComponent_ng_container_2_nb_chat_message_text_4_Template, 1, 4, "nb-chat-message-text", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngSwitch", ctx_r0.type);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "file");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "quote");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "map");
  }
}
function NbChatMessageComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-text", 13);
    ɵɵelementStart(1, "div");
    ɵɵelementContainer(2, 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("sender", ctx_r0.sender)("date", ctx_r0.date)("dateFormat", ctx_r0.dateFormat)("message", ctx_r0.message);
    ɵɵadvance();
    ɵɵclassProp("nb-custom-message", ctx_r0._areDefaultStylesEnabled())("nb-custom-message-no-space", ctx_r0._addNoSpaceClass)("nb-custom-message-reply", ctx_r0._addReplyClass)("nb-custom-message-not-reply", ctx_r0._addNotReplyClass)("nb-custom-message-full-width", !ctx_r0._areDefaultStylesEnabled());
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0._getTemplate())("ngTemplateOutletContext", ctx_r0._getTemplateContext());
  }
}
var _c27 = ["scrollable"];
var _c28 = [[["nb-chat-message"]], [["nb-chat-form"]]];
var _c29 = ["nb-chat-message", "nb-chat-form"];
var _c30 = (a0) => ({
  $implicit: a0
});
function NbChatComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.titleTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c30, ctx_r0.titleTemplate.context));
  }
}
function NbChatComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r0.title, " ");
  }
}
function NbChatComponent_p_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.noMessagesPlaceholder);
  }
}
function NbSpinnerComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.message);
  }
}
function NbStepComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c31 = [[["nb-step"]]];
var _c32 = ["nb-step"];
function NbStepperComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function NbStepperComponent_ng_container_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 6);
  }
  if (rf & 2) {
    const index_r1 = ɵɵnextContext().index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("connector-past", index_r1 <= ctx_r1.selectedIndex);
  }
}
function NbStepperComponent_ng_container_2_div_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const index_r1 = ɵɵnextContext(2).index;
    ɵɵadvance();
    ɵɵtextInterpolate(index_r1 + 1);
  }
}
function NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 12);
  }
}
function NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function NbStepperComponent_ng_container_2_div_2_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const step_r4 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.getStepTemplate(step_r4));
  }
}
function NbStepperComponent_ng_container_2_div_2_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const step_r4 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(step_r4.label);
  }
}
function NbStepperComponent_ng_container_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7);
    ɵɵlistener("click", function NbStepperComponent_ng_container_2_div_2_Template_div_click_0_listener() {
      ɵɵrestoreView(_r3);
      const step_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changeStep(step_r4));
    });
    ɵɵelementStart(1, "div", 8);
    ɵɵtemplate(2, NbStepperComponent_ng_container_2_div_2_span_2_Template, 2, 1, "span", 9)(3, NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template, 1, 0, "nb-icon", 10);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 11);
    ɵɵtemplate(5, NbStepperComponent_ng_container_2_div_2_ng_container_5_Template, 2, 1, "ng-container", 9)(6, NbStepperComponent_ng_container_2_div_2_span_6_Template, 2, 1, "span", 9);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const step_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("selected", ctx_r1.isStepSelected(step_r4))("completed", !ctx_r1.isStepSelected(step_r4) && step_r4.completed)("noninteractive", ctx_r1.disableStepNavigation);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !step_r4.completed || ctx_r1.isStepSelected(step_r4));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isStepSelected(step_r4) && step_r4.completed);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", step_r4.isLabelTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !step_r4.isLabelTemplate);
  }
}
function NbStepperComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbStepperComponent_ng_container_2_div_1_Template, 1, 2, "div", 4)(2, NbStepperComponent_ng_container_2_div_2_Template, 7, 10, "div", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const step_r4 = ctx.$implicit;
    const first_r5 = ctx.first;
    ɵɵadvance();
    ɵɵproperty("ngIf", !first_r5 && !step_r4.hidden);
    ɵɵadvance();
    ɵɵproperty("ngIf", !step_r4.hidden);
  }
}
var _c33 = [[["nb-accordion-item"]]];
var _c34 = ["nb-accordion-item"];
var _c35 = [[["nb-accordion-item-header"]], [["nb-accordion-item-body"]]];
var _c36 = ["nb-accordion-item-header", "nb-accordion-item-body"];
var _c37 = (a0) => ({
  value: a0
});
var _c38 = [[["nb-accordion-item-title"]], [["nb-accordion-item-description"]], "*"];
var _c39 = ["nb-accordion-item-title", "nb-accordion-item-description", "*"];
function NbAccordionItemHeaderComponent_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("@expansionIndicator", ctx_r0.state);
  }
}
function NbDialogContainerComponent_ng_template_0_Template(rf, ctx) {
}
function NbToastComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵelement(1, "nb-icon", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("config", ctx_r0.icon);
  }
}
function NbToastrContainerComponent_nb_toast_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-toast", 1);
  }
  if (rf & 2) {
    const toast_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("@fadeIn", ctx_r1.fadeIn)("toast", toast_r1);
  }
}
function NbTooltipComponent_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("config", ctx_r0.context.icon);
  }
}
function NbTooltipComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.content);
  }
}
function NbOptionComponent_nb_checkbox_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-checkbox", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("checked", ctx_r0.selected)("disabled", ctx_r0.disabled);
  }
}
var _c40 = ["selectButton"];
var _c41 = [[["nb-select-label"]], [["nb-option"], ["nb-option-group"]]];
var _c42 = ["nb-select-label", "nb-option, nb-option-group"];
function NbSelectComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementContainerEnd();
  }
}
function NbSelectComponent_ng_container_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r1.selectionView);
  }
}
function NbSelectComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbSelectComponent_ng_container_3_ng_container_1_Template, 2, 0, "ng-container", 5)(2, NbSelectComponent_ng_container_3_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const defaultSelectionTemplate_r3 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.customLabel)("ngIfElse", defaultSelectionTemplate_r3);
  }
}
function NbSelectComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r1.placeholder);
  }
}
function NbSelectComponent_nb_option_list_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-option-list", 8);
    ɵɵprojection(1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r1.optionsWidth, "px");
    ɵɵproperty("size", ctx_r1.size)("position", ctx_r1.overlayPosition)("ngClass", ctx_r1.optionsListClass);
  }
}
var _c43 = [[["nb-option"], ["ng-container"]]];
var _c44 = ["nb-option, ng-container"];
var _c45 = ["*", [["", "nbPrefix", ""]], [["", "nbSuffix", ""]]];
var _c46 = ["*", "[nbPrefix]", "[nbSuffix]"];
function NbFormFieldComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵpipe(1, "async");
    ɵɵprojection(2, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpipeBind1(1, 1, ctx_r0.prefixClasses$));
  }
}
function NbFormFieldComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵpipe(1, "async");
    ɵɵprojection(2, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpipeBind1(1, 1, ctx_r0.suffixClasses$));
  }
}
var _c47 = ["optionsAutocompleteInput"];
function NbSelectWithAutocompleteComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementContainerEnd();
  }
}
function NbSelectWithAutocompleteComponent_ng_container_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r1.selectionView);
  }
}
function NbSelectWithAutocompleteComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbSelectWithAutocompleteComponent_ng_container_3_ng_container_1_Template, 2, 0, "ng-container", 6)(2, NbSelectWithAutocompleteComponent_ng_container_3_ng_template_2_Template, 1, 1, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const defaultSelectionTemplate_r3 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.customLabel)("ngIfElse", defaultSelectionTemplate_r3);
  }
}
function NbSelectWithAutocompleteComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r1.placeholder);
  }
}
function NbSelectWithAutocompleteComponent_nb_option_list_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-option-list", 12);
    ɵɵprojection(1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r1.optionsWidth, "px");
    ɵɵproperty("size", ctx_r1.size)("position", ctx_r1.overlayPosition)("ngClass", ctx_r1.optionsListClass);
  }
}
var _c48 = [[["nb-option"], ["nb-option-group"]]];
var _c49 = ["nb-option, nb-option-group"];
function NbAutocompleteComponent_nb_option_list_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-option-list", 1);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r0.optionsWidth, "px");
    ɵɵclassProp("empty", !(ctx_r0.options == null ? null : ctx_r0.options.length));
    ɵɵproperty("size", ctx_r0.size)("position", ctx_r0.overlayPosition)("id", ctx_r0.id)("ngClass", ctx_r0.optionsListClass);
  }
}
var _c50 = ["viewContainerRef"];
function NbWindowComponent_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function NbWindowComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtemplate(1, NbWindowComponent_div_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.config.titleTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c30, ctx_r0.config.titleTemplateContext));
  }
}
function NbWindowComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.config.title);
  }
}
function NbWindowComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_6_Template_button_click_1_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.minimize());
    });
    ɵɵelement(2, "nb-icon", 8);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function NbWindowComponent_ng_container_7_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_7_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.maximize());
    });
    ɵɵelement(1, "nb-icon", 10);
    ɵɵelementEnd();
  }
}
function NbWindowComponent_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbWindowComponent_ng_container_7_button_1_Template, 2, 0, "button", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isFullScreen);
  }
}
function NbWindowComponent_ng_container_8_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_8_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.maximizeOrFullScreen());
    });
    ɵɵelement(1, "nb-icon", 11);
    ɵɵelementEnd();
  }
}
function NbWindowComponent_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbWindowComponent_ng_container_8_button_1_Template, 2, 0, "button", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.minimized || ctx_r0.maximized);
  }
}
function NbWindowComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_9_Template_button_click_1_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.close());
    });
    ɵɵelement(2, "nb-icon", 12);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function NbWindowComponent_nb_card_body_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-card-body");
    ɵɵelement(1, "nb-overlay-container");
    ɵɵelementEnd();
  }
}
var _c51 = ["input"];
var _c52 = [[["nb-radio"]]];
var _c53 = ["nb-radio"];
function NbTagComponent_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-icon", 1);
    ɵɵlistener("click", function NbTagComponent_nb_icon_1_Template_nb_icon_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._remove());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMapInterpolate1("nb-tag-remove size-", ctx_r1.size, "");
  }
}
var _c54 = [[["nb-tag"], ["input", "nbTagInput", ""]]];
var _c55 = ["nb-tag, input[nbTagInput]"];
function NbSortIconComponent_ng_container_0_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 3);
  }
}
function NbSortIconComponent_ng_container_0_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 4);
  }
}
function NbSortIconComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbSortIconComponent_ng_container_0_nb_icon_1_Template, 1, 0, "nb-icon", 1)(2, NbSortIconComponent_ng_container_0_nb_icon_2_Template, 1, 0, "nb-icon", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isAscending());
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isDescending());
  }
}
var _c56 = ["nbSortHeader", ""];
function NbSortHeaderComponent_nb_sort_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-sort-icon", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("direction", ctx_r1.direction);
  }
}
function NbSortHeaderComponent_ng_template_3_Template(rf, ctx) {
}
var _c57 = ["nbTreeGrid", ""];
var _c58 = ["nbTreeGridRow", ""];
var _c59 = ["nbTreeGridHeaderRow", ""];
var _c60 = ["nbTreeGridFooterRow", ""];
function NbToggleComponent_nb_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 6);
  }
}
var NB_THEME_OPTIONS = new InjectionToken("Nebular Theme Options");
var NB_MEDIA_BREAKPOINTS = new InjectionToken("Nebular Media Breakpoints");
var NB_BUILT_IN_JS_THEMES = new InjectionToken("Nebular Built-in JS Themes");
var NB_JS_THEMES = new InjectionToken("Nebular JS Themes");
var NB_WINDOW = new InjectionToken("Window");
var NB_DOCUMENT = new InjectionToken("Document");
var DEFAULT_MEDIA_BREAKPOINTS = [{
  name: "xs",
  width: 0
}, {
  name: "is",
  width: 400
}, {
  name: "sm",
  width: 576
}, {
  name: "md",
  width: 768
}, {
  name: "lg",
  width: 992
}, {
  name: "xl",
  width: 1200
}, {
  name: "xxl",
  width: 1400
}, {
  name: "xxxl",
  width: 1600
}];
var NbMediaBreakpointsService = class _NbMediaBreakpointsService {
  constructor(breakpoints) {
    this.breakpoints = breakpoints;
    this.breakpointsMap = this.breakpoints.reduce((res, b) => {
      res[b.name] = b.width;
      return res;
    }, {});
  }
  /**
   * Returns a configured breakpoint by width
   * @param width number
   * @returns {Z|{name: string, width: number}}
   */
  getByWidth(width) {
    const unknown = {
      name: "unknown",
      width
    };
    const breakpoints = this.getBreakpoints();
    return breakpoints.find((point, index) => {
      const next = breakpoints[index + 1];
      return width >= point.width && (!next || width < next.width);
    }) || unknown;
  }
  /**
   * Returns a configured breakpoint by name
   * @param name string
   * @returns NbMediaBreakpoint
   */
  getByName(name) {
    const unknown = {
      name: "unknown",
      width: NaN
    };
    const breakpoints = this.getBreakpoints();
    return breakpoints.find((point) => name === point.name) || unknown;
  }
  /**
   * Returns a list of configured breakpoints for the theme
   * @returns NbMediaBreakpoint[]
   */
  getBreakpoints() {
    return this.breakpoints;
  }
  /**
   * Returns a map of configured breakpoints for the theme
   * @returns {[p: string]: number}
   */
  getBreakpointsMap() {
    return this.breakpointsMap;
  }
  static {
    this.ɵfac = function NbMediaBreakpointsService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbMediaBreakpointsService)(ɵɵinject(NB_MEDIA_BREAKPOINTS));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbMediaBreakpointsService,
      factory: _NbMediaBreakpointsService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMediaBreakpointsService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_MEDIA_BREAKPOINTS]
    }]
  }], null);
})();
var palette$3 = {
  primary: "#3366ff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var DEFAULT_THEME = {
  name: "default",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#ffffff",
    bg2: "#f7f9fc",
    bg3: "#edf1f7",
    bg4: "#e4e9f2",
    border: "#ffffff",
    border2: "#f7f9fc",
    border3: "#edf1f7",
    border4: "#e4e9f2",
    border5: "#c5cee0",
    fg: "#8f9bb3",
    fgHeading: "#1a2138",
    fgText: "#1a2138",
    fgHighlight: palette$3.primary,
    layoutBg: "#f7f9fc",
    separator: "#edf1f7",
    primary: palette$3.primary,
    success: palette$3.success,
    info: palette$3.info,
    warning: palette$3.warning,
    danger: palette$3.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette$2 = {
  primary: "#a16eff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var COSMIC_THEME = {
  name: "cosmic",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#323259",
    bg2: "#252547",
    bg3: "#1b1b38",
    bg4: "#13132b",
    border: "#323259",
    border2: "#252547",
    border3: "#1b1b38",
    border4: "#13132b",
    border5: "#13132b",
    fg: "#b4b4db",
    fgHeading: "#ffffff",
    fgText: "#ffffff",
    fgHighlight: palette$2.primary,
    layoutBg: "#151a30",
    separator: "#151a30",
    primary: palette$2.primary,
    success: palette$2.success,
    info: palette$2.info,
    warning: palette$2.warning,
    danger: palette$2.danger,
    primaryLight: "#b18aff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette$1 = {
  primary: "#73a1ff",
  success: "#5dcfe3",
  info: "#ba7fec",
  warning: "#ffa36b",
  danger: "#ff6b83"
};
var CORPORATE_THEME = {
  name: "corporate",
  base: "default",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#ffffff",
    bg2: "#f7f9fc",
    bg3: "#edf1f7",
    bg4: "#e4e9f2",
    border: "#ffffff",
    border2: "#f7f9fc",
    border3: "#edf1f7",
    border4: "#e4e9f2",
    border5: "#c5cee0",
    fg: "#8f9bb3",
    fgHeading: "#1a2138",
    fgText: "#1a2138",
    fgHighlight: palette$1.primary,
    layoutBg: "#f7f9fc",
    separator: "#edf1f7",
    primary: palette$1.primary,
    success: palette$1.success,
    info: palette$1.info,
    warning: palette$1.warning,
    danger: palette$1.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette = {
  primary: "#3366ff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var DARK_THEME = {
  name: "dark",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#222b45",
    bg2: "#1a2138",
    bg3: "#151a30",
    bg4: "#101426",
    border: "#222b45",
    border2: "#1a2138",
    border3: "#151a30",
    border4: "#101426",
    border5: "#101426",
    fg: "#8f9bb3",
    fgHeading: "#ffffff",
    fgText: "#ffffff",
    fgHighlight: palette.primary,
    layoutBg: "#1b1b38",
    separator: "#1b1b38",
    primary: palette.primary,
    success: palette.success,
    info: palette.info,
    warning: palette.warning,
    danger: palette.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var BUILT_IN_THEMES = [DEFAULT_THEME, COSMIC_THEME, CORPORATE_THEME, DARK_THEME];
var NbJSThemesRegistry = class _NbJSThemesRegistry {
  constructor(builtInThemes, newThemes = []) {
    this.themes = {};
    const themes = this.combineByNames(newThemes, builtInThemes);
    themes.forEach((theme) => {
      this.register(theme, theme.name, theme.base);
    });
  }
  /**
   * Registers a new JS theme
   * @param config any
   * @param themeName string
   * @param baseTheme string
   */
  register(config, themeName, baseTheme) {
    const base = this.has(baseTheme) ? this.get(baseTheme) : {};
    this.themes[themeName] = this.mergeDeep({}, base, config);
  }
  /**
   * Checks whether the theme is registered
   * @param themeName
   * @returns boolean
   */
  has(themeName) {
    return !!this.themes[themeName];
  }
  /**
   * Return a theme
   * @param themeName
   * @returns NbJSThemeOptions
   */
  get(themeName) {
    if (!this.themes[themeName]) {
      throw Error(`NbThemeConfig: no theme '${themeName}' found registered.`);
    }
    return JSON.parse(JSON.stringify(this.themes[themeName]));
  }
  combineByNames(newThemes, oldThemes) {
    if (newThemes) {
      const mergedThemes = [];
      newThemes.forEach((theme) => {
        const sameOld = oldThemes.find((tm) => tm.name === theme.name) || {};
        const mergedTheme = this.mergeDeep({}, sameOld, theme);
        mergedThemes.push(mergedTheme);
      });
      oldThemes.forEach((theme) => {
        if (!mergedThemes.find((tm) => tm.name === theme.name)) {
          mergedThemes.push(theme);
        }
      });
      return mergedThemes;
    }
    return oldThemes;
  }
  isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }
  // TODO: move to helpers
  mergeDeep(target, ...sources) {
    if (!sources.length) {
      return target;
    }
    const source = sources.shift();
    if (this.isObject(target) && this.isObject(source)) {
      for (const key in source) {
        if (this.isObject(source[key])) {
          if (!target[key]) {
            Object.assign(target, {
              [key]: {}
            });
          }
          this.mergeDeep(target[key], source[key]);
        } else {
          Object.assign(target, {
            [key]: source[key]
          });
        }
      }
    }
    return this.mergeDeep(target, ...sources);
  }
  static {
    this.ɵfac = function NbJSThemesRegistry_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbJSThemesRegistry)(ɵɵinject(NB_BUILT_IN_JS_THEMES), ɵɵinject(NB_JS_THEMES));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbJSThemesRegistry,
      factory: _NbJSThemesRegistry.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbJSThemesRegistry, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_BUILT_IN_JS_THEMES]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_JS_THEMES]
    }]
  }], null);
})();
var NbThemeService = class _NbThemeService {
  constructor(options, breakpointService, jsThemesRegistry) {
    this.options = options;
    this.breakpointService = breakpointService;
    this.jsThemesRegistry = jsThemesRegistry;
    this.themeChanges$ = new ReplaySubject(1);
    this.appendLayoutClass$ = new Subject();
    this.removeLayoutClass$ = new Subject();
    this.changeWindowWidth$ = new ReplaySubject(2);
    if (options && options.name) {
      this.changeTheme(options.name);
    }
  }
  /**
   * Change current application theme
   * @param {string} name
   */
  changeTheme(name) {
    this.themeChanges$.next({
      name,
      previous: this.currentTheme
    });
    this.currentTheme = name;
  }
  changeWindowWidth(width) {
    this.changeWindowWidth$.next(width);
  }
  /**
   * Returns a theme object with variables (color/paddings/etc) on a theme change.
   * Once subscribed - returns current theme.
   *
   * @returns {Observable<NbJSThemeOptions>}
   */
  getJsTheme() {
    return this.onThemeChange().pipe(map((theme) => {
      return this.jsThemesRegistry.get(theme.name);
    }));
  }
  /**
   * Triggers media query breakpoint change
   * Returns a pair where the first item is previous media breakpoint and the second item is current breakpoit.
   * ```ts
   *  [{ name: 'xs', width: 0 }, { name: 'md', width: 768 }] // change from `xs` to `md`
   * ```
   * @returns {Observable<[NbMediaBreakpoint, NbMediaBreakpoint]>}
   */
  onMediaQueryChange() {
    return this.changeWindowWidth$.pipe(startWith(void 0), pairwise(), map(([prevWidth, width]) => {
      return [this.breakpointService.getByWidth(prevWidth), this.breakpointService.getByWidth(width)];
    }), filter(([prevPoint, point]) => {
      return prevPoint.name !== point.name;
    }), distinctUntilChanged(null, (params) => params[0].name + params[1].name), share());
  }
  /**
   * Triggered when current theme is changed
   * @returns {Observable<any>}
   */
  onThemeChange() {
    return this.themeChanges$.pipe(share());
  }
  /**
   * Append a class to nb-layout
   * @param {string} className
   */
  appendLayoutClass(className) {
    this.appendLayoutClass$.next(className);
  }
  /**
   * Triggered when a new class is added to nb-layout through `appendLayoutClass` method
   * @returns {Observable<any>}
   */
  onAppendLayoutClass() {
    return this.appendLayoutClass$.pipe(share());
  }
  /**
   * Removes a class from nb-layout
   * @param {string} className
   */
  removeLayoutClass(className) {
    this.removeLayoutClass$.next(className);
  }
  /**
   * Triggered when a class is removed from nb-layout through `removeLayoutClass` method
   * @returns {Observable<any>}
   */
  onRemoveLayoutClass() {
    return this.removeLayoutClass$.pipe(share());
  }
  static {
    this.ɵfac = function NbThemeService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbThemeService)(ɵɵinject(NB_THEME_OPTIONS), ɵɵinject(NbMediaBreakpointsService), ɵɵinject(NbJSThemesRegistry));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbThemeService,
      factory: _NbThemeService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbThemeService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_THEME_OPTIONS]
    }]
  }, {
    type: NbMediaBreakpointsService
  }, {
    type: NbJSThemesRegistry
  }], null);
})();
var NbSpinnerService = class _NbSpinnerService {
  constructor(document2) {
    this.document = document2;
    this.loaders = [];
    this.selector = "nb-global-spinner";
  }
  /**
   * Appends new loader to the list of loader to be completed before
   * spinner will be hidden
   * @param method Promise<any>
   */
  registerLoader(method) {
    this.loaders.push(method);
  }
  /**
   * Clears the list of loader
   */
  clear() {
    this.loaders = [];
  }
  /**
   * Start the loader process, show spinnder and execute loaders
   */
  load() {
    this.showSpinner();
    this.executeAll();
  }
  executeAll(done = (values) => {
  }) {
    Promise.all(this.loaders).then((values) => {
      this.hideSpinner();
      done.call(null, values);
    }).catch((error) => {
      console.error(error);
    });
  }
  // TODO is there any better way of doing this?
  showSpinner() {
    const el = this.getSpinnerElement();
    if (el) {
      el.style["display"] = "block";
    }
  }
  hideSpinner() {
    const el = this.getSpinnerElement();
    if (el) {
      el.style["display"] = "none";
    }
  }
  getSpinnerElement() {
    return this.document.getElementById(this.selector);
  }
  static {
    this.ɵfac = function NbSpinnerService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSpinnerService)(ɵɵinject(NB_DOCUMENT));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbSpinnerService,
      factory: _NbSpinnerService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbLayoutDirection;
(function(NbLayoutDirection2) {
  NbLayoutDirection2["LTR"] = "ltr";
  NbLayoutDirection2["RTL"] = "rtl";
})(NbLayoutDirection || (NbLayoutDirection = {}));
var NB_LAYOUT_DIRECTION = new InjectionToken("Layout direction");
var NbLayoutDirectionService = class _NbLayoutDirectionService {
  constructor(direction = NbLayoutDirection.LTR) {
    this.direction = direction;
    this.$directionChange = new ReplaySubject(1);
    this.setDirection(direction);
  }
  /**
   * Returns true if layout direction set to left to right.
   * @returns boolean.
   * */
  isLtr() {
    return this.direction === NbLayoutDirection.LTR;
  }
  /**
   * Returns true if layout direction set to right to left.
   * @returns boolean.
   * */
  isRtl() {
    return this.direction === NbLayoutDirection.RTL;
  }
  /**
   * Returns current layout direction.
   * @returns NbLayoutDirection.
   * */
  getDirection() {
    return this.direction;
  }
  /**
   * Sets layout direction
   * @param {NbLayoutDirection} direction
   */
  setDirection(direction) {
    this.direction = direction;
    this.$directionChange.next(direction);
  }
  /**
   * Triggered when direction was changed.
   * @returns Observable<NbLayoutDirection>.
   */
  onDirectionChange() {
    return this.$directionChange.pipe(share());
  }
  static {
    this.ɵfac = function NbLayoutDirectionService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbLayoutDirectionService)(ɵɵinject(NB_LAYOUT_DIRECTION, 8));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbLayoutDirectionService,
      factory: _NbLayoutDirectionService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutDirectionService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_LAYOUT_DIRECTION]
    }]
  }], null);
})();
var NbLayoutScrollService = class _NbLayoutScrollService {
  constructor() {
    this.scrollPositionReq$ = new Subject();
    this.manualScroll$ = new Subject();
    this.scroll$ = new Subject();
    this.scrollable$ = new Subject();
  }
  /**
   * Returns scroll position
   *
   * @returns {Observable<NbScrollPosition>}
   */
  getPosition() {
    return new Observable((observer) => {
      const listener = new Subject();
      listener.subscribe(observer);
      this.scrollPositionReq$.next({
        listener
      });
      return () => listener.complete();
    });
  }
  /**
   * Sets scroll position
   *
   * @param {number} x
   * @param {number} y
   */
  scrollTo(x = null, y = null) {
    this.manualScroll$.next({
      x,
      y
    });
  }
  /**
   * Returns a stream of scroll events
   *
   * @returns {Observable<any>}
   */
  onScroll() {
    return this.scroll$.pipe(share());
  }
  /**
   * @private
   * @returns Observable<NbScrollPosition>.
   */
  onManualScroll() {
    return this.manualScroll$.pipe(share());
  }
  /**
   * @private
   * @returns {Subject<any>}
   */
  onGetPosition() {
    return this.scrollPositionReq$;
  }
  onScrollableChange() {
    return this.scrollable$.pipe(share());
  }
  /**
   * @private
   * @param {any} event
   */
  fireScrollChange(event) {
    this.scroll$.next(event);
  }
  scrollable(scrollable) {
    this.scrollable$.next(scrollable);
  }
  static {
    this.ɵfac = function NbLayoutScrollService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbLayoutScrollService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbLayoutScrollService,
      factory: _NbLayoutScrollService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutScrollService, [{
    type: Injectable
  }], null, null);
})();
var NbLayoutRulerService = class _NbLayoutRulerService {
  constructor() {
    this.contentDimensionsReq$ = new Subject();
  }
  /**
   * Content dimensions
   * @returns {Observable<NbLayoutDimensions>}
   */
  getDimensions() {
    return new Observable((observer) => {
      const listener = new Subject();
      listener.subscribe(observer);
      this.contentDimensionsReq$.next({
        listener
      });
      return () => listener.complete();
    });
  }
  /**
   * @private
   * @returns {Subject<any>}
   */
  onGetDimensions() {
    return this.contentDimensionsReq$;
  }
  static {
    this.ɵfac = function NbLayoutRulerService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbLayoutRulerService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbLayoutRulerService,
      factory: _NbLayoutRulerService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutRulerService, [{
    type: Injectable
  }], null, null);
})();
var NbSharedModule = class _NbSharedModule {
  static {
    this.ɵfac = function NbSharedModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSharedModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbSharedModule,
      exports: [
        CommonModule,
        // TODO: probably we don't need FormsModule in SharedModule
        FormsModule,
        RouterModule
      ]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [
        CommonModule,
        // TODO: probably we don't need FormsModule in SharedModule
        FormsModule,
        RouterModule
      ]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSharedModule, [{
    type: NgModule,
    args: [{
      exports: [
        CommonModule,
        // TODO: probably we don't need FormsModule in SharedModule
        FormsModule,
        RouterModule
      ]
    }]
  }], null, null);
})();
var NbFocusTrap = class extends FocusTrap {
  constructor(element, checker, ngZone, document2, deferAnchors) {
    super(element, checker, ngZone, document2, deferAnchors);
    this.element = element;
    this.checker = checker;
    this.ngZone = ngZone;
    this.document = document2;
    this.savePreviouslyFocusedElement();
  }
  restoreFocus() {
    this.previouslyFocusedElement.focus();
    this.destroy();
  }
  blurPreviouslyFocusedElement() {
    this.previouslyFocusedElement.blur();
  }
  savePreviouslyFocusedElement() {
    this.previouslyFocusedElement = this.document.activeElement;
  }
};
var NbFocusTrapFactoryService = class _NbFocusTrapFactoryService extends FocusTrapFactory {
  constructor(checker, ngZone, document2) {
    super(checker, ngZone, document2);
    this.checker = checker;
    this.ngZone = ngZone;
    this.document = document2;
  }
  create(element, deferCaptureElements) {
    return new NbFocusTrap(element, this.checker, this.ngZone, this.document, deferCaptureElements);
  }
  static {
    this.ɵfac = function NbFocusTrapFactoryService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbFocusTrapFactoryService)(ɵɵinject(InteractivityChecker), ɵɵinject(NgZone), ɵɵinject(NB_DOCUMENT));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbFocusTrapFactoryService,
      factory: _NbFocusTrapFactoryService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFocusTrapFactoryService, [{
    type: Injectable
  }], () => [{
    type: InteractivityChecker
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbFocusKeyManager = class extends FocusKeyManager {
};
var NbFocusKeyManagerFactoryService = class {
  create(items) {
    return new NbFocusKeyManager(items);
  }
};
var NbActiveDescendantKeyManager = class extends ActiveDescendantKeyManager {
};
var NbActiveDescendantKeyManagerFactoryService = class {
  create(items) {
    return new NbActiveDescendantKeyManager(items);
  }
};
var NbKeyManagerActiveItemMode;
(function(NbKeyManagerActiveItemMode2) {
  NbKeyManagerActiveItemMode2[NbKeyManagerActiveItemMode2["RESET_ACTIVE"] = -1] = "RESET_ACTIVE";
  NbKeyManagerActiveItemMode2[NbKeyManagerActiveItemMode2["FIRST_ACTIVE"] = 0] = "FIRST_ACTIVE";
})(NbKeyManagerActiveItemMode || (NbKeyManagerActiveItemMode = {}));
var NbFocusMonitor = class _NbFocusMonitor extends FocusMonitor {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbFocusMonitor_BaseFactory;
      return function NbFocusMonitor_Factory(__ngFactoryType__) {
        return (ɵNbFocusMonitor_BaseFactory || (ɵNbFocusMonitor_BaseFactory = ɵɵgetInheritedFactory(_NbFocusMonitor)))(__ngFactoryType__ || _NbFocusMonitor);
      };
    })();
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbFocusMonitor,
      factory: _NbFocusMonitor.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFocusMonitor, [{
    type: Injectable
  }], null, null);
})();
var NbA11yModule = class _NbA11yModule {
  static forRoot() {
    return {
      ngModule: _NbA11yModule,
      providers: [NbFocusTrapFactoryService, NbFocusKeyManagerFactoryService, NbActiveDescendantKeyManagerFactoryService, {
        provide: NbFocusMonitor,
        useClass: FocusMonitor
      }]
    };
  }
  static {
    this.ɵfac = function NbA11yModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbA11yModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbA11yModule
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbA11yModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var NbPortalDirective = class _NbPortalDirective extends CdkPortal {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbPortalDirective_BaseFactory;
      return function NbPortalDirective_Factory(__ngFactoryType__) {
        return (ɵNbPortalDirective_BaseFactory || (ɵNbPortalDirective_BaseFactory = ɵɵgetInheritedFactory(_NbPortalDirective)))(__ngFactoryType__ || _NbPortalDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbPortalDirective,
      selectors: [["", "nbPortal", ""]],
      standalone: false,
      features: [ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPortalDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPortal]",
      standalone: false
    }]
  }], null, null);
})();
var NbPortalOutletDirective = class _NbPortalOutletDirective extends CdkPortalOutlet {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbPortalOutletDirective_BaseFactory;
      return function NbPortalOutletDirective_Factory(__ngFactoryType__) {
        return (ɵNbPortalOutletDirective_BaseFactory || (ɵNbPortalOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbPortalOutletDirective)))(__ngFactoryType__ || _NbPortalOutletDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbPortalOutletDirective,
      selectors: [["", "nbPortalOutlet", ""]],
      standalone: false,
      features: [ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPortalOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPortalOutlet]",
      standalone: false
    }]
  }], null, null);
})();
var NbComponentPortal = class extends ComponentPortal {
};
var NbOverlay = class _NbOverlay extends Overlay {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbOverlay_BaseFactory;
      return function NbOverlay_Factory(__ngFactoryType__) {
        return (ɵNbOverlay_BaseFactory || (ɵNbOverlay_BaseFactory = ɵɵgetInheritedFactory(_NbOverlay)))(__ngFactoryType__ || _NbOverlay);
      };
    })();
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbOverlay,
      factory: _NbOverlay.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlay, [{
    type: Injectable
  }], null, null);
})();
var NbOverlayPositionBuilder = class _NbOverlayPositionBuilder extends OverlayPositionBuilder {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbOverlayPositionBuilder_BaseFactory;
      return function NbOverlayPositionBuilder_Factory(__ngFactoryType__) {
        return (ɵNbOverlayPositionBuilder_BaseFactory || (ɵNbOverlayPositionBuilder_BaseFactory = ɵɵgetInheritedFactory(_NbOverlayPositionBuilder)))(__ngFactoryType__ || _NbOverlayPositionBuilder);
      };
    })();
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbOverlayPositionBuilder,
      factory: _NbOverlayPositionBuilder.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayPositionBuilder, [{
    type: Injectable
  }], null, null);
})();
var NbTemplatePortal = class extends TemplatePortal {
  constructor(template, viewContainerRef, context) {
    super(template, viewContainerRef, context);
  }
};
var NbOverlayContainer = class _NbOverlayContainer extends OverlayContainer {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbOverlayContainer_BaseFactory;
      return function NbOverlayContainer_Factory(__ngFactoryType__) {
        return (ɵNbOverlayContainer_BaseFactory || (ɵNbOverlayContainer_BaseFactory = ɵɵgetInheritedFactory(_NbOverlayContainer)))(__ngFactoryType__ || _NbOverlayContainer);
      };
    })();
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbOverlayContainer,
      factory: _NbOverlayContainer.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainer, [{
    type: Injectable
  }], null, null);
})();
var NbFlexibleConnectedPositionStrategy = class extends FlexibleConnectedPositionStrategy {
};
var NbPortalInjector = class extends PortalInjector {
};
var CDK_MODULES = [OverlayModule, PortalModule];
var NbCdkMappingModule = class _NbCdkMappingModule {
  static forRoot() {
    return {
      ngModule: _NbCdkMappingModule,
      providers: [NbOverlay, NbOverlayPositionBuilder]
    };
  }
  static {
    this.ɵfac = function NbCdkMappingModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCdkMappingModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbCdkMappingModule,
      declarations: [NbPortalDirective, NbPortalOutletDirective],
      imports: [OverlayModule, PortalModule],
      exports: [OverlayModule, PortalModule, NbPortalDirective, NbPortalOutletDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CDK_MODULES, OverlayModule, PortalModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCdkMappingModule, [{
    type: NgModule,
    args: [{
      imports: [...CDK_MODULES],
      exports: [...CDK_MODULES, NbPortalDirective, NbPortalOutletDirective],
      declarations: [NbPortalDirective, NbPortalOutletDirective]
    }]
  }], null, null);
})();
var NbGlobalLogicalPosition;
(function(NbGlobalLogicalPosition2) {
  NbGlobalLogicalPosition2["TOP_START"] = "top-start";
  NbGlobalLogicalPosition2["TOP_END"] = "top-end";
  NbGlobalLogicalPosition2["BOTTOM_START"] = "bottom-start";
  NbGlobalLogicalPosition2["BOTTOM_END"] = "bottom-end";
})(NbGlobalLogicalPosition || (NbGlobalLogicalPosition = {}));
var NbGlobalPhysicalPosition;
(function(NbGlobalPhysicalPosition2) {
  NbGlobalPhysicalPosition2["TOP_RIGHT"] = "top-right";
  NbGlobalPhysicalPosition2["TOP_LEFT"] = "top-left";
  NbGlobalPhysicalPosition2["BOTTOM_RIGHT"] = "bottom-right";
  NbGlobalPhysicalPosition2["BOTTOM_LEFT"] = "bottom-left";
})(NbGlobalPhysicalPosition || (NbGlobalPhysicalPosition = {}));
var NbPositionHelper = class _NbPositionHelper {
  constructor(layoutDirection) {
    this.layoutDirection = layoutDirection;
  }
  toLogicalPosition(position) {
    if (Object.values(NbGlobalLogicalPosition).includes(position)) {
      return position;
    }
    if (this.layoutDirection.isLtr()) {
      return this.toLogicalPositionWhenLtr(position);
    } else {
      return this.toLogicalPositionWhenRtl(position);
    }
  }
  toPhysicalPosition(position) {
    if (Object.values(NbGlobalPhysicalPosition).includes(position)) {
      return position;
    }
    if (this.layoutDirection.isLtr()) {
      return this.toPhysicalPositionWhenLtr(position);
    } else {
      return this.toPhysicalPositionWhenRtl(position);
    }
  }
  isTopPosition(position) {
    const logicalPosition = this.toLogicalPosition(position);
    return logicalPosition === NbGlobalLogicalPosition.TOP_END || logicalPosition === NbGlobalLogicalPosition.TOP_START;
  }
  isRightPosition(position) {
    const physicalPosition = this.toPhysicalPosition(position);
    return physicalPosition === NbGlobalPhysicalPosition.TOP_RIGHT || physicalPosition === NbGlobalPhysicalPosition.BOTTOM_RIGHT;
  }
  toLogicalPositionWhenLtr(position) {
    switch (position) {
      case NbGlobalPhysicalPosition.TOP_RIGHT:
        return NbGlobalLogicalPosition.TOP_END;
      case NbGlobalPhysicalPosition.TOP_LEFT:
        return NbGlobalLogicalPosition.TOP_START;
      case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
        return NbGlobalLogicalPosition.BOTTOM_END;
      case NbGlobalPhysicalPosition.BOTTOM_LEFT:
        return NbGlobalLogicalPosition.BOTTOM_START;
    }
  }
  toLogicalPositionWhenRtl(position) {
    switch (position) {
      case NbGlobalPhysicalPosition.TOP_RIGHT:
        return NbGlobalLogicalPosition.TOP_START;
      case NbGlobalPhysicalPosition.TOP_LEFT:
        return NbGlobalLogicalPosition.TOP_END;
      case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
        return NbGlobalLogicalPosition.BOTTOM_START;
      case NbGlobalPhysicalPosition.BOTTOM_LEFT:
        return NbGlobalLogicalPosition.BOTTOM_END;
    }
  }
  toPhysicalPositionWhenLtr(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return NbGlobalPhysicalPosition.TOP_LEFT;
      case NbGlobalLogicalPosition.TOP_END:
        return NbGlobalPhysicalPosition.TOP_RIGHT;
      case NbGlobalLogicalPosition.BOTTOM_START:
        return NbGlobalPhysicalPosition.BOTTOM_LEFT;
      case NbGlobalLogicalPosition.BOTTOM_END:
        return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
    }
  }
  toPhysicalPositionWhenRtl(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return NbGlobalPhysicalPosition.TOP_RIGHT;
      case NbGlobalLogicalPosition.TOP_END:
        return NbGlobalPhysicalPosition.TOP_LEFT;
      case NbGlobalLogicalPosition.BOTTOM_START:
        return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
      case NbGlobalLogicalPosition.BOTTOM_END:
        return NbGlobalPhysicalPosition.BOTTOM_LEFT;
    }
  }
  static {
    this.ɵfac = function NbPositionHelper_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbPositionHelper)(ɵɵinject(NbLayoutDirectionService));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbPositionHelper,
      factory: _NbPositionHelper.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionHelper, [{
    type: Injectable
  }], () => [{
    type: NbLayoutDirectionService
  }], null);
})();
var NbPlatform = class _NbPlatform extends Platform {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbPlatform_BaseFactory;
      return function NbPlatform_Factory(__ngFactoryType__) {
        return (ɵNbPlatform_BaseFactory || (ɵNbPlatform_BaseFactory = ɵɵgetInheritedFactory(_NbPlatform)))(__ngFactoryType__ || _NbPlatform);
      };
    })();
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbPlatform,
      factory: (__ngFactoryType__) => Platform.ɵfac(__ngFactoryType__),
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPlatform, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useClass: Platform
    }]
  }], null, null);
})();
var NbViewportRulerAdapter = class _NbViewportRulerAdapter extends ViewportRuler {
  constructor(platform, ngZone, ruler, scroll, document2) {
    super(platform, ngZone, document2);
    this.ruler = ruler;
    this.scroll = scroll;
  }
  getViewportSize() {
    let res;
    this.ruler.getDimensions().pipe(map((dimensions) => ({
      width: dimensions.clientWidth,
      height: dimensions.clientHeight
    }))).subscribe((rect) => res = rect);
    return res;
  }
  getViewportScrollPosition() {
    let res;
    this.scroll.getPosition().pipe(map((position) => ({
      top: position.y,
      left: position.x
    }))).subscribe((position) => res = position);
    return res;
  }
  static {
    this.ɵfac = function NbViewportRulerAdapter_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbViewportRulerAdapter)(ɵɵinject(NbPlatform), ɵɵinject(NgZone), ɵɵinject(NbLayoutRulerService), ɵɵinject(NbLayoutScrollService), ɵɵinject(NB_DOCUMENT));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbViewportRulerAdapter,
      factory: _NbViewportRulerAdapter.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbViewportRulerAdapter, [{
    type: Injectable
  }], () => [{
    type: NbPlatform
  }, {
    type: NgZone
  }, {
    type: NbLayoutRulerService
  }, {
    type: NbLayoutScrollService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
function throwLayoutNotFoundError() {
  throw new Error(`[NbOverlayContainerAdapter]: Layout not found.
  When using Nebular '<nb-layout>' is required and should wrap other nebular components.`);
}
var NbOverlayContainerAdapter = class _NbOverlayContainerAdapter extends NbOverlayContainer {
  setContainer(container) {
    this.container = container;
  }
  clearContainer() {
    this.container = null;
    this._containerElement = null;
  }
  _createContainer() {
    this.checkContainer();
    const container = this._document.createElement("div");
    container.classList.add("cdk-overlay-container");
    this.container.appendChild(container);
    this._containerElement = container;
  }
  checkContainer() {
    if (!this.container) {
      throwLayoutNotFoundError();
    }
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbOverlayContainerAdapter_BaseFactory;
      return function NbOverlayContainerAdapter_Factory(__ngFactoryType__) {
        return (ɵNbOverlayContainerAdapter_BaseFactory || (ɵNbOverlayContainerAdapter_BaseFactory = ɵɵgetInheritedFactory(_NbOverlayContainerAdapter)))(__ngFactoryType__ || _NbOverlayContainerAdapter);
      };
    })();
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbOverlayContainerAdapter,
      factory: _NbOverlayContainerAdapter.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainerAdapter, [{
    type: Injectable
  }], null, null);
})();
var NbAdjustment;
(function(NbAdjustment2) {
  NbAdjustment2["NOOP"] = "noop";
  NbAdjustment2["CLOCKWISE"] = "clockwise";
  NbAdjustment2["COUNTERCLOCKWISE"] = "counterclockwise";
  NbAdjustment2["VERTICAL"] = "vertical";
  NbAdjustment2["HORIZONTAL"] = "horizontal";
})(NbAdjustment || (NbAdjustment = {}));
var NbPosition;
(function(NbPosition2) {
  NbPosition2["TOP"] = "top";
  NbPosition2["BOTTOM"] = "bottom";
  NbPosition2["LEFT"] = "left";
  NbPosition2["RIGHT"] = "right";
  NbPosition2["START"] = "start";
  NbPosition2["END"] = "end";
  NbPosition2["TOP_END"] = "top-end";
  NbPosition2["TOP_START"] = "top-start";
  NbPosition2["BOTTOM_END"] = "bottom-end";
  NbPosition2["BOTTOM_START"] = "bottom-start";
  NbPosition2["END_TOP"] = "end-top";
  NbPosition2["END_BOTTOM"] = "end-bottom";
  NbPosition2["START_TOP"] = "start-top";
  NbPosition2["START_BOTTOM"] = "start-bottom";
})(NbPosition || (NbPosition = {}));
var POSITIONS = {
  [NbPosition.RIGHT](offset) {
    return {
      originX: "end",
      originY: "center",
      overlayX: "start",
      overlayY: "center",
      offsetX: offset
    };
  },
  [NbPosition.BOTTOM](offset) {
    return {
      originX: "center",
      originY: "bottom",
      overlayX: "center",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.LEFT](offset) {
    return {
      originX: "start",
      originY: "center",
      overlayX: "end",
      overlayY: "center",
      offsetX: -offset
    };
  },
  [NbPosition.TOP](offset) {
    return {
      originX: "center",
      originY: "top",
      overlayX: "center",
      overlayY: "bottom",
      offsetY: -offset
    };
  },
  [NbPosition.START](offset) {
    return this[NbPosition.LEFT](offset);
  },
  [NbPosition.END](offset) {
    return this[NbPosition.RIGHT](offset);
  },
  [NbPosition.END_TOP](offset) {
    return {
      originX: "end",
      originY: "bottom",
      overlayX: "start",
      overlayY: "bottom",
      offsetX: offset
    };
  },
  [NbPosition.END_BOTTOM](offset) {
    return {
      originX: "end",
      originY: "top",
      overlayX: "start",
      overlayY: "top",
      offsetX: offset
    };
  },
  [NbPosition.BOTTOM_START](offset) {
    return {
      originX: "end",
      originY: "bottom",
      overlayX: "end",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.BOTTOM_END](offset) {
    return {
      originX: "start",
      originY: "bottom",
      overlayX: "start",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.START_TOP](offset) {
    return {
      originX: "start",
      originY: "bottom",
      overlayX: "end",
      overlayY: "bottom",
      offsetX: -offset
    };
  },
  [NbPosition.START_BOTTOM](offset) {
    return {
      originX: "start",
      originY: "top",
      overlayX: "end",
      overlayY: "top",
      offsetX: -offset
    };
  },
  [NbPosition.TOP_START](offset) {
    return {
      originX: "end",
      originY: "top",
      overlayX: "end",
      overlayY: "bottom",
      offsetY: -offset
    };
  },
  [NbPosition.TOP_END](offset) {
    return {
      originX: "start",
      originY: "top",
      overlayX: "start",
      overlayY: "bottom",
      offsetY: -offset
    };
  }
};
var RTL_PHYSICAL_POSITIONS = __spreadProps(__spreadValues({}, POSITIONS), {
  [NbPosition.RIGHT](offset) {
    return {
      originX: "start",
      originY: "center",
      overlayX: "end",
      overlayY: "center",
      offsetX: offset
    };
  },
  [NbPosition.LEFT](offset) {
    return {
      originX: "end",
      originY: "center",
      overlayX: "start",
      overlayY: "center",
      offsetX: -offset
    };
  },
  [NbPosition.START](offset) {
    return this[NbPosition.RIGHT](offset);
  },
  [NbPosition.END](offset) {
    return this[NbPosition.LEFT](offset);
  }
});
var COUNTER_CLOCKWISE_POSITIONS = [NbPosition.TOP, NbPosition.TOP_END, NbPosition.TOP_START, NbPosition.START, NbPosition.START_TOP, NbPosition.START_BOTTOM, NbPosition.BOTTOM, NbPosition.BOTTOM_START, NbPosition.BOTTOM_END, NbPosition.END, NbPosition.END_BOTTOM, NbPosition.END_TOP];
var CLOCKWISE_POSITIONS = [NbPosition.TOP, NbPosition.TOP_START, NbPosition.TOP_END, NbPosition.END, NbPosition.END_TOP, NbPosition.END_BOTTOM, NbPosition.BOTTOM, NbPosition.BOTTOM_END, NbPosition.BOTTOM_START, NbPosition.START, NbPosition.START_BOTTOM, NbPosition.START_TOP];
var VERTICAL_POSITIONS = [NbPosition.BOTTOM, NbPosition.TOP];
var HORIZONTAL_POSITIONS = [NbPosition.START, NbPosition.END];
function comparePositions(p1, p2) {
  return p1.originX === p2.originX && p1.originY === p2.originY && p1.overlayX === p2.overlayX && p1.overlayY === p2.overlayY;
}
var NbAdjustableConnectedPositionStrategy = class extends NbFlexibleConnectedPositionStrategy {
  constructor() {
    super(...arguments);
    this._offset = 15;
    this.positionChange = this.positionChanges.pipe(map((positionChange) => positionChange.connectionPair), map((connectionPair) => {
      return this.appliedPositions.find(({
        connectedPosition
      }) => {
        return comparePositions(connectedPosition, connectionPair);
      }).key;
    }));
  }
  attach(overlayRef) {
    this.applyPositions();
    super.attach(overlayRef);
  }
  direction(direction) {
    this._direction = direction;
    return this;
  }
  apply() {
    this.applyPositions();
    super.apply();
  }
  position(position) {
    this._position = position;
    return this;
  }
  adjustment(adjustment) {
    this._adjustment = adjustment;
    return this;
  }
  offset(offset) {
    this._offset = offset;
    return this;
  }
  applyPositions() {
    const positions = this.createPositions();
    this.persistChosenPositions(positions);
    this.withPositions(this.appliedPositions.map(({
      connectedPosition
    }) => connectedPosition));
  }
  createPositions() {
    switch (this._adjustment) {
      case NbAdjustment.NOOP:
        return [this._position];
      case NbAdjustment.CLOCKWISE:
        return this.reorderPreferredPositions(CLOCKWISE_POSITIONS);
      case NbAdjustment.COUNTERCLOCKWISE:
        return this.reorderPreferredPositions(COUNTER_CLOCKWISE_POSITIONS);
      case NbAdjustment.HORIZONTAL:
        return this.reorderPreferredPositions(HORIZONTAL_POSITIONS);
      case NbAdjustment.VERTICAL:
        return this.reorderPreferredPositions(VERTICAL_POSITIONS);
    }
  }
  mapToLogicalPosition(position) {
    if (position === NbPosition.LEFT) {
      return this._direction === NbLayoutDirection.LTR ? NbPosition.START : NbPosition.END;
    }
    if (position === NbPosition.RIGHT) {
      return this._direction === NbLayoutDirection.LTR ? NbPosition.END : NbPosition.START;
    }
    return position;
  }
  persistChosenPositions(positions) {
    const positionGrid = this._direction === NbLayoutDirection.RTL ? RTL_PHYSICAL_POSITIONS : POSITIONS;
    this.appliedPositions = positions.map((position) => ({
      key: position,
      connectedPosition: positionGrid[position](this._offset)
    }));
  }
  reorderPreferredPositions(positions) {
    const startPosition = this.mapToLogicalPosition(this._position);
    const startPositionIndex = positions.indexOf(startPosition);
    const firstPart = positions.slice(startPositionIndex);
    const secondPart = positions.slice(0, startPositionIndex);
    return firstPart.concat(secondPart);
  }
};
var NbGlobalPositionStrategy = class extends GlobalPositionStrategy {
  position(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return this.top().left();
      case NbGlobalLogicalPosition.TOP_END:
        return this.top().right();
      case NbGlobalLogicalPosition.BOTTOM_START:
        return this.bottom().left();
      case NbGlobalLogicalPosition.BOTTOM_END:
        return this.bottom().right();
    }
  }
};
var NbPositionBuilderService = class _NbPositionBuilderService {
  constructor(document2, viewportRuler, platform, positionBuilder, overlayContainer) {
    this.document = document2;
    this.viewportRuler = viewportRuler;
    this.platform = platform;
    this.positionBuilder = positionBuilder;
    this.overlayContainer = overlayContainer;
  }
  global() {
    return new NbGlobalPositionStrategy();
  }
  connectedTo(elementRef) {
    return new NbAdjustableConnectedPositionStrategy(elementRef, this.viewportRuler, this.document, this.platform, this.overlayContainer).withFlexibleDimensions(false).withPush(false);
  }
  static {
    this.ɵfac = function NbPositionBuilderService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbPositionBuilderService)(ɵɵinject(NB_DOCUMENT), ɵɵinject(NbViewportRulerAdapter), ɵɵinject(NbPlatform), ɵɵinject(NbOverlayPositionBuilder), ɵɵinject(NbOverlayContainerAdapter));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbPositionBuilderService,
      factory: _NbPositionBuilderService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionBuilderService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NbPlatform
  }, {
    type: NbOverlayPositionBuilder
  }, {
    type: NbOverlayContainerAdapter
  }], null);
})();
var NbPositionedContainerComponent = class _NbPositionedContainerComponent {
  get top() {
    return this.position === NbPosition.TOP;
  }
  get topStart() {
    return this.position === NbPosition.TOP_START;
  }
  get topEnd() {
    return this.position === NbPosition.TOP_END;
  }
  get right() {
    return this.position === NbPosition.RIGHT || this.position === NbPosition.END;
  }
  get endTop() {
    return this.position === NbPosition.END_TOP;
  }
  get endBottom() {
    return this.position === NbPosition.END_BOTTOM;
  }
  get bottom() {
    return this.position === NbPosition.BOTTOM;
  }
  get bottomStart() {
    return this.position === NbPosition.BOTTOM_START;
  }
  get bottomEnd() {
    return this.position === NbPosition.BOTTOM_END;
  }
  get left() {
    return this.position === NbPosition.LEFT || this.position === NbPosition.START;
  }
  get startTop() {
    return this.position === NbPosition.START_TOP;
  }
  get startBottom() {
    return this.position === NbPosition.START_BOTTOM;
  }
  static {
    this.ɵfac = function NbPositionedContainerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbPositionedContainerComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbPositionedContainerComponent,
      selectors: [["ng-component"]],
      hostVars: 24,
      hostBindings: function NbPositionedContainerComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("nb-overlay-top", ctx.top)("nb-overlay-top-start", ctx.topStart)("nb-overlay-top-end", ctx.topEnd)("nb-overlay-right", ctx.right)("nb-overlay-end-top", ctx.endTop)("nb-overlay-end-bottom", ctx.endBottom)("nb-overlay-bottom", ctx.bottom)("nb-overlay-bottom-start", ctx.bottomStart)("nb-overlay-bottom-end", ctx.bottomEnd)("nb-overlay-left", ctx.left)("nb-overlay-start-top", ctx.startTop)("nb-overlay-start-bottom", ctx.startBottom);
        }
      },
      inputs: {
        position: "position"
      },
      standalone: false,
      decls: 0,
      vars: 0,
      template: function NbPositionedContainerComponent_Template(rf, ctx) {
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionedContainerComponent, [{
    type: Component,
    args: [{
      template: "",
      standalone: false
    }]
  }], null, {
    position: [{
      type: Input
    }],
    top: [{
      type: HostBinding,
      args: ["class.nb-overlay-top"]
    }],
    topStart: [{
      type: HostBinding,
      args: ["class.nb-overlay-top-start"]
    }],
    topEnd: [{
      type: HostBinding,
      args: ["class.nb-overlay-top-end"]
    }],
    right: [{
      type: HostBinding,
      args: ["class.nb-overlay-right"]
    }],
    endTop: [{
      type: HostBinding,
      args: ["class.nb-overlay-end-top"]
    }],
    endBottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-end-bottom"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom"]
    }],
    bottomStart: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom-start"]
    }],
    bottomEnd: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom-end"]
    }],
    left: [{
      type: HostBinding,
      args: ["class.nb-overlay-left"]
    }],
    startTop: [{
      type: HostBinding,
      args: ["class.nb-overlay-start-top"]
    }],
    startBottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-start-bottom"]
    }]
  });
})();
var NbOverlayContainerComponent = class _NbOverlayContainerComponent {
  constructor(vcr, injector, changeDetectorRef) {
    this.vcr = vcr;
    this.injector = injector;
    this.changeDetectorRef = changeDetectorRef;
    this.isAttached = false;
  }
  get isStringContent() {
    return !!this.content;
  }
  attachComponentPortal(portal, context) {
    portal.injector = this.createChildInjector(portal.componentFactoryResolver);
    const componentRef = this.portalOutlet.attachComponentPortal(portal);
    if (context) {
      Object.assign(componentRef.instance, context);
    }
    componentRef.changeDetectorRef.markForCheck();
    componentRef.changeDetectorRef.detectChanges();
    this.isAttached = true;
    return componentRef;
  }
  attachTemplatePortal(portal) {
    const templateRef = this.portalOutlet.attachTemplatePortal(portal);
    templateRef.detectChanges();
    this.isAttached = true;
    return templateRef;
  }
  attachStringContent(content) {
    this.content = content;
    this.changeDetectorRef.markForCheck();
    this.changeDetectorRef.detectChanges();
    this.isAttached = true;
  }
  detach() {
    if (this.portalOutlet.hasAttached()) {
      this.portalOutlet.detach();
    }
    this.attachStringContent(null);
    this.isAttached = false;
  }
  createChildInjector(cfr) {
    return new NbPortalInjector(this.injector, new WeakMap([[ComponentFactoryResolver$1, cfr]]));
  }
  static {
    this.ɵfac = function NbOverlayContainerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbOverlayContainerComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbOverlayContainerComponent,
      selectors: [["nb-overlay-container"]],
      viewQuery: function NbOverlayContainerComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbPortalOutletDirective, 7);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
        }
      },
      standalone: false,
      decls: 2,
      vars: 1,
      consts: [["class", "primitive-overlay", 4, "ngIf"], ["nbPortalOutlet", ""], [1, "primitive-overlay"]],
      template: function NbOverlayContainerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbOverlayContainerComponent_div_0_Template, 2, 1, "div", 0)(1, NbOverlayContainerComponent_ng_template_1_Template, 0, 0, "ng-template", 1);
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.isStringContent);
        }
      },
      dependencies: [NbPortalOutletDirective, NgIf],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-overlay-container",
      template: `
    <div *ngIf="isStringContent" class="primitive-overlay">{{ content }}</div>
    <ng-template nbPortalOutlet></ng-template>
  `,
      standalone: false
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: Injector
  }, {
    type: ChangeDetectorRef
  }], {
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective, {
        static: true
      }]
    }]
  });
})();
function patch(container, containerContext) {
  Object.assign(container.instance, containerContext);
  container.changeDetectorRef.detectChanges();
  return container;
}
function createContainer(ref, container, context, componentFactoryResolver) {
  const containerRef = ref.attach(new NbComponentPortal(container, null, null, componentFactoryResolver));
  patch(containerRef, context);
  return containerRef;
}
var NbOverlayService = class _NbOverlayService {
  constructor(overlay, layoutDirection) {
    this.overlay = overlay;
    this.layoutDirection = layoutDirection;
  }
  get scrollStrategies() {
    return this.overlay.scrollStrategies;
  }
  create(config) {
    const overlayRef = this.overlay.create(config);
    this.layoutDirection.onDirectionChange().subscribe((dir) => overlayRef.setDirection(dir));
    return overlayRef;
  }
  static {
    this.ɵfac = function NbOverlayService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbOverlayService)(ɵɵinject(NbOverlay), ɵɵinject(NbLayoutDirectionService));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbOverlayService,
      factory: _NbOverlayService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayService, [{
    type: Injectable
  }], () => [{
    type: NbOverlay
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var NbScrollDispatcherAdapter = class _NbScrollDispatcherAdapter extends ScrollDispatcher {
  constructor(ngZone, platform, scrollService, document2) {
    super(ngZone, platform, document2);
    this.scrollService = scrollService;
  }
  scrolled(auditTimeInMs) {
    return merge(super.scrolled(auditTimeInMs), this.scrollService.onScroll());
  }
  static {
    this.ɵfac = function NbScrollDispatcherAdapter_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbScrollDispatcherAdapter)(ɵɵinject(NgZone), ɵɵinject(NbPlatform), ɵɵinject(NbLayoutScrollService), ɵɵinject(NB_DOCUMENT));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbScrollDispatcherAdapter,
      factory: _NbScrollDispatcherAdapter.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbScrollDispatcherAdapter, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: NbPlatform
  }, {
    type: NbLayoutScrollService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbBlockScrollStrategyAdapter = class _NbBlockScrollStrategyAdapter extends BlockScrollStrategy {
  constructor(document2, viewportRuler, scrollService) {
    super(viewportRuler, document2);
    this.scrollService = scrollService;
  }
  enable() {
    super.enable();
    this.scrollService.scrollable(false);
  }
  disable() {
    super.disable();
    this.scrollService.scrollable(true);
  }
  static {
    this.ɵfac = function NbBlockScrollStrategyAdapter_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbBlockScrollStrategyAdapter)(ɵɵinject(NB_DOCUMENT), ɵɵinject(NbViewportRulerAdapter), ɵɵinject(NbLayoutScrollService));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbBlockScrollStrategyAdapter,
      factory: _NbBlockScrollStrategyAdapter.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBlockScrollStrategyAdapter, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NbLayoutScrollService
  }], null);
})();
var NbScrollStrategyOptions = class _NbScrollStrategyOptions extends ScrollStrategyOptions {
  constructor(scrollService, scrollDispatcher, viewportRuler, ngZone, document2) {
    super(scrollDispatcher, viewportRuler, ngZone, document2);
    this.scrollService = scrollService;
    this.scrollDispatcher = scrollDispatcher;
    this.viewportRuler = viewportRuler;
    this.ngZone = ngZone;
    this.document = document2;
    this.block = () => new NbBlockScrollStrategyAdapter(this.document, this.viewportRuler, this.scrollService);
  }
  static {
    this.ɵfac = function NbScrollStrategyOptions_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbScrollStrategyOptions)(ɵɵinject(NbLayoutScrollService), ɵɵinject(ScrollDispatcher), ɵɵinject(NbViewportRulerAdapter), ɵɵinject(NgZone), ɵɵinject(NB_DOCUMENT));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbScrollStrategyOptions,
      factory: _NbScrollStrategyOptions.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbScrollStrategyOptions, [{
    type: Injectable
  }], () => [{
    type: NbLayoutScrollService
  }, {
    type: ScrollDispatcher
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbCdkAdapterModule = class _NbCdkAdapterModule {
  static forRoot() {
    return {
      ngModule: _NbCdkAdapterModule,
      providers: [NbViewportRulerAdapter, NbOverlayContainerAdapter, NbBlockScrollStrategyAdapter, NbScrollDispatcherAdapter, NbScrollStrategyOptions, {
        provide: OverlayContainer,
        useExisting: NbOverlayContainerAdapter
      }, {
        provide: NbOverlayContainer,
        useExisting: NbOverlayContainerAdapter
      }, {
        provide: ScrollDispatcher,
        useExisting: NbScrollDispatcherAdapter
      }, {
        provide: ScrollStrategyOptions,
        useExisting: NbScrollStrategyOptions
      }]
    };
  }
  static {
    this.ɵfac = function NbCdkAdapterModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCdkAdapterModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbCdkAdapterModule
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCdkAdapterModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var NbTrigger;
(function(NbTrigger2) {
  NbTrigger2["NOOP"] = "noop";
  NbTrigger2["CLICK"] = "click";
  NbTrigger2["HOVER"] = "hover";
  NbTrigger2["HINT"] = "hint";
  NbTrigger2["FOCUS"] = "focus";
})(NbTrigger || (NbTrigger = {}));
var NbTriggerStrategyBase = class {
  destroy() {
    this.destroyed$.next();
  }
  isNotOnHostOrContainer(element) {
    return !this.isOnHost(element) && !this.isOnContainer(element);
  }
  isOnHostOrContainer(element) {
    return this.isOnHost(element) || this.isOnContainer(element);
  }
  isOnHost(element) {
    return this.host.contains(element);
  }
  isOnContainer(element) {
    return this.container() && this.container().location.nativeElement.contains(element);
  }
  constructor(document2, host, container) {
    this.document = document2;
    this.host = host;
    this.container = container;
    this.destroyed$ = new Subject();
  }
};
var NbClickTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.click$ = fromEvent(this.document, "click").pipe(map((event) => [!this.container() && this.isOnHost(event.target), event]), share(), takeUntil(this.destroyed$));
    this.show$ = this.click$.pipe(filter(([shouldShow]) => shouldShow), map(([, event]) => event), takeUntil(this.destroyed$));
    this.hide$ = this.click$.pipe(filter(([shouldShow, event]) => !shouldShow && !this.isOnContainer(event.target)), map(([, event]) => event), takeUntil(this.destroyed$));
  }
};
var NbHoverTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = fromEvent(this.host, "mouseenter").pipe(
      filter(() => !this.container()),
      // this `delay & takeUntil & repeat` operators combination is a synonym for `conditional debounce`
      // meaning that if one event occurs in some time after the initial one we won't react to it
      delay(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "mouseleave")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = fromEvent(this.host, "mouseleave").pipe(switchMap(() => fromEvent(this.document, "mousemove").pipe(debounceTime(100), takeWhile(() => !!this.container()), filter((event) => this.isNotOnHostOrContainer(event.target)))), takeUntil(this.destroyed$));
  }
};
var NbHintTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = fromEvent(this.host, "mouseenter").pipe(
      // this `delay & takeUntil & repeat` operators combination is a synonym for `conditional debounce`
      // meaning that if one event occurs in some time after the initial one we won't react to it
      delay(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "mouseleave")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = fromEvent(this.host, "mouseleave").pipe(takeUntil(this.destroyed$));
  }
};
var NbFocusTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.focusOut$ = fromEvent(this.host, "focusout").pipe(switchMap(() => fromEvent(this.document, "focusin").pipe(takeWhile(() => !!this.container()), filter((event) => this.isNotOnHostOrContainer(event.target)))), takeUntil(this.destroyed$));
    this.clickIn$ = fromEvent(this.host, "click").pipe(filter(() => !this.container()), takeUntil(this.destroyed$));
    this.clickOut$ = fromEvent(this.document, "click").pipe(
      filter(() => !!this.container()),
      /**
       * Event target of `click` could be different from `activeElement`.
       * If during click you return focus to the host, it won't be opened.
       */
      filter((event) => {
        if (this.isNotOnHostOrContainer(event.target)) {
          return this.isNotOnHostOrContainer(this.document.activeElement);
        }
        return false;
      }),
      takeUntil(this.destroyed$)
    );
    this.tabKeyPress$ = fromEvent(this.document, "keydown").pipe(filter((event) => event.keyCode === 9), filter(() => !!this.container()), takeUntil(this.destroyed$));
    this.show$ = merge(fromEvent(this.host, "focusin"), this.clickIn$).pipe(
      filter(() => !this.container()),
      debounceTime(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "focusout")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = merge(this.focusOut$, this.tabKeyPress$, this.clickOut$).pipe(takeUntil(this.destroyed$));
  }
};
var NbNoopTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = EMPTY;
    this.hide$ = EMPTY;
  }
};
var NbTriggerStrategyBuilderService = class _NbTriggerStrategyBuilderService {
  constructor(_document) {
    this._document = _document;
  }
  trigger(trigger2) {
    this._trigger = trigger2;
    return this;
  }
  host(host) {
    this._host = host;
    return this;
  }
  container(container) {
    this._container = container;
    return this;
  }
  build() {
    switch (this._trigger) {
      case NbTrigger.CLICK:
        return new NbClickTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.HINT:
        return new NbHintTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.HOVER:
        return new NbHoverTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.FOCUS:
        return new NbFocusTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.NOOP:
        return new NbNoopTriggerStrategy(this._document, this._host, this._container);
      default:
        throw new Error("Trigger have to be provided");
    }
  }
  static {
    this.ɵfac = function NbTriggerStrategyBuilderService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTriggerStrategyBuilderService)(ɵɵinject(NB_DOCUMENT));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbTriggerStrategyBuilderService,
      factory: _NbTriggerStrategyBuilderService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTriggerStrategyBuilderService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbOverlayModule = class _NbOverlayModule {
  static forRoot() {
    return {
      ngModule: _NbOverlayModule,
      providers: [NbPositionBuilderService, NbTriggerStrategyBuilderService, NbOverlayService, NbPositionHelper, ...NbCdkMappingModule.forRoot().providers, ...NbCdkAdapterModule.forRoot().providers, ...NbA11yModule.forRoot().providers]
    };
  }
  static {
    this.ɵfac = function NbOverlayModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbOverlayModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbOverlayModule,
      declarations: [NbPositionedContainerComponent, NbOverlayContainerComponent],
      imports: [NbCdkMappingModule, NbSharedModule],
      exports: [NbCdkMappingModule, NbCdkAdapterModule, NbOverlayContainerComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbCdkMappingModule, NbSharedModule, NbCdkMappingModule, NbCdkAdapterModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayModule, [{
    type: NgModule,
    args: [{
      imports: [NbCdkMappingModule, NbSharedModule],
      declarations: [NbPositionedContainerComponent, NbOverlayContainerComponent],
      exports: [NbCdkMappingModule, NbCdkAdapterModule, NbOverlayContainerComponent]
    }]
  }], null, null);
})();
var NbStatusService = class _NbStatusService {
  constructor() {
    this.coreStatuses = ["basic", "primary", "info", "warning", "danger", "control"];
  }
  isCoreStatus(status) {
    return this.coreStatuses.includes(status);
  }
  isCustomStatus(status) {
    if (this.isValidStatusString(status)) {
      return !this.isCoreStatus(status);
    }
    return false;
  }
  getStatusClass(status) {
    if (this.isValidStatusString(status)) {
      return `status-${status}`;
    }
    return void 0;
  }
  isValidStatusString(status) {
    return typeof status === "string" && status.length > 0;
  }
  static {
    this.ɵfac = function NbStatusService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbStatusService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbStatusService,
      factory: _NbStatusService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStatusService, [{
    type: Injectable
  }], null, null);
})();
function windowFactory(platformId) {
  if (isPlatformBrowser(platformId)) {
    return window;
  }
  return void 0;
}
var NbThemeModule = class _NbThemeModule {
  // TODO: check the options (throw exception?)
  /**
   * Main Theme Module
   *
   * @param nbThemeOptions {NbThemeOptions} Main theme options
   * @param nbJSThemes {NbJSThemeOptions[]} List of JS Themes, will be merged with default themes
   * @param nbMediaBreakpoints {NbMediaBreakpoint} Available media breakpoints
   * @param layoutDirection {NbLayoutDirection} Layout direction
   *
   * @returns {ModuleWithProviders}
   */
  static forRoot(nbThemeOptions = {
    name: "default"
  }, nbJSThemes, nbMediaBreakpoints, layoutDirection) {
    return {
      ngModule: _NbThemeModule,
      providers: [{
        provide: NB_THEME_OPTIONS,
        useValue: nbThemeOptions || {}
      }, {
        provide: NB_BUILT_IN_JS_THEMES,
        useValue: BUILT_IN_THEMES
      }, {
        provide: NB_JS_THEMES,
        useValue: nbJSThemes || []
      }, {
        provide: NB_MEDIA_BREAKPOINTS,
        useValue: nbMediaBreakpoints || DEFAULT_MEDIA_BREAKPOINTS
      }, {
        provide: NB_DOCUMENT,
        useExisting: DOCUMENT
      }, {
        provide: NB_WINDOW,
        useFactory: windowFactory,
        deps: [PLATFORM_ID]
      }, NbJSThemesRegistry, NbThemeService, NbMediaBreakpointsService, NbSpinnerService, {
        provide: NB_LAYOUT_DIRECTION,
        useValue: layoutDirection || NbLayoutDirection.LTR
      }, NbLayoutDirectionService, NbLayoutScrollService, NbLayoutRulerService, ...NbOverlayModule.forRoot().providers, NbStatusService]
    };
  }
  static {
    this.ɵfac = function NbThemeModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbThemeModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbThemeModule,
      imports: [CommonModule]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbThemeModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      exports: []
    }]
  }], null, null);
})();
var NbColorHelper = class _NbColorHelper {
  static shade(color, weight) {
    return _NbColorHelper.mix("#000000", color, weight);
  }
  static tint(color, weight) {
    return _NbColorHelper.mix("#ffffff", color, weight);
  }
  static mix(color1, color2, weight) {
    const d2h = (d) => d.toString(16);
    const h2d = (h) => parseInt(h, 16);
    let result = "#";
    for (let i = 1; i < 7; i += 2) {
      const firstPart = h2d(color1.substr(i, 2));
      const secondPart = h2d(color2.substr(i, 2));
      const resultPart = d2h(Math.floor(secondPart + (firstPart - secondPart) * (weight / 100)));
      result += ("0" + resultPart).slice(-2);
    }
    return result;
  }
  static hexToRgbA(hex, alpha) {
    let c;
    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
      c = hex.substring(1).split("");
      if (c.length === 3) {
        c = [c[0], c[0], c[1], c[1], c[2], c[2]];
      }
      c = "0x" + c.join("");
      return "rgba(" + [c >> 16 & 255, c >> 8 & 255, c & 255].join(",") + "," + alpha + ")";
    }
    throw new Error("Bad Hex");
  }
};
var NbIconPackType;
(function(NbIconPackType2) {
  NbIconPackType2["SVG"] = "svg";
  NbIconPackType2["FONT"] = "font";
})(NbIconPackType || (NbIconPackType = {}));
var NbFontIcon = class {
  constructor(name, content, params = {}) {
    this.name = name;
    this.content = content;
    this.params = params;
  }
  getClasses(options) {
    const classes = [];
    if (this.params.packClass) {
      classes.push(this.params.packClass);
    }
    const name = this.params.iconClassPrefix ? `${this.params.iconClassPrefix}-${this.name}` : this.name;
    classes.push(name);
    return classes;
  }
  getContent(options) {
    return this.content;
  }
};
var NbSvgIcon = class {
  constructor(name, content, params = {}) {
    this.name = name;
    this.content = content;
    this.params = params;
  }
  getClasses(options) {
    const classes = [];
    if (this.params.packClass) {
      classes.push(this.params.packClass);
    }
    return classes;
  }
  getContent(options) {
    return this.content;
  }
};
var NbIconDefinition = class {
};
function throwPackNotFoundError(name) {
  throw Error(`Icon Pack '${name}' is not registered`);
}
function throwNoDefaultPackError() {
  throw Error("Default pack is not registered.");
}
function throwWrongPackTypeError(name, type, desiredType) {
  throw Error(`Pack '${name}' is not an '${desiredType}' Pack and its type is '${type}'`);
}
var NbIconLibraries = class _NbIconLibraries {
  constructor() {
    this.packs = /* @__PURE__ */ new Map();
  }
  /**
   * Registers new Svg icon pack
   * @param {string} name
   * @param {NbIcon} icons
   * @param {NbIconPackParams} params
   */
  registerSvgPack(name, icons, params = {}) {
    this.packs.set(name, {
      name,
      icons: new Map(Object.entries(icons)),
      params,
      type: NbIconPackType.SVG
    });
  }
  /**
   * Registers new font pack
   * @param {string} name
   * @param {NbIconPackParams} params
   */
  registerFontPack(name, params = {}) {
    this.packs.set(name, {
      name,
      params,
      icons: /* @__PURE__ */ new Map(),
      type: NbIconPackType.FONT
    });
  }
  /**
   * Returns pack by name
   * @param {string} name
   */
  getPack(name) {
    return this.packs.get(name);
  }
  /**
   * Sets pack as a default
   * @param {string} name
   */
  setDefaultPack(name) {
    if (!this.packs.has(name)) {
      throwPackNotFoundError(name);
    }
    this.defaultPack = this.packs.get(name);
  }
  /**
   * Returns Svg icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getSvgIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type !== NbIconPackType.SVG) {
      throwWrongPackTypeError(iconsPack.name, iconsPack.type, "SVG");
    }
    const icon = this.getIconFromPack(name, iconsPack);
    if (!icon) {
      return null;
    }
    return {
      name,
      pack: iconsPack.name,
      type: NbIconPackType.SVG,
      icon: this.createSvgIcon(name, icon, iconsPack.params)
    };
  }
  /**
   * Returns Font icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getFontIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type !== NbIconPackType.FONT) {
      throwWrongPackTypeError(iconsPack.name, iconsPack.type, "Font");
    }
    const icon = this.getIconFromPack(name, iconsPack) ?? "";
    const iconContent = iconsPack.params.ligature ? name : icon;
    return {
      name,
      pack: iconsPack.name,
      type: NbIconPackType.FONT,
      icon: this.createFontIcon(name, iconContent, iconsPack.params)
    };
  }
  /**
   * Returns an icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type === NbIconPackType.SVG) {
      return this.getSvgIcon(name, pack);
    }
    return this.getFontIcon(name, pack);
  }
  createSvgIcon(name, content, params) {
    return content instanceof NbSvgIcon ? content : new NbSvgIcon(name, content, params);
  }
  createFontIcon(name, content, params) {
    return content instanceof NbFontIcon ? content : new NbFontIcon(name, content, params);
  }
  getPackOrThrow(name) {
    const pack = this.packs.get(name);
    if (!pack) {
      throwPackNotFoundError(name);
    }
    return pack;
  }
  getDefaultPackOrThrow() {
    if (!this.defaultPack) {
      throwNoDefaultPackError();
    }
    return this.defaultPack;
  }
  getIconFromPack(name, pack) {
    if (pack.icons.has(name)) {
      return pack.icons.get(name);
    }
    return null;
  }
  static {
    this.ɵfac = function NbIconLibraries_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbIconLibraries)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbIconLibraries,
      factory: _NbIconLibraries.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconLibraries, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NbIconComponent = class _NbIconComponent {
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Sets all icon configurable properties via config object.
   * If passed value is a string set icon name.
   * @docs-private
   */
  get config() {
    return this._config;
  }
  set config(value) {
    if (!value) {
      return;
    }
    this._config = value;
    if (typeof value === "string") {
      this.icon = value;
    } else {
      this.icon = value.icon;
      this.pack = value.pack;
      this.status = value.status;
      this.options = value.options;
    }
  }
  constructor(sanitizer, iconLibrary, el, renderer, statusService) {
    this.sanitizer = sanitizer;
    this.iconLibrary = iconLibrary;
    this.el = el;
    this.renderer = renderer;
    this.statusService = statusService;
    this.prevClasses = [];
    this.html = "";
  }
  ngOnInit() {
    this.iconDef = this.renderIcon(this.icon, this.pack, this.options);
  }
  ngOnChanges() {
    const iconDef = this.iconLibrary.getIcon(this.icon, this.pack);
    if (iconDef) {
      this.renderIcon(this.icon, this.pack, this.options);
    } else {
      this.clearIcon();
    }
  }
  renderIcon(name, pack, options) {
    const iconDefinition = this.iconLibrary.getIcon(name, pack);
    if (!iconDefinition) {
      return void 0;
    }
    const content = iconDefinition.icon.getContent(options);
    if (content) {
      this.html = this.sanitizer.bypassSecurityTrustHtml(content);
    }
    this.assignClasses(iconDefinition.icon.getClasses(options));
    return iconDefinition;
  }
  clearIcon() {
    this.html = "";
    this.assignClasses([]);
  }
  assignClasses(classes) {
    this.prevClasses.forEach((className) => {
      this.renderer.removeClass(this.el.nativeElement, className);
    });
    classes.forEach((className) => {
      this.renderer.addClass(this.el.nativeElement, className);
    });
    this.prevClasses = classes;
  }
  static {
    this.ɵfac = function NbIconComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbIconComponent)(ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(NbIconLibraries), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbIconComponent,
      selectors: [["nb-icon"]],
      hostVars: 17,
      hostBindings: function NbIconComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵhostProperty("innerHtml", ctx.html, ɵɵsanitizeHtml);
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
        }
      },
      inputs: {
        icon: "icon",
        pack: "pack",
        options: "options",
        status: "status",
        config: "config"
      },
      standalone: false,
      features: [ɵɵNgOnChangesFeature],
      decls: 0,
      vars: 0,
      template: function NbIconComponent_Template(rf, ctx) {
      },
      styles: ["[_nghost-%COMP%]{display:inline-block}"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconComponent, [{
    type: Component,
    args: [{
      selector: "nb-icon",
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:inline-block}\n"]
    }]
  }], () => [{
    type: DomSanitizer
  }, {
    type: NbIconLibraries
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NbStatusService
  }], {
    html: [{
      type: HostBinding,
      args: ["innerHtml"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    icon: [{
      type: Input
    }],
    pack: [{
      type: Input
    }],
    options: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    config: [{
      type: Input
    }]
  });
})();
var NbIconModule = class _NbIconModule {
  constructor(iconsLibrary) {
    this.iconsLibrary = iconsLibrary;
    this.essentialsPackName = "nebular-essentials";
    if (this.iconsLibrary.getPack(this.essentialsPackName)) {
      return;
    }
    this.iconsLibrary.registerSvgPack(this.essentialsPackName, {
      "chevron-down-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-down"><rect width="24" height="24" opacity="0"/><path d="M12 15.5a1 1 0 0 1-.71-.29l-4-4a1 1 0 1 1 1.42-1.42L12 13.1l3.3-3.18a1 1 0 1 1 1.38 1.44l-4 3.86a1 1 0 0 1-.68.28z"/></g></g></svg>',
      "chevron-up-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M16 14.5a1 1 0 0 1-.71-.29L12 10.9l-3.3 3.18a1 1 0 0 1-1.41 0 1 1 0 0 1 0-1.42l4-3.86a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1 0 1.42 1 1 0 0 1-.69.28z"/></g></g></svg>',
      "chevron-left-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.36 17a1 1 0 0 1-.72-.31l-3.86-4a1 1 0 0 1 0-1.4l4-4a1 1 0 1 1 1.42 1.42L10.9 12l3.18 3.3a1 1 0 0 1 0 1.41 1 1 0 0 1-.72.29z"/></g></g></svg>',
      "chevron-right-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M10.5 17a1 1 0 0 1-.71-.29 1 1 0 0 1 0-1.42L13.1 12 9.92 8.69a1 1 0 0 1 0-1.41 1 1 0 0 1 1.42 0l3.86 4a1 1 0 0 1 0 1.4l-4 4a1 1 0 0 1-.7.32z"/></g></g></svg>',
      "checkmark-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="checkmark"><rect width="24" height="24" opacity="0"/><path d="M9.86 18a1 1 0 0 1-.73-.32l-4.86-5.17a1 1 0 1 1 1.46-1.37l4.12 4.39 8.41-9.2a1 1 0 1 1 1.48 1.34l-9.14 10a1 1 0 0 1-.73.33z"/></g></g></svg>',
      "paper-plane-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="paper-plane"><rect width="24" height="24" opacity="0"/><path d="M21 4a1.31 1.31 0 0 0-.06-.27v-.09a1 1 0 0 0-.2-.3 1 1 0 0 0-.29-.19h-.09a.86.86 0 0 0-.31-.15H20a1 1 0 0 0-.3 0l-18 6a1 1 0 0 0 0 1.9l8.53 2.84 2.84 8.53a1 1 0 0 0 1.9 0l6-18A1 1 0 0 0 21 4zm-4.7 2.29l-5.57 5.57L5.16 10zM14 18.84l-1.86-5.57 5.57-5.57z"/></g></g></svg>',
      "file-text-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="file-text"><rect width="24" height="24" opacity="0"/><path d="M15 16H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2z"/><path d="M9 14h3a1 1 0 0 0 0-2H9a1 1 0 0 0 0 2z"/><path d="M19.74 8.33l-5.44-6a1 1 0 0 0-.74-.33h-7A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V9a1 1 0 0 0-.26-.67zM14 5l2.74 3h-2a.79.79 0 0 1-.74-.85zm3.44 15H6.56a.53.53 0 0 1-.56-.5v-15a.53.53 0 0 1 .56-.5H12v3.15A2.79 2.79 0 0 0 14.71 10H18v9.5a.53.53 0 0 1-.56.5z"/></g></g></svg>',
      "alert-triangle-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="alert-triangle"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M22.56 16.3L14.89 3.58a3.43 3.43 0 0 0-5.78 0L1.44 16.3a3 3 0 0 0-.05 3A3.37 3.37 0 0 0 4.33 21h15.34a3.37 3.37 0 0 0 2.94-1.66 3 3 0 0 0-.05-3.04zm-1.7 2.05a1.31 1.31 0 0 1-1.19.65H4.33a1.31 1.31 0 0 1-1.19-.65 1 1 0 0 1 0-1l7.68-12.73a1.48 1.48 0 0 1 2.36 0l7.67 12.72a1 1 0 0 1 .01 1.01z"/><circle cx="12" cy="16" r="1"/><path d="M12 8a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/></g></g></svg>',
      "question-mark-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="question-mark"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M17 9A5 5 0 0 0 7 9a1 1 0 0 0 2 0 3 3 0 1 1 3 3 1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-1.1A5 5 0 0 0 17 9z"/><circle cx="12" cy="19" r="1"/></g></g></svg>',
      "email-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="email"><rect width="24" height="24" opacity="0"/><path d="M19 4H5a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3zm-.67 2L12 10.75 5.67 6zM19 18H5a1 1 0 0 1-1-1V7.25l7.4 5.55a1 1 0 0 0 .6.2 1 1 0 0 0 .6-.2L20 7.25V17a1 1 0 0 1-1 1z"/></g></g></svg>',
      "flash-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="flash"><rect width="24" height="24" opacity="0"/><path d="M11.11 23a1 1 0 0 1-.34-.06 1 1 0 0 1-.65-1.05l.77-7.09H5a1 1 0 0 1-.83-1.56l7.89-11.8a1 1 0 0 1 1.17-.38 1 1 0 0 1 .65 1l-.77 7.14H19a1 1 0 0 1 .83 1.56l-7.89 11.8a1 1 0 0 1-.83.44zM6.87 12.8H12a1 1 0 0 1 .74.33 1 1 0 0 1 .25.78l-.45 4.15 4.59-6.86H12a1 1 0 0 1-1-1.11l.45-4.15z"/></g></g></svg>',
      "search-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="search"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM5 11a6 6 0 1 1 6 6 6 6 0 0 1-6-6z"/></g></g></svg>',
      "close-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="close"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M13.41 12l4.3-4.29a1 1 0 1 0-1.42-1.42L12 10.59l-4.29-4.3a1 1 0 0 0-1.42 1.42l4.3 4.29-4.3 4.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l4.29-4.3 4.29 4.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g></svg>',
      "collapse-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="collapse"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 9h-2.58l3.29-3.29a1 1 0 1 0-1.42-1.42L15 7.57V5a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2z"/><path d="M10 13H5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L9 16.42V19a1 1 0 0 0 1 1 1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z"/></g></g></svg>',
      "expand-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="expand"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20 5a1 1 0 0 0-1-1h-5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L18 7.42V10a1 1 0 0 0 1 1 1 1 0 0 0 1-1z"/><path d="M10.71 13.29a1 1 0 0 0-1.42 0L6 16.57V14a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2H7.42l3.29-3.29a1 1 0 0 0 0-1.42z"/></g></g></svg>',
      "minus-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="minus"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 13H5a1 1 0 0 1 0-2h14a1 1 0 0 1 0 2z"/></g></g></svg>',
      "minus-bold-outline": '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 2" width="100%" height="100%"><defs><rect id="nb-mbo" y="3" width="8" height="2" rx="1"/></defs><use xlink:href="#nb-mbo" transform="translate(0 -3)" fill-rule="evenodd"/></svg>',
      "checkmark-bold-outline": '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 7" width="100%" height="100%"><defs><path id="nb-cbo" d="M6.039 1.43a1.11 1.11 0 0 1 1.517-.228c.483.342.588.998.234 1.466L4.431 7.1a1 1 0 0 1-1.492.115L.317 4.677a1.023 1.023 0 0 1 .002-1.483 1.113 1.113 0 0 1 1.535.002l1.641 1.59L6.04 1.428z"/></defs><use xlink:href="#nb-cbo" transform="translate(0 -1)" fill-rule="evenodd"/></svg>',
      "arrow-back": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="arrow-back"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M19 11H7.14l3.63-4.36a1 1 0 1 0-1.54-1.28l-5 6a1.19 1.19 0 0 0-.09.15c0 .05 0 .08-.07.13A1 1 0 0 0 4 12a1 1 0 0 0 .07.36c0 .05 0 .08.07.13a1.19 1.19 0 0 0 .09.15l5 6A1 1 0 0 0 10 19a1 1 0 0 0 .64-.23 1 1 0 0 0 .13-1.41L7.14 13H19a1 1 0 0 0 0-2z"/></g></g></svg>'
    });
  }
  static {
    this.ɵfac = function NbIconModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbIconModule)(ɵɵinject(NbIconLibraries));
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbIconModule,
      declarations: [NbIconComponent],
      imports: [CommonModule],
      exports: [NbIconComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [NbIconComponent],
      exports: [NbIconComponent]
    }]
  }], () => [{
    type: NbIconLibraries
  }], null);
})();
var NbCardHeaderComponent = class _NbCardHeaderComponent {
  static {
    this.ɵfac = function NbCardHeaderComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCardHeaderComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCardHeaderComponent,
      selectors: [["nb-card-header"]],
      standalone: false,
      ngContentSelectors: _c03,
      decls: 1,
      vars: 0,
      template: function NbCardHeaderComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵprojection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-header",
      template: `<ng-content></ng-content>`,
      standalone: false
    }]
  }], null, null);
})();
var NbCardBodyComponent = class _NbCardBodyComponent {
  static {
    this.ɵfac = function NbCardBodyComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCardBodyComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCardBodyComponent,
      selectors: [["nb-card-body"]],
      standalone: false,
      ngContentSelectors: _c03,
      decls: 1,
      vars: 0,
      template: function NbCardBodyComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵprojection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardBodyComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-body",
      template: `<ng-content></ng-content>`,
      standalone: false
    }]
  }], null, null);
})();
var NbCardFooterComponent = class _NbCardFooterComponent {
  static {
    this.ɵfac = function NbCardFooterComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCardFooterComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCardFooterComponent,
      selectors: [["nb-card-footer"]],
      standalone: false,
      ngContentSelectors: _c03,
      decls: 1,
      vars: 0,
      template: function NbCardFooterComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵprojection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-footer",
      template: `<ng-content></ng-content>`,
      standalone: false
    }]
  }], null, null);
})();
var NbCardComponent = class _NbCardComponent {
  /**
   * Card size, available sizes:
   * tiny, small, medium, large, giant
   */
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get hasAccent() {
    return this.accent;
  }
  get primaryAccent() {
    return this.accent === "primary";
  }
  get infoAccent() {
    return this.accent === "info";
  }
  get successAccent() {
    return this.accent === "success";
  }
  get warningAccent() {
    return this.accent === "warning";
  }
  get dangerAccent() {
    return this.accent === "danger";
  }
  get basicAccent() {
    return this.accent === "basic";
  }
  get controlAccent() {
    return this.accent === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this._size = "";
    this.status = "";
    this.accent = "";
  }
  static {
    this.ɵfac = function NbCardComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCardComponent)(ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCardComponent,
      selectors: [["nb-card"]],
      hostVars: 42,
      hostBindings: function NbCardComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent", ctx.hasAccent)("accent-primary", ctx.primaryAccent)("accent-info", ctx.infoAccent)("accent-success", ctx.successAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent);
        }
      },
      inputs: {
        size: "size",
        status: "status",
        accent: "accent"
      },
      standalone: false,
      ngContentSelectors: _c2,
      decls: 4,
      vars: 0,
      template: function NbCardComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c13);
          ɵɵprojection(0);
          ɵɵprojection(1, 1);
          ɵɵprojection(2, 2);
          ɵɵprojection(3, 3);
        }
      },
      styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-card",
      template: `
    <ng-content select="nb-card-header"></ng-content>
    <ng-content select="nb-card-body"></ng-content>
    <ng-content></ng-content>
    <ng-content select="nb-card-footer"></ng-content>
  `,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    accent: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    hasAccent: [{
      type: HostBinding,
      args: ["class.accent"]
    }],
    primaryAccent: [{
      type: HostBinding,
      args: ["class.accent-primary"]
    }],
    infoAccent: [{
      type: HostBinding,
      args: ["class.accent-info"]
    }],
    successAccent: [{
      type: HostBinding,
      args: ["class.accent-success"]
    }],
    warningAccent: [{
      type: HostBinding,
      args: ["class.accent-warning"]
    }],
    dangerAccent: [{
      type: HostBinding,
      args: ["class.accent-danger"]
    }],
    basicAccent: [{
      type: HostBinding,
      args: ["class.accent-basic"]
    }],
    controlAccent: [{
      type: HostBinding,
      args: ["class.accent-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NbRevealCardComponent = class _NbRevealCardComponent {
  constructor() {
    this.revealed = false;
    this.showToggleButton = true;
  }
  toggle() {
    this.revealed = !this.revealed;
  }
  static {
    this.ɵfac = function NbRevealCardComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbRevealCardComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbRevealCardComponent,
      selectors: [["nb-reveal-card"]],
      hostVars: 2,
      hostBindings: function NbRevealCardComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("revealed", ctx.revealed);
        }
      },
      inputs: {
        revealed: "revealed",
        showToggleButton: "showToggleButton"
      },
      standalone: false,
      ngContentSelectors: _c4,
      decls: 4,
      vars: 1,
      consts: [[1, "second-card-container"], ["class", "reveal-button", 3, "click", 4, "ngIf"], [1, "reveal-button", 3, "click"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
      template: function NbRevealCardComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c3);
          ɵɵprojection(0);
          ɵɵelementStart(1, "div", 0);
          ɵɵprojection(2, 1);
          ɵɵelementEnd();
          ɵɵtemplate(3, NbRevealCardComponent_a_3_Template, 2, 0, "a", 1);
        }
        if (rf & 2) {
          ɵɵadvance(3);
          ɵɵproperty("ngIf", ctx.showToggleButton);
        }
      },
      dependencies: [NgIf, NbIconComponent],
      styles: ["[_nghost-%COMP%]{display:block;position:relative;overflow:hidden}[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s .5s}[_nghost-%COMP%]     nb-card-front nb-card, [_nghost-%COMP%]     nb-card-back nb-card{box-shadow:none;margin:0}[_nghost-%COMP%]     nb-card-front{display:block;height:100%}[_nghost-%COMP%]     nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top .5s}[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform .3s}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{top:0;transition:none}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]     nb-card-back{top:0}.revealed[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{transform:none}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRevealCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-reveal-card",
      template: `
    <ng-content select="nb-card-front"></ng-content>
    <div class="second-card-container">
      <ng-content select="nb-card-back"></ng-content>
    </div>
    <a *ngIf="showToggleButton" class="reveal-button" (click)="toggle()">
      <nb-icon icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </a>
  `,
      standalone: false,
      styles: [":host{display:block;position:relative;overflow:hidden}:host .second-card-container{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s .5s}:host ::ng-deep nb-card-front nb-card,:host ::ng-deep nb-card-back nb-card{box-shadow:none;margin:0}:host ::ng-deep nb-card-front{display:block;height:100%}:host ::ng-deep nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top .5s}:host .reveal-button{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform .3s}:host(.revealed) .second-card-container{top:0;transition:none}:host(.revealed) .second-card-container ::ng-deep nb-card-back{top:0}:host(.revealed) .reveal-button{transform:none}\n"]
    }]
  }], null, {
    revealed: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.revealed"]
    }],
    showToggleButton: [{
      type: Input
    }]
  });
})();
var NbFlipCardComponent = class _NbFlipCardComponent {
  constructor() {
    this.flipped = false;
    this.showToggleButton = true;
  }
  toggle() {
    this.flipped = !this.flipped;
  }
  static {
    this.ɵfac = function NbFlipCardComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbFlipCardComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbFlipCardComponent,
      selectors: [["nb-flip-card"]],
      hostVars: 2,
      hostBindings: function NbFlipCardComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("flipped", ctx.flipped);
        }
      },
      inputs: {
        flipped: "flipped",
        showToggleButton: "showToggleButton"
      },
      standalone: false,
      ngContentSelectors: _c4,
      decls: 7,
      vars: 2,
      consts: [[1, "flipcard-body"], [1, "front-container"], ["class", "flip-button", 3, "click", 4, "ngIf"], [1, "back-container"], [1, "flip-button", 3, "click"], ["icon", "chevron-left-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
      template: function NbFlipCardComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c3);
          ɵɵelementStart(0, "div", 0)(1, "div", 1);
          ɵɵprojection(2);
          ɵɵtemplate(3, NbFlipCardComponent_a_3_Template, 2, 0, "a", 2);
          ɵɵelementEnd();
          ɵɵelementStart(4, "div", 3);
          ɵɵprojection(5, 1);
          ɵɵtemplate(6, NbFlipCardComponent_a_6_Template, 2, 0, "a", 2);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance(3);
          ɵɵproperty("ngIf", ctx.showToggleButton);
          ɵɵadvance(3);
          ɵɵproperty("ngIf", ctx.showToggleButton);
        }
      },
      dependencies: [NgIf, NbIconComponent],
      styles: ["[_nghost-%COMP%]{display:block;min-width:0;perspective:1200px;position:relative}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]{transform:rotateY(-180deg)}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{opacity:0;transition:opacity 0s .25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{opacity:0;z-index:-1}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body[_ngcontent-%COMP%]{display:flex;transition:transform .5s;transform-style:preserve-3d}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{flex:1;height:fit-content;overflow:auto}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s .15s}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s .2s}.flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFlipCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-flip-card",
      template: `
    <div class="flipcard-body">
      <div class="front-container">
        <ng-content select="nb-card-front"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
      <div class="back-container">
        <ng-content select="nb-card-back"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
    </div>
  `,
      standalone: false,
      styles: [":host{display:block;min-width:0;perspective:1200px;position:relative}:host-context(.flipped) .flipcard-body{transform:rotateY(-180deg)}:host-context(.flipped) .flipcard-body .front-container{opacity:0;transition:opacity 0s .25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}:host-context(.flipped) .flipcard-body .front-container .flip-button{opacity:0;z-index:-1}:host-context(.flipped) .flipcard-body .back-container{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body{display:flex;transition:transform .5s;transform-style:preserve-3d}.flipcard-body .front-container,.flipcard-body .back-container{flex:1;height:fit-content;overflow:auto}.flipcard-body .front-container .flip-button,.flipcard-body .back-container .flip-button{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s .15s}.flipcard-body .front-container{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s .2s}.flipcard-body .back-container{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    flipped: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.flipped"]
    }],
    showToggleButton: [{
      type: Input
    }]
  });
})();
var NbCardFrontComponent = class _NbCardFrontComponent {
  static {
    this.ɵfac = function NbCardFrontComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCardFrontComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCardFrontComponent,
      selectors: [["nb-card-front"]],
      standalone: false,
      ngContentSelectors: _c6,
      decls: 1,
      vars: 0,
      template: function NbCardFrontComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c5);
          ɵɵprojection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardFrontComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-front",
      template: '<ng-content select="nb-card"></ng-content>',
      standalone: false
    }]
  }], null, null);
})();
var NbCardBackComponent = class _NbCardBackComponent {
  static {
    this.ɵfac = function NbCardBackComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCardBackComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCardBackComponent,
      selectors: [["nb-card-back"]],
      standalone: false,
      ngContentSelectors: _c6,
      decls: 1,
      vars: 0,
      template: function NbCardBackComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c5);
          ɵɵprojection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardBackComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-back",
      template: '<ng-content select="nb-card"></ng-content>',
      standalone: false
    }]
  }], null, null);
})();
var NB_CARD_COMPONENTS = [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent];
var NbCardModule = class _NbCardModule {
  static {
    this.ɵfac = function NbCardModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCardModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbCardModule,
      declarations: [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent],
      imports: [NbSharedModule, NbIconModule],
      exports: [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [...NB_CARD_COMPONENTS],
      exports: [...NB_CARD_COMPONENTS]
    }]
  }], null, null);
})();
var NbCalendarViewMode;
(function(NbCalendarViewMode2) {
  NbCalendarViewMode2["YEAR"] = "year";
  NbCalendarViewMode2["MONTH"] = "month";
  NbCalendarViewMode2["DATE"] = "date";
})(NbCalendarViewMode || (NbCalendarViewMode = {}));
var NbCalendarSize;
(function(NbCalendarSize2) {
  NbCalendarSize2["MEDIUM"] = "medium";
  NbCalendarSize2["LARGE"] = "large";
})(NbCalendarSize || (NbCalendarSize = {}));
function convertToBoolProperty(val) {
  if (typeof val === "string") {
    val = val.toLowerCase().trim();
    return val === "true" || val === "";
  }
  return !!val;
}
var NbDateService = class {
  constructor() {
    this.DAYS_IN_WEEK = 7;
    this.HOURS_IN_DAY_PERIOD = 12;
  }
  setLocale(locale) {
    this.locale = locale;
  }
  /**
   * Checks if the date is between the start date and the end date.
   * */
  isBetween(date, start, end) {
    return this.compareDates(date, start) > 0 && this.compareDates(date, end) < 0;
  }
  /**
   * Checks is two dates have the same day.
   * */
  isSameDaySafe(date1, date2) {
    return date1 && date2 && this.isSameDay(date1, date2);
  }
  /**
   * Checks is two dates have the same month.
   * */
  isSameMonthSafe(date1, date2) {
    return date1 && date2 && this.isSameMonth(date1, date2);
  }
  /**
   * Checks is two dates have the same year.
   * */
  isSameYearSafe(date1, date2) {
    return date1 && date2 && this.isSameYear(date1, date2);
  }
  isSameHourAndMinute(date1, date2) {
    return this.isSameHour(date1, date2) && this.isSameMinute(date1, date2);
  }
  isSameHour(date1, date2) {
    return this.getHours(date1) === this.getHours(date2);
  }
  isSameMinute(date1, date2) {
    return this.getMinutes(date1) === this.getMinutes(date2);
  }
  getTwentyFourHoursFormat() {
    return "HH:mm";
  }
  getTwentyFourHoursFormatWithSeconds() {
    return "HH:mm:ss";
  }
  getTwelveHoursFormatWithSeconds() {
    return "hh:mm:ss a";
  }
  getDayPeriod(date) {
    const isFirstDayPeriod = this.getHours(date) < this.HOURS_IN_DAY_PERIOD;
    if (isFirstDayPeriod) {
      return "AM";
    } else {
      return "PM";
    }
  }
};
var batch = (target, batchSize, offset = 0) => {
  return target.reduce((res, item, index) => {
    const chunkIndex = Math.floor((index + offset) / batchSize);
    if (!res[chunkIndex]) {
      res[chunkIndex] = [];
    }
    res[chunkIndex].push(item);
    return res;
  }, []);
};
var rangeFromTo = (from2, to = 0, producer = (i) => i) => {
  const arr = [];
  for (let i = from2; i < to; i++) {
    arr.push(producer(i));
  }
  return arr;
};
var range = (bound, producer = (i) => i) => {
  return rangeFromTo(0, bound, producer);
};
var NbCalendarYearModelService = class _NbCalendarYearModelService {
  constructor(dateService) {
    this.dateService = dateService;
    this.yearsInView = 12;
    this.yearsInRow = 4;
  }
  getYearsInView() {
    return this.yearsInView;
  }
  getYearsInRow() {
    return this.yearsInRow;
  }
  getViewYears(viewYear) {
    const year = this.dateService.getYear(viewYear);
    let viewStartYear;
    if (year >= 0) {
      viewStartYear = year - year % this.yearsInView;
    } else {
      viewStartYear = year - (year % this.yearsInView + this.yearsInView);
    }
    const years = range(this.yearsInView).map((i) => this.copyWithYear(viewStartYear + i, viewYear));
    return batch(years, this.yearsInRow);
  }
  copyWithYear(year, date) {
    return this.dateService.createDate(year, this.dateService.getMonth(date), this.dateService.getDate(date));
  }
  static {
    this.ɵfac = function NbCalendarYearModelService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarYearModelService)(ɵɵinject(NbDateService));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbCalendarYearModelService,
      factory: _NbCalendarYearModelService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var NbButton = class _NbButton {
  /**
   * Sets `filled` appearance
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Sets `outline` appearance
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Sets `ghost` appearance
   */
  get ghost() {
    return this.appearance === "ghost";
  }
  set ghost(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "ghost";
    }
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * Disables the button
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (this.disabled !== convertToBoolProperty(value)) {
      this._disabled = !this.disabled;
      this.renderer.setProperty(this.hostElement.nativeElement, "disabled", this.disabled);
    }
  }
  // issue #794
  get tabbable() {
    if (this.disabled) {
      return "-1";
    }
    if (this.tabIndex == null) {
      return "0";
    }
    return this.tabIndex.toString();
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(renderer, hostElement, cd, zone, statusService) {
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "filled";
    this._fullWidth = false;
    this._disabled = false;
    this.iconLeft = false;
    this.iconRight = false;
  }
  ngAfterContentChecked() {
    const firstNode = this.nodes[0];
    const lastNode = this.nodes[this.nodes.length - 1];
    this.iconLeft = this.isIconExist(firstNode);
    this.iconRight = this.isIconExist(lastNode);
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  /**
   * @docs-private
   **/
  updateProperties(config) {
    let isPropertyChanged = false;
    for (const key in config) {
      if (config.hasOwnProperty(key) && this[key] !== config[key]) {
        this[key] = config[key];
        isPropertyChanged = true;
      }
    }
    if (isPropertyChanged) {
      this.cd.markForCheck();
    }
  }
  get iconElement() {
    const el = this.hostElement.nativeElement;
    return el.querySelector("nb-icon");
  }
  get nodes() {
    return this.cd.rootNodes.filter((child) => child.nodeType !== Node.COMMENT_NODE);
  }
  isIconExist(node) {
    return this.icons.some((item) => item.nativeElement === node);
  }
  static {
    this.ɵfac = function NbButton_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbButton)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbButton,
      contentQueries: function NbButton_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbIconComponent, 4, ElementRef);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.icons = _t);
        }
      },
      hostVars: 34,
      hostBindings: function NbButton_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵattribute("aria-disabled", ctx.disabled)("tabindex", ctx.tabbable);
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("appearance-filled", ctx.filled)("appearance-outline", ctx.outline)("appearance-ghost", ctx.ghost)("full-width", ctx.fullWidth)("btn-disabled", ctx.disabled)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound)("icon-start", ctx.iconLeft)("icon-end", ctx.iconRight);
        }
      },
      inputs: {
        size: "size",
        status: "status",
        shape: "shape",
        appearance: "appearance",
        filled: "filled",
        outline: "outline",
        ghost: "ghost",
        fullWidth: "fullWidth",
        disabled: "disabled",
        tabIndex: "tabIndex"
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButton, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    ghost: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-ghost"]
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.btn-disabled"]
    }],
    tabIndex: [{
      type: Input
    }],
    tabbable: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    iconLeft: [{
      type: HostBinding,
      args: ["class.icon-start"]
    }],
    iconRight: [{
      type: HostBinding,
      args: ["class.icon-end"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    icons: [{
      type: ContentChildren,
      args: [NbIconComponent, {
        read: ElementRef
      }]
    }]
  });
})();
var NbButtonComponent = class _NbButtonComponent extends NbButton {
  /**
   * Sets `hero` appearance
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  /**
   * @private
   * Keep this handler to partially support anchor disabling.
   * Unlike button, anchor doesn't have 'disabled' DOM property,
   * so handler will be called anyway. We preventing navigation and bubbling.
   * Disabling is partial due to click handlers precedence. Consider example:
   * <a nbButton [disabled]="true" (click)="clickHandler()">...</a>
   * 'clickHandler' will be called before our host listener below. We can't prevent
   * such handlers call.
   */
  onClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
  }
  constructor(renderer, hostElement, cd, zone, statusService) {
    super(renderer, hostElement, cd, zone, statusService);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
  }
  static {
    this.ɵfac = function NbButtonComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbButtonComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbButtonComponent,
      selectors: [["button", "nbButton", ""], ["a", "nbButton", ""], ["input", "type", "button", "nbButton", ""], ["input", "type", "submit", "nbButton", ""]],
      hostVars: 16,
      hostBindings: function NbButtonComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbButtonComponent_click_HostBindingHandler($event) {
            return ctx.onClick($event);
          });
        }
        if (rf & 2) {
          ɵɵclassProp("appearance-hero", ctx.hero)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
        }
      },
      inputs: {
        hero: "hero"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbButton,
        useExisting: _NbButtonComponent
      }]), ɵɵInheritDefinitionFeature],
      attrs: _c7,
      ngContentSelectors: _c03,
      decls: 1,
      vars: 0,
      template: function NbButtonComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵprojection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonComponent, [{
    type: Component,
    args: [{
      selector: 'button[nbButton],a[nbButton],input[type="button"][nbButton],input[type="submit"][nbButton]',
      template: `
    <ng-content></ng-content>
  `,
      providers: [{
        provide: NbButton,
        useExisting: NbButtonComponent
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var NbCalendarViewModeComponent = class _NbCalendarViewModeComponent {
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.viewMode = NbCalendarViewMode.DATE;
    this.changeMode = new EventEmitter(true);
  }
  getText() {
    if (!this.date) {
      return "";
    }
    switch (this.viewMode) {
      case NbCalendarViewMode.DATE: {
        const month = this.dateService.getMonthName(this.date, TranslationWidth.Wide);
        const year = this.dateService.getYear(this.date);
        return `${month} ${year}`;
      }
      case NbCalendarViewMode.MONTH:
        return `${this.dateService.getYear(this.date)}`;
      case NbCalendarViewMode.YEAR:
        return `${this.getFirstYear()} - ${this.getLastYear()}`;
    }
  }
  getIcon() {
    if (this.viewMode === NbCalendarViewMode.DATE) {
      return "chevron-down-outline";
    }
    return "chevron-up-outline";
  }
  getFirstYear() {
    const years = this.yearModelService.getViewYears(this.date);
    return this.dateService.getYear(years[0][0]).toString();
  }
  getLastYear() {
    const years = this.yearModelService.getViewYears(this.date);
    const lastRow = years[years.length - 1];
    const lastYear = lastRow[lastRow.length - 1];
    return this.dateService.getYear(lastYear).toString();
  }
  static {
    this.ɵfac = function NbCalendarViewModeComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarViewModeComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NbCalendarYearModelService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarViewModeComponent,
      selectors: [["nb-calendar-view-mode"]],
      inputs: {
        date: "date",
        viewMode: "viewMode"
      },
      outputs: {
        changeMode: "changeMode"
      },
      standalone: false,
      decls: 3,
      vars: 2,
      consts: [["nbButton", "", "ghost", "", "status", "basic", 3, "click"], ["pack", "nebular-essentials", 3, "icon"]],
      template: function NbCalendarViewModeComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "button", 0);
          ɵɵlistener("click", function NbCalendarViewModeComponent_Template_button_click_0_listener() {
            return ctx.changeMode.emit();
          });
          ɵɵtext(1);
          ɵɵelement(2, "nb-icon", 1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵtextInterpolate1(" ", ctx.getText(), " ");
          ɵɵadvance();
          ɵɵproperty("icon", ctx.getIcon());
        }
      },
      dependencies: [NbButtonComponent, NbIconComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarViewModeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-view-mode",
      template: `
    <button nbButton (click)="changeMode.emit()" ghost status="basic">
      {{ getText() }}
      <nb-icon [icon]="getIcon()" pack="nebular-essentials"></nb-icon>
    </button>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    date: [{
      type: Input
    }],
    viewMode: [{
      type: Input
    }],
    changeMode: [{
      type: Output
    }]
  });
})();
var NbCalendarPageableNavigationComponent = class _NbCalendarPageableNavigationComponent {
  constructor(directionService) {
    this.directionService = directionService;
    this.next = new EventEmitter();
    this.prev = new EventEmitter();
  }
  get isLtr() {
    return this.directionService.isLtr();
  }
  static {
    this.ɵfac = function NbCalendarPageableNavigationComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarPageableNavigationComponent)(ɵɵdirectiveInject(NbLayoutDirectionService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarPageableNavigationComponent,
      selectors: [["nb-calendar-pageable-navigation"]],
      outputs: {
        next: "next",
        prev: "prev"
      },
      standalone: false,
      decls: 4,
      vars: 2,
      consts: [["nbButton", "", "ghost", "", "status", "basic", 1, "prev-month", 3, "click"], ["pack", "nebular-essentials", 3, "icon"], ["nbButton", "", "ghost", "", "status", "basic", 1, "next-month", 3, "click"]],
      template: function NbCalendarPageableNavigationComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "button", 0);
          ɵɵlistener("click", function NbCalendarPageableNavigationComponent_Template_button_click_0_listener() {
            return ctx.prev.emit();
          });
          ɵɵelement(1, "nb-icon", 1);
          ɵɵelementEnd();
          ɵɵelementStart(2, "button", 2);
          ɵɵlistener("click", function NbCalendarPageableNavigationComponent_Template_button_click_2_listener() {
            return ctx.next.emit();
          });
          ɵɵelement(3, "nb-icon", 1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("icon", ctx.isLtr ? "chevron-left-outline" : "chevron-right-outline");
          ɵɵadvance(2);
          ɵɵproperty("icon", ctx.isLtr ? "chevron-right-outline" : "chevron-left-outline");
        }
      },
      dependencies: [NbButtonComponent, NbIconComponent],
      styles: ["[_nghost-%COMP%]{display:flex;align-items:center;justify-content:flex-start}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPageableNavigationComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-pageable-navigation",
      template: `
    <button nbButton (click)="prev.emit()" ghost status="basic" class="prev-month">
      <nb-icon [icon]="isLtr ? 'chevron-left-outline' : 'chevron-right-outline'" pack="nebular-essentials"></nb-icon>
    </button>
    <button nbButton (click)="next.emit()" ghost status="basic" class="next-month">
      <nb-icon [icon]="isLtr ? 'chevron-right-outline' : 'chevron-left-outline'" pack="nebular-essentials"></nb-icon>
    </button>
  `,
      standalone: false,
      styles: [":host{display:flex;align-items:center;justify-content:flex-start}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbLayoutDirectionService
  }], {
    next: [{
      type: Output
    }],
    prev: [{
      type: Output
    }]
  });
})();
var NbCalendarYearCellComponent = class _NbCalendarYearCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.yearCellClass = true;
  }
  get selected() {
    return this.dateService.isSameYearSafe(this.date, this.selectedValue);
  }
  get today() {
    return this.dateService.isSameYearSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get year() {
    return this.dateService.getYear(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
  }
  yearStart() {
    return this.dateService.getYearStart(this.date);
  }
  yearEnd() {
    return this.dateService.getYearEnd(this.date);
  }
  static {
    this.ɵfac = function NbCalendarYearCellComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarYearCellComponent)(ɵɵdirectiveInject(NbDateService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarYearCellComponent,
      selectors: [["nb-calendar-year-cell"]],
      hostVars: 10,
      hostBindings: function NbCalendarYearCellComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbCalendarYearCellComponent_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
        if (rf & 2) {
          ɵɵclassProp("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("year-cell", ctx.yearCellClass);
        }
      },
      inputs: {
        date: "date",
        min: "min",
        max: "max",
        selectedValue: "selectedValue",
        size: "size"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      decls: 2,
      vars: 1,
      consts: [[1, "cell-content"]],
      template: function NbCalendarYearCellComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtext(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵtextInterpolate1(" ", ctx.year, " ");
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-year-cell",
      template: `
    <div class="cell-content">
      {{ year }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    yearCellClass: [{
      type: HostBinding,
      args: ["class.year-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var NbCalendarPickerRowComponent = class _NbCalendarPickerRowComponent {
  constructor(cfr) {
    this.cfr = cfr;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter();
  }
  ngOnChanges() {
    const factory = this.cfr.resolveComponentFactory(this.component);
    this.containerRef.clear();
    this.row.forEach((date) => {
      const component = this.containerRef.createComponent(factory, this.containerRef.length);
      this.patchWithContext(component.instance, date);
      component.changeDetectorRef.detectChanges();
    });
  }
  patchWithContext(component, date) {
    component.visibleDate = this.visibleDate;
    component.selectedValue = this.selectedValue;
    component.date = date;
    component.min = this.min;
    component.max = this.max;
    component.filter = this.filter;
    component.size = this.size;
    component.select.subscribe(this.select.emit.bind(this.select));
  }
  static {
    this.ɵfac = function NbCalendarPickerRowComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarPickerRowComponent)(ɵɵdirectiveInject(ComponentFactoryResolver$1));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarPickerRowComponent,
      selectors: [["nb-calendar-picker-row"]],
      viewQuery: function NbCalendarPickerRowComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(TemplateRef, 7, ViewContainerRef);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.containerRef = _t.first);
        }
      },
      inputs: {
        row: "row",
        selectedValue: "selectedValue",
        visibleDate: "visibleDate",
        component: "component",
        min: "min",
        max: "max",
        filter: "filter",
        size: "size"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [ɵɵNgOnChangesFeature],
      decls: 1,
      vars: 0,
      template: function NbCalendarPickerRowComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbCalendarPickerRowComponent_ng_template_0_Template, 0, 0, "ng-template");
        }
      },
      styles: ["[_nghost-%COMP%]{display:flex;justify-content:space-between}"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPickerRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-picker-row",
      template: "<ng-template></ng-template>",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;justify-content:space-between}\n"]
    }]
  }], () => [{
    type: ComponentFactoryResolver$1
  }], {
    row: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    component: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    containerRef: [{
      type: ViewChild,
      args: [TemplateRef, {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
var NbCalendarPickerComponent = class _NbCalendarPickerComponent {
  constructor() {
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  static {
    this.ɵfac = function NbCalendarPickerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarPickerComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarPickerComponent,
      selectors: [["nb-calendar-picker"]],
      hostVars: 2,
      hostBindings: function NbCalendarPickerComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("size-large", ctx.isLarge);
        }
      },
      inputs: {
        data: "data",
        visibleDate: "visibleDate",
        selectedValue: "selectedValue",
        cellComponent: "cellComponent",
        min: "min",
        max: "max",
        filter: "filter",
        size: "size"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      decls: 1,
      vars: 1,
      consts: [[3, "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "size", "select", 4, "ngFor", "ngForOf"], [3, "select", "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "size"]],
      template: function NbCalendarPickerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbCalendarPickerComponent_nb_calendar_picker_row_0_Template, 1, 8, "nb-calendar-picker-row", 0);
        }
        if (rf & 2) {
          ɵɵproperty("ngForOf", ctx.data);
        }
      },
      dependencies: [NgForOf, NbCalendarPickerRowComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-picker",
      template: `
    <nb-calendar-picker-row
      *ngFor="let row of data"
      [row]="row"
      [visibleDate]="visibleDate"
      [selectedValue]="selectedValue"
      [component]="cellComponent"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [size]="size"
      (select)="select.emit($event)">
    </nb-calendar-picker-row>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    data: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    cellComponent: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var NbCalendarYearPickerComponent = class _NbCalendarYearPickerComponent {
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.cellComponent = NbCalendarYearCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this.yearChange = new EventEmitter();
  }
  ngOnChanges() {
    this.years = this.yearModelService.getViewYears(this.year);
  }
  onSelect(year) {
    this.yearChange.emit(year);
  }
  static {
    this.ɵfac = function NbCalendarYearPickerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarYearPickerComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NbCalendarYearModelService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarYearPickerComponent,
      selectors: [["nb-calendar-year-picker"]],
      hostVars: 2,
      hostBindings: function NbCalendarYearPickerComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("size-large", ctx.large);
        }
      },
      inputs: {
        date: "date",
        min: "min",
        max: "max",
        filter: "filter",
        _cellComponent: [0, "cellComponent", "_cellComponent"],
        size: "size",
        year: "year"
      },
      outputs: {
        yearChange: "yearChange"
      },
      standalone: false,
      features: [ɵɵNgOnChangesFeature],
      decls: 1,
      vars: 8,
      consts: [[3, "select", "data", "min", "max", "filter", "selectedValue", "visibleDate", "cellComponent", "size"]],
      template: function NbCalendarYearPickerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "nb-calendar-picker", 0);
          ɵɵlistener("select", function NbCalendarYearPickerComponent_Template_nb_calendar_picker_select_0_listener($event) {
            return ctx.onSelect($event);
          });
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("data", ctx.years)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.date)("visibleDate", ctx.year)("cellComponent", ctx.cellComponent)("size", ctx.size);
        }
      },
      dependencies: [NbCalendarPickerComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-year-picker",
      template: `
    <nb-calendar-picker
      [data]="years"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="year"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    _cellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    size: [{
      type: Input
    }],
    year: [{
      type: Input
    }],
    yearChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var NbCalendarMonthCellComponent = class _NbCalendarMonthCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.monthCellClass = true;
  }
  get selected() {
    return this.dateService.isSameMonthSafe(this.date, this.selectedValue);
  }
  get today() {
    return this.dateService.isSameMonthSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get month() {
    return this.dateService.getMonthName(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.monthEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.monthStart(), this.max) > 0;
  }
  monthStart() {
    return this.dateService.getMonthStart(this.date);
  }
  monthEnd() {
    return this.dateService.getMonthEnd(this.date);
  }
  static {
    this.ɵfac = function NbCalendarMonthCellComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarMonthCellComponent)(ɵɵdirectiveInject(NbDateService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarMonthCellComponent,
      selectors: [["nb-calendar-month-cell"]],
      hostVars: 10,
      hostBindings: function NbCalendarMonthCellComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbCalendarMonthCellComponent_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
        if (rf & 2) {
          ɵɵclassProp("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("month-cell", ctx.monthCellClass);
        }
      },
      inputs: {
        date: "date",
        selectedValue: "selectedValue",
        min: "min",
        max: "max",
        size: "size"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      decls: 2,
      vars: 1,
      consts: [[1, "cell-content"]],
      template: function NbCalendarMonthCellComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtext(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵtextInterpolate1(" ", ctx.month, " ");
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-month-cell",
      template: `
    <div class="cell-content">
      {{ month }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    monthCellClass: [{
      type: HostBinding,
      args: ["class.month-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var MONTHS_IN_VIEW = 12;
var MONTHS_IN_COLUMN = 4;
var NbCalendarMonthPickerComponent = class _NbCalendarMonthPickerComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.monthChange = new EventEmitter();
    this.cellComponent = NbCalendarMonthCellComponent;
  }
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  ngOnChanges(changes) {
    if (changes.month) {
      this.initMonths();
    }
  }
  initMonths() {
    const date = this.dateService.getDate(this.month);
    const year = this.dateService.getYear(this.month);
    const firstMonth = this.dateService.createDate(year, 0, date);
    const months = [firstMonth];
    for (let monthIndex = 1; monthIndex < MONTHS_IN_VIEW; monthIndex++) {
      months.push(this.dateService.addMonth(firstMonth, monthIndex));
    }
    this.months = batch(months, MONTHS_IN_COLUMN);
  }
  onSelect(month) {
    this.monthChange.emit(month);
  }
  static {
    this.ɵfac = function NbCalendarMonthPickerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarMonthPickerComponent)(ɵɵdirectiveInject(NbDateService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarMonthPickerComponent,
      selectors: [["nb-calendar-month-picker"]],
      hostVars: 2,
      hostBindings: function NbCalendarMonthPickerComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("size-large", ctx.large);
        }
      },
      inputs: {
        min: "min",
        max: "max",
        filter: "filter",
        size: "size",
        month: "month",
        date: "date",
        _cellComponent: [0, "cellComponent", "_cellComponent"]
      },
      outputs: {
        monthChange: "monthChange"
      },
      standalone: false,
      features: [ɵɵNgOnChangesFeature],
      decls: 1,
      vars: 8,
      consts: [[3, "select", "data", "min", "max", "filter", "selectedValue", "visibleDate", "cellComponent", "size"]],
      template: function NbCalendarMonthPickerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "nb-calendar-picker", 0);
          ɵɵlistener("select", function NbCalendarMonthPickerComponent_Template_nb_calendar_picker_select_0_listener($event) {
            return ctx.onSelect($event);
          });
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("data", ctx.months)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.date)("visibleDate", ctx.month)("cellComponent", ctx.cellComponent)("size", ctx.size);
        }
      },
      dependencies: [NbCalendarPickerComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-month-picker",
      template: `
    <nb-calendar-picker
      [data]="months"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="month"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    month: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    monthChange: [{
      type: Output
    }],
    _cellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var NbCalendarDayCellComponent = class _NbCalendarDayCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.dayCellClass = true;
  }
  get today() {
    return this.dateService.isSameDaySafe(this.date, this.dateService.today());
  }
  get boundingMonth() {
    return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
  }
  get selected() {
    return this.dateService.isSameDaySafe(this.date, this.selectedValue);
  }
  get empty() {
    return !this.date;
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get day() {
    return this.date && this.dateService.getDate(this.date);
  }
  onClick() {
    if (this.disabled || this.empty) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
  }
  dontFitFilter() {
    return this.date && this.filter && !this.filter(this.date);
  }
  static {
    this.ɵfac = function NbCalendarDayCellComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarDayCellComponent)(ɵɵdirectiveInject(NbDateService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarDayCellComponent,
      selectors: [["nb-calendar-day-cell"]],
      hostVars: 14,
      hostBindings: function NbCalendarDayCellComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbCalendarDayCellComponent_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
        if (rf & 2) {
          ɵɵclassProp("today", ctx.today)("bounding-month", ctx.boundingMonth)("selected", ctx.selected)("empty", ctx.empty)("disabled", ctx.disabled)("size-large", ctx.isLarge)("day-cell", ctx.dayCellClass);
        }
      },
      inputs: {
        date: "date",
        selectedValue: "selectedValue",
        visibleDate: "visibleDate",
        min: "min",
        max: "max",
        filter: "filter",
        size: "size"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      decls: 2,
      vars: 1,
      consts: [[1, "cell-content"]],
      template: function NbCalendarDayCellComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtext(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵtextInterpolate1(" ", ctx.day, " ");
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDayCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-day-cell",
      template: `
    <div class="cell-content">
      {{ day }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    boundingMonth: [{
      type: HostBinding,
      args: ["class.bounding-month"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    empty: [{
      type: HostBinding,
      args: ["class.empty"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    dayCellClass: [{
      type: HostBinding,
      args: ["class.day-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var NbCalendarMonthModelService = class _NbCalendarMonthModelService {
  constructor(dateService) {
    this.dateService = dateService;
  }
  createDaysGrid(activeMonth, boundingMonth = true, firstDayOfWeek) {
    const weeks = this.createDates(activeMonth, firstDayOfWeek);
    return this.withBoundingMonths(weeks, activeMonth, boundingMonth);
  }
  createDates(activeMonth, firstDayOfWeek) {
    const days = this.createDateRangeForMonth(activeMonth);
    const startOfWeekDayDiff = this.getStartOfWeekDayDiff(activeMonth, firstDayOfWeek);
    return batch(days, this.dateService.DAYS_IN_WEEK, startOfWeekDayDiff);
  }
  withBoundingMonths(weeks, activeMonth, boundingMonth) {
    let withBoundingMonths = weeks;
    if (this.isShouldAddPrevBoundingMonth(withBoundingMonths)) {
      withBoundingMonths = this.addPrevBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
    }
    if (this.isShouldAddNextBoundingMonth(withBoundingMonths)) {
      withBoundingMonths = this.addNextBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
    }
    return withBoundingMonths;
  }
  addPrevBoundingMonth(weeks, activeMonth, boundingMonth) {
    const firstWeek = weeks.shift();
    const requiredItems = this.dateService.DAYS_IN_WEEK - firstWeek.length;
    firstWeek.unshift(...this.createPrevBoundingDays(activeMonth, boundingMonth, requiredItems));
    return [firstWeek, ...weeks];
  }
  addNextBoundingMonth(weeks, activeMonth, boundingMonth) {
    const lastWeek = weeks.pop();
    const requiredItems = this.dateService.DAYS_IN_WEEK - lastWeek.length;
    lastWeek.push(...this.createNextBoundingDays(activeMonth, boundingMonth, requiredItems));
    return [...weeks, lastWeek];
  }
  createPrevBoundingDays(activeMonth, boundingMonth, requiredItems) {
    const month = this.dateService.addMonth(activeMonth, -1);
    const daysInMonth = this.dateService.getNumberOfDaysInMonth(month);
    return this.createDateRangeForMonth(month).slice(daysInMonth - requiredItems).map((date) => boundingMonth ? date : null);
  }
  createNextBoundingDays(activeMonth, boundingMonth, requiredItems) {
    const month = this.dateService.addMonth(activeMonth, 1);
    return this.createDateRangeForMonth(month).slice(0, requiredItems).map((date) => boundingMonth ? date : null);
  }
  getStartOfWeekDayDiff(date, firstDayOfWeek) {
    const startOfMonth = this.dateService.getMonthStart(date);
    return this.getWeekStartDiff(startOfMonth, firstDayOfWeek);
  }
  getWeekStartDiff(date, firstDayOfWeek) {
    const weekOfset = firstDayOfWeek ?? this.dateService.getFirstDayOfWeek();
    return (7 - weekOfset + this.dateService.getDayOfWeek(date)) % 7;
  }
  isShouldAddPrevBoundingMonth(weeks) {
    return weeks[0].length < this.dateService.DAYS_IN_WEEK;
  }
  isShouldAddNextBoundingMonth(weeks) {
    return weeks[weeks.length - 1].length < this.dateService.DAYS_IN_WEEK;
  }
  createDateRangeForMonth(date) {
    const daysInMonth = this.dateService.getNumberOfDaysInMonth(date);
    return range(daysInMonth, (i) => {
      const year = this.dateService.getYear(date);
      const month = this.dateService.getMonth(date);
      return this.dateService.createDate(year, month, i + 1);
    });
  }
  static {
    this.ɵfac = function NbCalendarMonthModelService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarMonthModelService)(ɵɵinject(NbDateService));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbCalendarMonthModelService,
      factory: _NbCalendarMonthModelService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var NbCalendarDaysNamesComponent = class _NbCalendarDaysNamesComponent {
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService) {
    this.dateService = dateService;
  }
  ngOnInit() {
    const days = this.createDaysNames();
    this.days = this.shiftStartOfWeek(days);
  }
  ngOnChanges({
    firstDayOfWeek
  }) {
    if (firstDayOfWeek) {
      const days = this.createDaysNames();
      this.days = this.shiftStartOfWeek(days);
    }
  }
  createDaysNames() {
    return this.dateService.getDayOfWeekNames().map(this.markIfHoliday);
  }
  shiftStartOfWeek(days) {
    const firstDayOfWeek = this.firstDayOfWeek ?? this.dateService.getFirstDayOfWeek();
    for (let i = 0; i < firstDayOfWeek; i++) {
      days.push(days.shift());
    }
    return days;
  }
  markIfHoliday(name, i) {
    return {
      name,
      isHoliday: i % 6 === 0
    };
  }
  static {
    this.ɵfac = function NbCalendarDaysNamesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarDaysNamesComponent)(ɵɵdirectiveInject(NbDateService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarDaysNamesComponent,
      selectors: [["nb-calendar-days-names"]],
      hostVars: 2,
      hostBindings: function NbCalendarDaysNamesComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("size-large", ctx.isLarge);
        }
      },
      inputs: {
        size: "size",
        firstDayOfWeek: "firstDayOfWeek"
      },
      standalone: false,
      features: [ɵɵNgOnChangesFeature],
      decls: 1,
      vars: 1,
      consts: [["class", "day", 3, "holiday", 4, "ngFor", "ngForOf"], [1, "day"]],
      template: function NbCalendarDaysNamesComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbCalendarDaysNamesComponent_div_0_Template, 2, 3, "div", 0);
        }
        if (rf & 2) {
          ɵɵproperty("ngForOf", ctx.days);
        }
      },
      dependencies: [NgForOf],
      styles: ["[_nghost-%COMP%]{display:flex;justify-content:space-between}[_nghost-%COMP%]   .day[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDaysNamesComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-days-names",
      template: `
    <div class="day" *ngFor="let day of days" [class.holiday]="day.isHoliday">{{ day.name }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;justify-content:space-between}:host .day{display:flex;align-items:center;justify-content:center}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbDateService
  }], {
    size: [{
      type: Input
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    firstDayOfWeek: [{
      type: Input
    }]
  });
})();
var NbCalendarWeekNumberComponent = class _NbCalendarWeekNumberComponent {
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService) {
    this.dateService = dateService;
  }
  ngOnChanges(changes) {
    if (changes.weeks) {
      this.weekNumbers = this.getWeeks();
    }
  }
  getWeeks() {
    return this.weeks.map((week) => {
      const lastDay = [...week].reverse().find((day) => !!day);
      return this.dateService.getWeekNumber(lastDay);
    });
  }
  static {
    this.ɵfac = function NbCalendarWeekNumberComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarWeekNumberComponent)(ɵɵdirectiveInject(NbDateService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarWeekNumberComponent,
      selectors: [["nb-calendar-week-numbers"]],
      hostVars: 2,
      hostBindings: function NbCalendarWeekNumberComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("size-large", ctx.isLarge);
        }
      },
      inputs: {
        weeks: "weeks",
        size: "size",
        weekNumberSymbol: "weekNumberSymbol"
      },
      standalone: false,
      features: [ɵɵNgOnChangesFeature],
      decls: 4,
      vars: 2,
      consts: [[1, "sign-container"], [1, "sign"], ["class", "week-number", 4, "ngFor", "ngForOf"], [1, "week-number"]],
      template: function NbCalendarWeekNumberComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0)(1, "div", 1);
          ɵɵtext(2);
          ɵɵelementEnd()();
          ɵɵtemplate(3, NbCalendarWeekNumberComponent_div_3_Template, 2, 1, "div", 2);
        }
        if (rf & 2) {
          ɵɵadvance(2);
          ɵɵtextInterpolate(ctx.weekNumberSymbol);
          ɵɵadvance();
          ɵɵproperty("ngForOf", ctx.weekNumbers);
        }
      },
      dependencies: [NgForOf],
      styles: [_c8],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarWeekNumberComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-week-numbers",
      template: `
    <div class="sign-container">
      <div class="sign">{{ weekNumberSymbol }}</div>
    </div>
    <div class="week-number" *ngFor="let weekNumber of weekNumbers">{{ weekNumber }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbDateService
  }], {
    weeks: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var NbCalendarDayPickerComponent = class _NbCalendarDayPickerComponent {
  /**
   * Custom day cell component. Have to implement `NbCalendarCell` interface.
   * */
  set setCellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(monthModel) {
    this.monthModel = monthModel;
    this.boundingMonths = true;
    this.cellComponent = NbCalendarDayCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this._showWeekNumber = false;
    this.dateChange = new EventEmitter();
  }
  ngOnChanges({
    visibleDate,
    boundingMonths,
    firstDayOfWeek
  }) {
    if (visibleDate || boundingMonths || firstDayOfWeek) {
      this.weeks = this.monthModel.createDaysGrid(this.visibleDate, this.boundingMonths, this.firstDayOfWeek);
    }
  }
  onSelect(day) {
    this.dateChange.emit(day);
  }
  static {
    this.ɵfac = function NbCalendarDayPickerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarDayPickerComponent)(ɵɵdirectiveInject(NbCalendarMonthModelService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarDayPickerComponent,
      selectors: [["nb-calendar-day-picker"]],
      hostVars: 2,
      hostBindings: function NbCalendarDayPickerComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("size-large", ctx.large);
        }
      },
      inputs: {
        visibleDate: "visibleDate",
        boundingMonths: "boundingMonths",
        min: "min",
        max: "max",
        filter: "filter",
        setCellComponent: [0, "cellComponent", "setCellComponent"],
        size: "size",
        date: "date",
        showWeekNumber: "showWeekNumber",
        weekNumberSymbol: "weekNumberSymbol",
        firstDayOfWeek: "firstDayOfWeek"
      },
      outputs: {
        dateChange: "dateChange"
      },
      standalone: false,
      features: [ɵɵNgOnChangesFeature],
      decls: 4,
      vars: 11,
      consts: [[3, "weeks", "size", "weekNumberSymbol", 4, "ngIf"], [1, "days-container"], [3, "size", "firstDayOfWeek"], [3, "select", "data", "visibleDate", "selectedValue", "cellComponent", "min", "max", "filter", "size"], [3, "weeks", "size", "weekNumberSymbol"]],
      template: function NbCalendarDayPickerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template, 1, 3, "nb-calendar-week-numbers", 0);
          ɵɵelementStart(1, "div", 1);
          ɵɵelement(2, "nb-calendar-days-names", 2);
          ɵɵelementStart(3, "nb-calendar-picker", 3);
          ɵɵlistener("select", function NbCalendarDayPickerComponent_Template_nb_calendar_picker_select_3_listener($event) {
            return ctx.onSelect($event);
          });
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.showWeekNumber);
          ɵɵadvance(2);
          ɵɵproperty("size", ctx.size)("firstDayOfWeek", ctx.firstDayOfWeek);
          ɵɵadvance();
          ɵɵproperty("data", ctx.weeks)("visibleDate", ctx.visibleDate)("selectedValue", ctx.date)("cellComponent", ctx.cellComponent)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("size", ctx.size);
        }
      },
      dependencies: [NgIf, NbCalendarDaysNamesComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent],
      styles: ["[_nghost-%COMP%]{display:flex}.days-container[_ngcontent-%COMP%]{width:100%}"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDayPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-day-picker",
      template: `
    <nb-calendar-week-numbers *ngIf="showWeekNumber"
                              [weeks]="weeks"
                              [size]="size"
                              [weekNumberSymbol]="weekNumberSymbol">
    </nb-calendar-week-numbers>
    <div class="days-container">
      <nb-calendar-days-names [size]="size" [firstDayOfWeek]="firstDayOfWeek"></nb-calendar-days-names>
      <nb-calendar-picker
          [data]="weeks"
          [visibleDate]="visibleDate"
          [selectedValue]="date"
          [cellComponent]="cellComponent"
          [min]="min"
          [max]="max"
          [filter]="filter"
          [size]="size"
          (select)="onSelect($event)">
      </nb-calendar-picker>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex}.days-container{width:100%}\n"]
    }]
  }], () => [{
    type: NbCalendarMonthModelService
  }], {
    visibleDate: [{
      type: Input
    }],
    boundingMonths: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    setCellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    size: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var NbBaseCalendarComponent = class _NbBaseCalendarComponent {
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.boundingMonth = true;
    this.activeViewMode = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.dateChange = new EventEmitter();
    this.ViewMode = NbCalendarViewMode;
  }
  ngOnInit() {
    if (!this.visibleDate) {
      this.visibleDate = this.dateService.today();
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  setViewMode(viewMode) {
    this.activeViewMode = viewMode;
  }
  setVisibleDate(visibleDate) {
    this.visibleDate = visibleDate;
  }
  prevMonth() {
    this.changeVisibleMonth(-1);
  }
  nextMonth() {
    this.changeVisibleMonth(1);
  }
  prevYear() {
    this.changeVisibleYear(-1);
  }
  nextYear() {
    this.changeVisibleYear(1);
  }
  prevYears() {
    this.changeVisibleYears(-1);
  }
  nextYears() {
    this.changeVisibleYears(1);
  }
  navigatePrev() {
    switch (this.activeViewMode) {
      case NbCalendarViewMode.DATE:
        return this.prevMonth();
      case NbCalendarViewMode.MONTH:
        return this.prevYear();
      case NbCalendarViewMode.YEAR:
        return this.prevYears();
    }
  }
  navigateNext() {
    switch (this.activeViewMode) {
      case NbCalendarViewMode.DATE:
        return this.nextMonth();
      case NbCalendarViewMode.MONTH:
        return this.nextYear();
      case NbCalendarViewMode.YEAR:
        return this.nextYears();
    }
  }
  onChangeViewMode() {
    if (this.activeViewMode === NbCalendarViewMode.DATE) {
      return this.setViewMode(NbCalendarViewMode.YEAR);
    }
    this.setViewMode(NbCalendarViewMode.DATE);
  }
  changeVisibleMonth(direction) {
    this.visibleDate = this.dateService.addMonth(this.visibleDate, direction);
  }
  changeVisibleYear(direction) {
    this.visibleDate = this.dateService.addYear(this.visibleDate, direction);
  }
  changeVisibleYears(direction) {
    this.visibleDate = this.dateService.addYear(this.visibleDate, direction * this.yearModelService.getYearsInView());
  }
  static {
    this.ɵfac = function NbBaseCalendarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbBaseCalendarComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NbCalendarYearModelService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbBaseCalendarComponent,
      selectors: [["nb-base-calendar"]],
      hostVars: 6,
      hostBindings: function NbBaseCalendarComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("has-navigation", ctx.showNavigation)("has-week-number", ctx.showWeekNumber)("size-large", ctx.large);
        }
      },
      inputs: {
        boundingMonth: "boundingMonth",
        activeViewMode: [0, "startView", "activeViewMode"],
        min: "min",
        max: "max",
        filter: "filter",
        dayCellComponent: "dayCellComponent",
        monthCellComponent: "monthCellComponent",
        yearCellComponent: "yearCellComponent",
        size: "size",
        visibleDate: "visibleDate",
        showNavigation: "showNavigation",
        date: "date",
        showWeekNumber: "showWeekNumber",
        weekNumberSymbol: "weekNumberSymbol",
        firstDayOfWeek: "firstDayOfWeek"
      },
      outputs: {
        dateChange: "dateChange"
      },
      standalone: false,
      decls: 6,
      vars: 5,
      consts: [["class", "calendar-navigation", 4, "ngIf"], [3, "ngSwitch"], [3, "boundingMonths", "cellComponent", "min", "max", "filter", "visibleDate", "size", "date", "showWeekNumber", "firstDayOfWeek", "weekNumberSymbol", "dateChange", 4, "ngSwitchCase"], [3, "cellComponent", "date", "min", "max", "filter", "size", "year", "yearChange", 4, "ngSwitchCase"], [3, "cellComponent", "min", "max", "filter", "size", "month", "date", "monthChange", 4, "ngSwitchCase"], [1, "calendar-navigation"], [3, "changeMode", "date", "viewMode"], [3, "prev", "next"], [3, "dateChange", "boundingMonths", "cellComponent", "min", "max", "filter", "visibleDate", "size", "date", "showWeekNumber", "firstDayOfWeek", "weekNumberSymbol"], [3, "yearChange", "cellComponent", "date", "min", "max", "filter", "size", "year"], [3, "monthChange", "cellComponent", "min", "max", "filter", "size", "month", "date"]],
      template: function NbBaseCalendarComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "nb-card");
          ɵɵtemplate(1, NbBaseCalendarComponent_nb_card_header_1_Template, 3, 2, "nb-card-header", 0);
          ɵɵelementStart(2, "nb-card-body", 1);
          ɵɵtemplate(3, NbBaseCalendarComponent_nb_calendar_day_picker_3_Template, 1, 11, "nb-calendar-day-picker", 2)(4, NbBaseCalendarComponent_nb_calendar_year_picker_4_Template, 1, 7, "nb-calendar-year-picker", 3)(5, NbBaseCalendarComponent_nb_calendar_month_picker_5_Template, 1, 7, "nb-calendar-month-picker", 4);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.showNavigation);
          ɵɵadvance();
          ɵɵproperty("ngSwitch", ctx.activeViewMode);
          ɵɵadvance();
          ɵɵproperty("ngSwitchCase", ctx.ViewMode.DATE);
          ɵɵadvance();
          ɵɵproperty("ngSwitchCase", ctx.ViewMode.YEAR);
          ɵɵadvance();
          ɵɵproperty("ngSwitchCase", ctx.ViewMode.MONTH);
        }
      },
      dependencies: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NgIf, NgSwitch, NgSwitchCase, NbCardComponent, NbCardBodyComponent, NbCardHeaderComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseCalendarComponent, [{
    type: Component,
    args: [{
      selector: "nb-base-calendar",
      standalone: false,
      template: '<nb-card>\n  <nb-card-header *ngIf="showNavigation" class="calendar-navigation">\n    <nb-calendar-view-mode [date]="visibleDate"\n                           [viewMode]="activeViewMode"\n                           (changeMode)="onChangeViewMode()">\n    </nb-calendar-view-mode>\n\n    <nb-calendar-pageable-navigation (prev)="navigatePrev()" (next)="navigateNext()">\n    </nb-calendar-pageable-navigation>\n  </nb-card-header>\n\n  <nb-card-body [ngSwitch]="activeViewMode">\n\n    <nb-calendar-day-picker *ngSwitchCase="ViewMode.DATE"\n                            [boundingMonths]="boundingMonth"\n                            [cellComponent]="dayCellComponent"\n                            [min]="min"\n                            [max]="max"\n                            [filter]="filter"\n                            [visibleDate]="visibleDate"\n                            [size]="size"\n                            [date]="date"\n                            [showWeekNumber]="showWeekNumber"\n                            [firstDayOfWeek]="firstDayOfWeek"\n                            (dateChange)="dateChange.emit($any($event))"\n                            [weekNumberSymbol]="weekNumberSymbol">\n    </nb-calendar-day-picker>\n\n    <nb-calendar-year-picker *ngSwitchCase="ViewMode.YEAR"\n                             [cellComponent]="yearCellComponent"\n                             [date]="$any(date)"\n                             [min]="min"\n                             [max]="max"\n                             [filter]="filter"\n                             [size]="size"\n                             [year]="visibleDate"\n                             (yearChange)="setVisibleDate($event); setViewMode(ViewMode.MONTH)">\n    </nb-calendar-year-picker>\n\n    <nb-calendar-month-picker *ngSwitchCase="ViewMode.MONTH"\n                              [cellComponent]="monthCellComponent"\n                              [min]="min"\n                              [max]="max"\n                              [filter]="filter"\n                              [size]="size"\n                              [month]="visibleDate"\n                              [date]="$any(date)"\n                              (monthChange)="setVisibleDate($event); setViewMode(ViewMode.DATE)">\n    </nb-calendar-month-picker>\n\n  </nb-card-body>\n\n</nb-card>\n'
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    boundingMonth: [{
      type: Input
    }],
    activeViewMode: [{
      type: Input,
      args: ["startView"]
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.has-navigation"]
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.has-week-number"]
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var NbCalendarComponent = class _NbCalendarComponent {
  constructor() {
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.weekNumberSymbol = "#";
    this.dateChange = new EventEmitter();
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  static {
    this.ɵfac = function NbCalendarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarComponent,
      selectors: [["nb-calendar"]],
      inputs: {
        boundingMonth: "boundingMonth",
        startView: "startView",
        min: "min",
        max: "max",
        filter: "filter",
        dayCellComponent: "dayCellComponent",
        monthCellComponent: "monthCellComponent",
        yearCellComponent: "yearCellComponent",
        size: "size",
        visibleDate: "visibleDate",
        showNavigation: "showNavigation",
        date: "date",
        showWeekNumber: "showWeekNumber",
        weekNumberSymbol: "weekNumberSymbol",
        firstDayOfWeek: "firstDayOfWeek"
      },
      outputs: {
        dateChange: "dateChange"
      },
      standalone: false,
      decls: 1,
      vars: 15,
      consts: [[3, "dateChange", "boundingMonth", "startView", "date", "min", "max", "filter", "dayCellComponent", "monthCellComponent", "yearCellComponent", "size", "visibleDate", "showNavigation", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek"]],
      template: function NbCalendarComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "nb-base-calendar", 0);
          ɵɵlistener("dateChange", function NbCalendarComponent_Template_nb_base_calendar_dateChange_0_listener($event) {
            return ctx.dateChange.emit($event);
          });
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("boundingMonth", ctx.boundingMonth)("startView", ctx.startView)("date", ctx.date)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("size", ctx.size)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
        }
      },
      dependencies: [NbBaseCalendarComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar",
      template: `
    <nb-base-calendar
      [boundingMonth]="boundingMonth"
      [startView]="startView"
      [date]="date"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [size]="size"
      [visibleDate]="visibleDate"
      [showNavigation]="showNavigation"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
      [firstDayOfWeek]="firstDayOfWeek"
      (dateChange)="dateChange.emit($event)"
    ></nb-base-calendar>
  `,
      standalone: false
    }]
  }], null, {
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }]
  });
})();
var NB_BUTTON_COMPONENTS = [NbButtonComponent];
var NbButtonModule = class _NbButtonModule {
  static {
    this.ɵfac = function NbButtonModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbButtonModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbButtonModule,
      declarations: [NbButtonComponent],
      imports: [NbSharedModule],
      exports: [NbButtonComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_BUTTON_COMPONENTS],
      exports: [...NB_BUTTON_COMPONENTS]
    }]
  }], null, null);
})();
var NbNativeDateService = class _NbNativeDateService extends NbDateService {
  constructor(locale) {
    super();
    this.setLocale(locale);
  }
  setLocale(locale) {
    super.setLocale(locale);
    this.datePipe = new DatePipe(locale);
  }
  setHours(date, hour) {
    const result = this.clone(date);
    result.setHours(hour);
    return result;
  }
  setMinutes(date, minute) {
    const result = this.clone(date);
    result.setMinutes(minute);
    return result;
  }
  setSeconds(date, second) {
    const result = this.clone(date);
    result.setSeconds(second);
    return result;
  }
  setMilliseconds(date, second) {
    const result = this.clone(date);
    result.setMilliseconds(second);
    return result;
  }
  isValidDateString(date, format) {
    return !isNaN(this.parse(date, format).getTime());
  }
  isValidTimeString(date, format) {
    return this.isValidDateString(date, format);
  }
  today() {
    return /* @__PURE__ */ new Date();
  }
  getLocaleTimeFormat() {
    return getLocaleTimeFormat(this.locale, FormatWidth.Short);
  }
  getDate(date) {
    return date.getDate();
  }
  getMonth(date) {
    return date.getMonth();
  }
  getYear(date) {
    return date.getFullYear();
  }
  getDayOfWeek(date) {
    return date.getDay();
  }
  /**
   * returns first day of the week, it can be 1 if week starts from monday
   * and 0 if from sunday and so on.
   * */
  getFirstDayOfWeek() {
    return getLocaleFirstDayOfWeek(this.locale);
  }
  getMonthName(date, style2 = TranslationWidth.Abbreviated) {
    const index = date.getMonth();
    return this.getMonthNameByIndex(index, style2);
  }
  getMonthNameByIndex(index, style2 = TranslationWidth.Abbreviated) {
    return getLocaleMonthNames(this.locale, FormStyle.Format, style2)[index];
  }
  getDayOfWeekNames() {
    return [...getLocaleDayNames(this.locale, FormStyle.Format, TranslationWidth.Short)];
  }
  format(date, format) {
    return this.datePipe.transform(date, format);
  }
  /**
   * We haven't got capability to parse date using formatting without third party libraries.
   * */
  parse(date, format) {
    return new Date(Date.parse(date));
  }
  addDay(date, num) {
    return this.createDate(date.getFullYear(), date.getMonth(), date.getDate() + num);
  }
  addMonth(date, num) {
    const month = this.createDate(date.getFullYear(), date.getMonth() + num, 1);
    month.setDate(Math.min(date.getDate(), this.getMonthEnd(month).getDate()));
    return month;
  }
  addMinutes(date, minute) {
    const result = new Date(date);
    result.setMinutes(date.getMinutes() + minute);
    return result;
  }
  addHours(date, hour) {
    const result = new Date(date);
    result.setHours(date.getHours() + hour);
    return result;
  }
  getHours(date) {
    return date.getHours();
  }
  getMinutes(date) {
    return date.getMinutes();
  }
  getSeconds(date) {
    return date.getSeconds();
  }
  getMilliseconds(date) {
    return date.getMilliseconds();
  }
  addYear(date, num) {
    return this.createDate(date.getFullYear() + num, date.getMonth(), date.getDate());
  }
  clone(date) {
    return new Date(date.getTime());
  }
  compareDates(date1, date2) {
    return date1.getTime() - date2.getTime();
  }
  createDate(year, month, date) {
    const result = new Date(year, month, date);
    if (year >= 0 && year < 100) {
      result.setFullYear(result.getFullYear() - 1900);
    }
    return result;
  }
  getMonthEnd(date) {
    return this.createDate(date.getFullYear(), date.getMonth() + 1, 0);
  }
  getMonthStart(date) {
    return this.createDate(date.getFullYear(), date.getMonth(), 1);
  }
  getNumberOfDaysInMonth(date) {
    return this.getMonthEnd(date).getDate();
  }
  getYearEnd(date) {
    return this.createDate(date.getFullYear(), 11, 31);
  }
  getYearStart(date) {
    return this.createDate(date.getFullYear(), 0, 1);
  }
  valueOf(date) {
    return date.valueOf();
  }
  isSameDay(date1, date2) {
    return this.isSameMonth(date1, date2) && date1.getDate() === date2.getDate();
  }
  isSameMonth(date1, date2) {
    return this.isSameYear(date1, date2) && date1.getMonth() === date2.getMonth();
  }
  isSameYear(date1, date2) {
    return date1.getFullYear() === date2.getFullYear();
  }
  getId() {
    return "native";
  }
  getWeekNumber(date) {
    return parseInt(this.datePipe.transform(date, "w"), 10);
  }
  getDateFormat() {
    return "yyyy-MM-dd";
  }
  getTwelveHoursFormat() {
    return "hh:mm a";
  }
  static {
    this.ɵfac = function NbNativeDateService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbNativeDateService)(ɵɵinject(LOCALE_ID));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbNativeDateService,
      factory: _NbNativeDateService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbNativeDateService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var NbCalendarTimeModelService = class _NbCalendarTimeModelService {
  constructor(dateService) {
    this.dateService = dateService;
    this.MINUTES_AND_SECONDS = 60;
  }
  getHoursRange(step = this.MINUTES_AND_SECONDS) {
    let date = this.getResetTime();
    const endDate = this.dateService.addDay(date, 1);
    const result = [];
    while (this.dateService.compareDates(date, endDate) < 0) {
      result.push(date);
      date = this.dateService.addMinutes(date, step);
    }
    return result;
  }
  getResetTime() {
    let today = this.dateService.today();
    today = this.dateService.setHours(today, 0);
    today = this.dateService.setMinutes(today, 0);
    today = this.dateService.setSeconds(today, 0);
    today = this.dateService.setMilliseconds(today, 0);
    return today;
  }
  paddToTwoSymbols(n) {
    if (n < 10) {
      return "0" + n;
    }
    return n.toString();
  }
  buildDateFormat(twelveHoursFormat, withSeconds = false) {
    if (twelveHoursFormat) {
      return `${this.dateService.getDateFormat()} ${this.dateService.getTwelveHoursFormat()}`;
    }
    if (withSeconds) {
      return `${this.dateService.getDateFormat()} ${this.dateService.getTwentyFourHoursFormatWithSeconds()}`;
    }
    return `${this.dateService.getDateFormat()} ${this.dateService.getTwentyFourHoursFormat()}`;
  }
  static {
    this.ɵfac = function NbCalendarTimeModelService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarTimeModelService)(ɵɵinject(NbDateService));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbCalendarTimeModelService,
      factory: _NbCalendarTimeModelService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarTimeModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var NbCalendarActionsComponent = class _NbCalendarActionsComponent {
  constructor() {
    this._applyButtonText = "ok";
    this._currentTimeButtonText = "now";
    this.setCurrentTime = new EventEmitter();
    this.saveValue = new EventEmitter();
  }
  set applyButtonText(value) {
    if (value) {
      this._applyButtonText = value;
    }
  }
  get applyText() {
    return this._applyButtonText;
  }
  set currentTimeButtonText(value) {
    if (value) {
      this._currentTimeButtonText = value;
    }
  }
  get currentTimeText() {
    return this._currentTimeButtonText;
  }
  static {
    this.ɵfac = function NbCalendarActionsComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarActionsComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarActionsComponent,
      selectors: [["nb-calendar-actions"]],
      inputs: {
        applyButtonText: "applyButtonText",
        currentTimeButtonText: "currentTimeButtonText",
        showCurrentTimeButton: "showCurrentTimeButton"
      },
      outputs: {
        setCurrentTime: "setCurrentTime",
        saveValue: "saveValue"
      },
      standalone: false,
      decls: 3,
      vars: 2,
      consts: [["nbButton", "", "ghost", "", "status", "primary", "size", "small", 3, "click", 4, "ngIf"], ["nbButton", "", "status", "primary", "size", "small", 1, "apply-text-button", 3, "click"], ["nbButton", "", "ghost", "", "status", "primary", "size", "small", 3, "click"]],
      template: function NbCalendarActionsComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbCalendarActionsComponent_button_0_Template, 2, 1, "button", 0);
          ɵɵelementStart(1, "button", 1);
          ɵɵlistener("click", function NbCalendarActionsComponent_Template_button_click_1_listener() {
            return ctx.saveValue.emit();
          });
          ɵɵtext(2);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.showCurrentTimeButton);
          ɵɵadvance(2);
          ɵɵtextInterpolate1(" ", ctx.applyText, "");
        }
      },
      dependencies: [NgIf, NbButtonComponent],
      styles: ["[_nghost-%COMP%]{display:flex;justify-content:space-between}[dir=ltr]   [_nghost-%COMP%]   .apply-text-button[_ngcontent-%COMP%]{margin-left:auto}[dir=rtl]   [_nghost-%COMP%]   .apply-text-button[_ngcontent-%COMP%]{margin-right:auto}\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarActionsComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-actions",
      template: `
    <button
      *ngIf="showCurrentTimeButton"
      nbButton
      ghost
      status="primary"
      size="small"
      (click)="setCurrentTime.emit()">
      {{ currentTimeText }}</button>
    <button
      class="apply-text-button"
      nbButton
      status="primary"
      size="small"
      (click)="saveValue.emit()">
      {{ applyText }}</button>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;justify-content:space-between}[dir=ltr] :host .apply-text-button{margin-left:auto}[dir=rtl] :host .apply-text-button{margin-right:auto}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    setCurrentTime: [{
      type: Output
    }],
    saveValue: [{
      type: Output
    }]
  });
})();
var SERVICES = [{
  provide: NbDateService,
  useClass: NbNativeDateService
}, DatePipe, NbCalendarMonthModelService, NbCalendarYearModelService, NbCalendarTimeModelService];
var COMPONENTS$3 = [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent];
var NbCalendarKitModule = class _NbCalendarKitModule {
  static {
    this.ɵfac = function NbCalendarKitModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarKitModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbCalendarKitModule,
      declarations: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent],
      imports: [NbSharedModule, NbButtonModule, NbIconModule],
      exports: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [...SERVICES],
      imports: [NbSharedModule, NbButtonModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarKitModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbButtonModule, NbIconModule],
      exports: [...COMPONENTS$3],
      declarations: [...COMPONENTS$3],
      providers: [...SERVICES]
    }]
  }], null, null);
})();
var NbBaseCalendarModule = class _NbBaseCalendarModule {
  static {
    this.ɵfac = function NbBaseCalendarModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbBaseCalendarModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbBaseCalendarModule,
      declarations: [NbBaseCalendarComponent],
      imports: [NbCalendarKitModule, NbSharedModule, NbCardModule],
      exports: [NbBaseCalendarComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbCalendarKitModule, NbSharedModule, NbCardModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseCalendarModule, [{
    type: NgModule,
    args: [{
      imports: [NbCalendarKitModule, NbSharedModule, NbCardModule],
      exports: [NbBaseCalendarComponent],
      declarations: [NbBaseCalendarComponent]
    }]
  }], null, null);
})();
var NbCalendarModule = class _NbCalendarModule {
  static {
    this.ɵfac = function NbCalendarModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbCalendarModule,
      declarations: [NbCalendarComponent],
      imports: [NbBaseCalendarModule],
      exports: [NbCalendarComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbBaseCalendarModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarModule, [{
    type: NgModule,
    args: [{
      imports: [NbBaseCalendarModule],
      exports: [NbCalendarComponent],
      declarations: [NbCalendarComponent]
    }]
  }], null, null);
})();
var NbBaseCalendarRangeCell = class {
  get hasRange() {
    return !!(this.selectedValue && this.selectedValue.start && this.selectedValue.end);
  }
};
var NbCalendarRangeDayCellComponent = class _NbCalendarRangeDayCellComponent extends NbBaseCalendarRangeCell {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.rangeCellClass = true;
    this.dayCellClass = true;
  }
  get inRange() {
    if (this.date && this.hasRange) {
      return this.isInRange(this.date, this.selectedValue);
    }
    return false;
  }
  get start() {
    return this.date && this.hasRange && this.dateService.isSameDay(this.date, this.selectedValue.start);
  }
  get end() {
    return this.date && this.hasRange && this.dateService.isSameDay(this.date, this.selectedValue.end);
  }
  get today() {
    return this.date && this.dateService.isSameDay(this.date, this.dateService.today());
  }
  get boundingMonth() {
    return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameDaySafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get empty() {
    return !this.date;
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get day() {
    return this.date && this.dateService.getDate(this.date);
  }
  onClick() {
    if (this.disabled || this.empty) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
  }
  dontFitFilter() {
    return this.date && this.filter && !this.filter(this.date);
  }
  isInRange(date, {
    start,
    end
  }) {
    const isGreaterThanStart = this.dateService.compareDates(this.date, start) >= 0;
    const isLessThanEnd = this.dateService.compareDates(this.date, end) <= 0;
    return isGreaterThanStart && isLessThanEnd;
  }
  static {
    this.ɵfac = function NbCalendarRangeDayCellComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarRangeDayCellComponent)(ɵɵdirectiveInject(NbDateService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarRangeDayCellComponent,
      selectors: [["nb-calendar-range-day-cell"]],
      hostVars: 22,
      hostBindings: function NbCalendarRangeDayCellComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbCalendarRangeDayCellComponent_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
        if (rf & 2) {
          ɵɵclassProp("in-range", ctx.inRange)("start", ctx.start)("end", ctx.end)("range-cell", ctx.rangeCellClass)("day-cell", ctx.dayCellClass)("today", ctx.today)("bounding-month", ctx.boundingMonth)("selected", ctx.selected)("empty", ctx.empty)("disabled", ctx.disabled)("size-large", ctx.isLarge);
        }
      },
      inputs: {
        date: "date",
        selectedValue: "selectedValue",
        visibleDate: "visibleDate",
        min: "min",
        max: "max",
        filter: "filter",
        size: "size"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [ɵɵInheritDefinitionFeature],
      decls: 2,
      vars: 1,
      consts: [[1, "cell-content"]],
      template: function NbCalendarRangeDayCellComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtext(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵtextInterpolate(ctx.day);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeDayCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-day-cell",
      template: `
    <div class="cell-content">{{ day }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    start: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    end: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    dayCellClass: [{
      type: HostBinding,
      args: ["class.day-cell"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    boundingMonth: [{
      type: HostBinding,
      args: ["class.bounding-month"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    empty: [{
      type: HostBinding,
      args: ["class.empty"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var NbCalendarRangeYearCellComponent = class _NbCalendarRangeYearCellComponent extends NbBaseCalendarRangeCell {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.yearCellClass = true;
    this.rangeCellClass = true;
  }
  get inRange() {
    return this.hasRange && this.isInRange(this.date, this.selectedValue);
  }
  get rangeStart() {
    return this.hasRange && this.dateService.isSameYear(this.date, this.selectedValue.start);
  }
  get rangeEnd() {
    return this.hasRange && this.dateService.isSameYear(this.date, this.selectedValue.end);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameYearSafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get today() {
    return this.dateService.isSameYear(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get year() {
    return this.dateService.getYear(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
  }
  yearStart() {
    return this.dateService.getYearStart(this.date);
  }
  yearEnd() {
    return this.dateService.getYearEnd(this.date);
  }
  isInRange(date, {
    start,
    end
  }) {
    if (start && end) {
      const cellYear = this.dateService.getYear(date);
      const startYear = this.dateService.getYear(start);
      const endYear = this.dateService.getYear(end);
      return cellYear >= startYear && cellYear <= endYear;
    }
    return this.dateService.isSameYear(date, start);
  }
  static {
    this.ɵfac = function NbCalendarRangeYearCellComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarRangeYearCellComponent)(ɵɵdirectiveInject(NbDateService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarRangeYearCellComponent,
      selectors: [["nb-calendar-range-year-cell"]],
      hostVars: 18,
      hostBindings: function NbCalendarRangeYearCellComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbCalendarRangeYearCellComponent_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
        if (rf & 2) {
          ɵɵclassProp("in-range", ctx.inRange)("start", ctx.rangeStart)("end", ctx.rangeEnd)("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("year-cell", ctx.yearCellClass)("range-cell", ctx.rangeCellClass);
        }
      },
      inputs: {
        date: "date",
        min: "min",
        max: "max",
        selectedValue: "selectedValue",
        size: "size"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [ɵɵInheritDefinitionFeature],
      decls: 2,
      vars: 1,
      consts: [[1, "cell-content"]],
      template: function NbCalendarRangeYearCellComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtext(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵtextInterpolate1(" ", ctx.year, " ");
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeYearCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-year-cell",
      template: `
    <div class="cell-content">
      {{ year }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    rangeStart: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    rangeEnd: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    yearCellClass: [{
      type: HostBinding,
      args: ["class.year-cell"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var NbCalendarRangeMonthCellComponent = class _NbCalendarRangeMonthCellComponent extends NbBaseCalendarRangeCell {
  get month() {
    return this.dateService.getMonthName(this.date);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameMonthSafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get inRange() {
    if (this.hasRange) {
      return this.isInRage(this.date, this.selectedValue);
    }
    return false;
  }
  get rangeStart() {
    if (this.hasRange) {
      return this.dateService.isSameMonth(this.date, this.selectedValue.start);
    }
    return false;
  }
  get rangeEnd() {
    if (this.hasRange) {
      return this.dateService.isSameMonth(this.date, this.selectedValue.end);
    }
    return false;
  }
  get today() {
    return this.dateService.isSameMonthSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.monthCellClass = true;
    this.rangeCellClass = true;
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.monthEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.monthStart(), this.max) > 0;
  }
  monthStart() {
    return this.dateService.getMonthStart(this.date);
  }
  monthEnd() {
    return this.dateService.getMonthEnd(this.date);
  }
  isInRage(date, range2) {
    if (range2.start && range2.end) {
      const cellDate = this.dateService.getMonthStart(date);
      const start = this.dateService.getMonthStart(range2.start);
      const end = this.dateService.getMonthStart(range2.end);
      const isGreaterThanStart = this.dateService.compareDates(cellDate, start) >= 0;
      const isLessThanEnd = this.dateService.compareDates(cellDate, end) <= 0;
      return isGreaterThanStart && isLessThanEnd;
    }
    return this.dateService.isSameMonth(date, range2.start);
  }
  static {
    this.ɵfac = function NbCalendarRangeMonthCellComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarRangeMonthCellComponent)(ɵɵdirectiveInject(NbDateService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarRangeMonthCellComponent,
      selectors: [["nb-calendar-range-month-cell"]],
      hostVars: 18,
      hostBindings: function NbCalendarRangeMonthCellComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbCalendarRangeMonthCellComponent_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
        if (rf & 2) {
          ɵɵclassProp("month-cell", ctx.monthCellClass)("range-cell", ctx.rangeCellClass)("selected", ctx.selected)("in-range", ctx.inRange)("start", ctx.rangeStart)("end", ctx.rangeEnd)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge);
        }
      },
      inputs: {
        date: "date",
        visibleDate: "visibleDate",
        selectedValue: "selectedValue",
        min: "min",
        max: "max",
        size: "size"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      features: [ɵɵInheritDefinitionFeature],
      decls: 2,
      vars: 1,
      consts: [[1, "cell-content"]],
      template: function NbCalendarRangeMonthCellComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtext(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵtextInterpolate1(" ", ctx.month, " ");
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeMonthCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-month-cell",
      template: `
    <div class="cell-content">
      {{ month }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    monthCellClass: [{
      type: HostBinding,
      args: ["class.month-cell"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    rangeStart: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    rangeEnd: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var NbCalendarRangeComponent = class _NbCalendarRangeComponent {
  /**
   * Custom day cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.dayCellComponent = cellComponent;
    }
  }
  /**
   * Custom month cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _monthCellComponent(cellComponent) {
    if (cellComponent) {
      this.monthCellComponent = cellComponent;
    }
  }
  /**
   * Custom year cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _yearCellComponent(cellComponent) {
    if (cellComponent) {
      this.yearCellComponent = cellComponent;
    }
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(dateService) {
    this.dateService = dateService;
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.dayCellComponent = NbCalendarRangeDayCellComponent;
    this.monthCellComponent = NbCalendarRangeMonthCellComponent;
    this.yearCellComponent = NbCalendarRangeYearCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.weekNumberSymbol = "#";
    this.rangeChange = new EventEmitter();
  }
  onChange(date) {
    this.initDateIfNull();
    this.handleSelected(date);
  }
  initDateIfNull() {
    if (!this.range) {
      this.range = {
        start: null,
        end: null
      };
    }
  }
  handleSelected(date) {
    if (this.selectionStarted()) {
      this.selectEnd(date);
    } else {
      this.selectStart(date);
    }
  }
  selectionStarted() {
    const {
      start,
      end
    } = this.range;
    return start && !end;
  }
  selectStart(start) {
    this.selectRange({
      start
    });
  }
  selectEnd(date) {
    const {
      start
    } = this.range;
    if (this.dateService.compareDates(date, start) > 0) {
      this.selectRange({
        start,
        end: date
      });
    } else {
      this.selectRange({
        start: date,
        end: start
      });
    }
  }
  selectRange(range2) {
    this.range = range2;
    this.rangeChange.emit(range2);
  }
  static {
    this.ɵfac = function NbCalendarRangeComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarRangeComponent)(ɵɵdirectiveInject(NbDateService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarRangeComponent,
      selectors: [["nb-calendar-range"]],
      inputs: {
        boundingMonth: "boundingMonth",
        startView: "startView",
        min: "min",
        max: "max",
        filter: "filter",
        _cellComponent: [0, "dayCellComponent", "_cellComponent"],
        _monthCellComponent: [0, "monthCellComponent", "_monthCellComponent"],
        monthCellComponent: "monthCellComponent",
        _yearCellComponent: [0, "yearCellComponent", "_yearCellComponent"],
        size: "size",
        visibleDate: "visibleDate",
        showNavigation: "showNavigation",
        range: "range",
        showWeekNumber: "showWeekNumber",
        weekNumberSymbol: "weekNumberSymbol",
        firstDayOfWeek: "firstDayOfWeek"
      },
      outputs: {
        rangeChange: "rangeChange"
      },
      standalone: false,
      decls: 1,
      vars: 15,
      consts: [[3, "dateChange", "date", "min", "max", "filter", "startView", "boundingMonth", "dayCellComponent", "monthCellComponent", "yearCellComponent", "visibleDate", "showNavigation", "size", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek"]],
      template: function NbCalendarRangeComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "nb-base-calendar", 0);
          ɵɵlistener("dateChange", function NbCalendarRangeComponent_Template_nb_base_calendar_dateChange_0_listener($event) {
            return ctx.onChange($event);
          });
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("date", ctx.range)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("startView", ctx.startView)("boundingMonth", ctx.boundingMonth)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("size", ctx.size)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
        }
      },
      dependencies: [NbBaseCalendarComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range",
      template: `
    <nb-base-calendar
      [date]="range"
      (dateChange)="onChange($any($event))"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [startView]="startView"
      [boundingMonth]="boundingMonth"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [visibleDate]="visibleDate"
      [showNavigation]="showNavigation"
      [size]="size"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
      [firstDayOfWeek]="firstDayOfWeek"
    ></nb-base-calendar>
  `,
      standalone: false
    }]
  }], () => [{
    type: NbDateService
  }], {
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    _cellComponent: [{
      type: Input,
      args: ["dayCellComponent"]
    }],
    _monthCellComponent: [{
      type: Input,
      args: ["monthCellComponent"]
    }],
    monthCellComponent: [{
      type: Input
    }],
    _yearCellComponent: [{
      type: Input,
      args: ["yearCellComponent"]
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    range: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    rangeChange: [{
      type: Output
    }]
  });
})();
var NbCalendarRangeModule = class _NbCalendarRangeModule {
  static {
    this.ɵfac = function NbCalendarRangeModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarRangeModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbCalendarRangeModule,
      declarations: [NbCalendarRangeComponent, NbCalendarRangeDayCellComponent, NbCalendarRangeYearCellComponent, NbCalendarRangeMonthCellComponent],
      imports: [NbBaseCalendarModule],
      exports: [NbCalendarRangeComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbBaseCalendarModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeModule, [{
    type: NgModule,
    args: [{
      imports: [NbBaseCalendarModule],
      exports: [NbCalendarRangeComponent],
      declarations: [NbCalendarRangeComponent, NbCalendarRangeDayCellComponent, NbCalendarRangeYearCellComponent, NbCalendarRangeMonthCellComponent]
    }]
  }], null, null);
})();
var NB_TIME_PICKER_CONFIG = new InjectionToken("NB_TIME_PICKER_CONFIG");
var NB_DEFAULT_TIMEPICKER_LOCALIZATION_CONFIG = {
  hoursText: "Hr",
  minutesText: "Min",
  secondsText: "Sec",
  ampmText: "Am/Pm"
};
var NbListComponent = class _NbListComponent {
  constructor() {
    this.role = "list";
  }
  static {
    this.ɵfac = function NbListComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbListComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbListComponent,
      selectors: [["nb-list"]],
      hostVars: 1,
      hostBindings: function NbListComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵattribute("role", ctx.role);
        }
      },
      inputs: {
        role: "role"
      },
      standalone: false,
      ngContentSelectors: _c10,
      decls: 1,
      vars: 0,
      template: function NbListComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c9);
          ɵɵprojection(0);
        }
      },
      styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListComponent, [{
    type: Component,
    args: [{
      selector: "nb-list",
      template: `<ng-content select="nb-list-item"></ng-content>`,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}\n"]
    }]
  }], null, {
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var NbListItemComponent = class _NbListItemComponent {
  constructor() {
    this.role = "listitem";
  }
  static {
    this.ɵfac = function NbListItemComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbListItemComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbListItemComponent,
      selectors: [["nb-list-item"]],
      hostVars: 1,
      hostBindings: function NbListItemComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵattribute("role", ctx.role);
        }
      },
      inputs: {
        role: "role"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 1,
      vars: 0,
      template: function NbListItemComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵprojection(0);
        }
      },
      styles: ["[_nghost-%COMP%]{display:flex;align-items:center;flex-shrink:0}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListItemComponent, [{
    type: Component,
    args: [{
      selector: "nb-list-item",
      template: `<ng-content></ng-content>`,
      standalone: false,
      styles: [":host{display:flex;align-items:center;flex-shrink:0}\n"]
    }]
  }], null, {
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var NbTimePickerCellComponent = class _NbTimePickerCellComponent {
  set selected(selected) {
    if (selected) {
      this._selected = selected;
      this.scrollToElement();
    }
    this.selectedChange$.next(selected);
  }
  get selected() {
    return this._selected;
  }
  constructor(ngZone, platformService) {
    this.ngZone = ngZone;
    this.platformService = platformService;
    this.selectedChange$ = new Subject();
    this.unselected$ = this.selectedChange$.pipe(filter((selected) => !selected));
    this.destroy$ = new Subject();
    this.select = new EventEmitter();
  }
  onClick() {
    this.select.emit({
      value: this.value
    });
  }
  ngAfterViewInit() {
    if (this.selected) {
      this.ngZone.onStable.pipe(take(1), takeUntil(merge(this.unselected$, this.destroy$))).subscribe(() => this.scrollToElement());
    }
  }
  scrollToElement() {
    if (this.valueContainerElement && this.platformService.isBrowser) {
      this.ngZone.runOutsideAngular(() => this.valueContainerElement.nativeElement.scrollIntoView({
        block: "center"
      }));
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  static {
    this.ɵfac = function NbTimePickerCellComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTimePickerCellComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbPlatform));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTimePickerCellComponent,
      selectors: [["nb-timepicker-cell"]],
      viewQuery: function NbTimePickerCellComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c11, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.valueContainerElement = _t.first);
        }
      },
      hostBindings: function NbTimePickerCellComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbTimePickerCellComponent_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
      },
      inputs: {
        selected: "selected",
        value: "value"
      },
      outputs: {
        select: "select"
      },
      standalone: false,
      decls: 3,
      vars: 1,
      consts: [["valueContainer", ""]],
      template: function NbTimePickerCellComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", null, 0);
          ɵɵtext(2);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance(2);
          ɵɵtextInterpolate(ctx.value);
        }
      },
      styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:flex;align-items:center;justify-content:center;-webkit-user-select:none;user-select:none}\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-timepicker-cell",
      template: `
    <div #valueContainer>{{ value }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{width:100%;height:100%;display:flex;align-items:center;justify-content:center;-webkit-user-select:none;user-select:none}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NgZone
  }, {
    type: NbPlatform
  }], {
    selected: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    valueContainerElement: [{
      type: ViewChild,
      args: ["valueContainer"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var NbTimePickerComponent = class _NbTimePickerComponent {
  /**
   * Emits when timepicker looses focus.
   */
  get blur() {
    return this.blur$.asObservable();
  }
  /**
   * Defines time format string.
   * */
  get timeFormat() {
    return this._timeFormat;
  }
  set timeFormat(timeFormat) {
    this._timeFormat = timeFormat;
  }
  /**
   * Defines 12 hours format .
   * */
  get twelveHoursFormat() {
    return this._twelveHoursFormat;
  }
  set twelveHoursFormat(value) {
    this._twelveHoursFormat = convertToBoolProperty(value);
  }
  /**
   * Defines should show am/pm label if twelveHoursFormat enabled.
   * */
  get showAmPmLabel() {
    return this._showAmPmLabel;
  }
  set showAmPmLabel(value) {
    this._showAmPmLabel = convertToBoolProperty(value);
  }
  /**
   * Show seconds in timepicker.
   * Ignored when singleColumn is true
   * */
  get withSeconds() {
    return this._withSeconds;
  }
  set withSeconds(value) {
    this._withSeconds = convertToBoolProperty(value);
  }
  /**
   * Show timepicker values in one column with 60 minutes step by default.
   * */
  get singleColumn() {
    return this._singleColumn;
  }
  set singleColumn(value) {
    this._singleColumn = convertToBoolProperty(value);
  }
  /**
   * Defines minutes offset for options, when timepicker is in single column mode.
   * By default it’s 60 minutes: '12:00, 13:00: 14:00, 15:00...'
   * */
  set step(step) {
    this._step = step;
  }
  get step() {
    return this._step;
  }
  /**
   * Date which will be rendered as selected.
   * */
  set date(date) {
    this._date = date;
    this.isAM = this.dateService.getDayPeriod(this.date) === "AM";
    this.buildColumnOptions();
    this.cd.markForCheck();
  }
  get date() {
    return this._date;
  }
  constructor(config, platformService, locale, cd, calendarTimeModelService, dateService) {
    this.config = config;
    this.platformService = platformService;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
    this.dateService = dateService;
    this.blur$ = new Subject();
    this.dayPeriodColumnOptions = [
      "AM",
      "PM"
      /* NbDayPeriod.PM */
    ];
    this.isAM = true;
    this.timepickerFormatChange$ = new Subject();
    this.computedTimeFormat = this.setupTimeFormat();
    this._showAmPmLabel = true;
    this.showFooter = true;
    this.onSelectTime = new EventEmitter();
    this.initFromConfig(this.config);
  }
  ngOnChanges({
    step,
    twelveHoursFormat,
    withSeconds,
    singleColumn
  }) {
    const nextTimeFormat = this.setupTimeFormat();
    if (nextTimeFormat !== this.computedTimeFormat) {
      this.computedTimeFormat = nextTimeFormat;
      this.timepickerFormatChange$.next();
    }
    const isConfigChanged = step || twelveHoursFormat || withSeconds || singleColumn;
    if (isConfigChanged || !this.fullTimeOptions) {
      this.buildColumnOptions();
    }
  }
  setHost(hostRef) {
    this.hostRef = hostRef;
  }
  attach(hostRef) {
    this.hostRef = hostRef;
  }
  setCurrentTime() {
    this.date = this.dateService.today();
    this.onSelectTime.emit({
      time: this.date,
      save: true
    });
  }
  setHour(value) {
    this.updateValue(this.dateService.setHours(this.date, value));
  }
  setMinute(value) {
    this.updateValue(this.dateService.setMinutes(this.date, value));
  }
  setSecond(value) {
    this.updateValue(this.dateService.setSeconds(this.date, value));
  }
  selectFullTime(value) {
    this.updateValue(value);
  }
  changeDayPeriod(dayPeriodToSet) {
    if (this.dateService.getDayPeriod(this.date) === dayPeriodToSet) {
      return;
    }
    const direction = dayPeriodToSet === "AM" ? -1 : 1;
    const increment = direction * this.dateService.HOURS_IN_DAY_PERIOD;
    this.updateValue(this.dateService.addHours(this.date, increment));
  }
  updateValue(date) {
    this.onSelectTime.emit({
      time: date
    });
  }
  saveValue() {
    this.onSelectTime.emit({
      time: this.date,
      save: true
    });
  }
  trackByTimeValues(index, item) {
    return item.value;
  }
  trackBySingleColumnValue(index, item) {
    return this.dateService.valueOf(item);
  }
  trackByDayPeriod(index, item) {
    return item;
  }
  showSeconds() {
    return this.withSeconds && !this.singleColumn;
  }
  isSelectedHour(val) {
    if (this.date) {
      return this.dateService.getHours(this.date) === val;
    }
    return false;
  }
  isSelectedMinute(val) {
    if (this.date) {
      return this.dateService.getMinutes(this.date) === val;
    }
    return false;
  }
  isSelectedSecond(val) {
    if (this.date) {
      return this.dateService.getSeconds(this.date) === val;
    }
    return false;
  }
  isSelectedDayPeriod(dayPeriod) {
    if (this.date) {
      return dayPeriod === this.dateService.getDayPeriod(this.date);
    }
    return false;
  }
  getFullTimeString(item) {
    return this.dateService.format(item, this.computedTimeFormat).toUpperCase();
  }
  isSelectedFullTimeValue(value) {
    if (this.date) {
      return this.dateService.isSameHourAndMinute(value, this.date);
    }
    return false;
  }
  buildColumnOptions() {
    this.fullTimeOptions = this.singleColumn ? this.calendarTimeModelService.getHoursRange(this.step) : [];
    this.hoursColumnOptions = this.generateHours();
    this.minutesColumnOptions = this.generateMinutesOrSeconds();
    this.secondsColumnOptions = this.showSeconds() ? this.generateMinutesOrSeconds() : [];
  }
  /**
   * @docs-private
   */
  isFirefox() {
    return this.platformService.FIREFOX;
  }
  generateHours() {
    if (!this.twelveHoursFormat) {
      return range(24, (v) => {
        return {
          value: v,
          text: this.calendarTimeModelService.paddToTwoSymbols(v)
        };
      });
    }
    if (this.isAM) {
      return range(12, (v) => {
        const text = v === 0 ? 12 : v;
        return {
          value: v,
          text: this.calendarTimeModelService.paddToTwoSymbols(text)
        };
      });
    }
    return rangeFromTo(12, 24, (v) => {
      const text = v === 12 ? 12 : v - 12;
      return {
        value: v,
        text: this.calendarTimeModelService.paddToTwoSymbols(text)
      };
    });
  }
  generateMinutesOrSeconds() {
    return range(60, (v) => {
      return {
        value: v,
        text: this.calendarTimeModelService.paddToTwoSymbols(v)
      };
    });
  }
  setupTimeFormat() {
    if (!this.timeFormat) {
      return this.config.format || this.buildTimeFormat();
    }
    return this.timeFormat;
  }
  /**
   * @docs-private
   */
  buildTimeFormat() {
    if (this.twelveHoursFormat) {
      return `${this.withSeconds && !this.singleColumn ? this.dateService.getTwelveHoursFormatWithSeconds() : this.dateService.getTwelveHoursFormat()}`;
    } else {
      return `${this.withSeconds && !this.singleColumn ? this.dateService.getTwentyFourHoursFormatWithSeconds() : this.dateService.getTwentyFourHoursFormat()}`;
    }
  }
  initFromConfig(config) {
    if (config) {
      this.twelveHoursFormat = config.twelveHoursFormat;
    } else {
      this.twelveHoursFormat = this.dateService.getLocaleTimeFormat().includes("h");
    }
    const localeConfig = __spreadValues(__spreadValues({}, NB_DEFAULT_TIMEPICKER_LOCALIZATION_CONFIG), config?.localization ?? {});
    this.hoursText = localeConfig.hoursText;
    this.minutesText = localeConfig.minutesText;
    this.secondsText = localeConfig.secondsText;
    this.ampmText = localeConfig.ampmText;
  }
  static {
    this.ɵfac = function NbTimePickerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTimePickerComponent)(ɵɵdirectiveInject(NB_TIME_PICKER_CONFIG), ɵɵdirectiveInject(NbPlatform), ɵɵdirectiveInject(LOCALE_ID), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbCalendarTimeModelService), ɵɵdirectiveInject(NbDateService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTimePickerComponent,
      selectors: [["nb-timepicker"]],
      viewQuery: function NbTimePickerComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbPortalDirective, 7);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
        }
      },
      inputs: {
        timeFormat: "timeFormat",
        twelveHoursFormat: "twelveHoursFormat",
        showAmPmLabel: "showAmPmLabel",
        withSeconds: "withSeconds",
        singleColumn: "singleColumn",
        step: "step",
        date: "date",
        showFooter: "showFooter",
        applyButtonText: "applyButtonText",
        hoursText: "hoursText",
        minutesText: "minutesText",
        secondsText: "secondsText",
        ampmText: "ampmText",
        currentTimeButtonText: "currentTimeButtonText"
      },
      outputs: {
        onSelectTime: "onSelectTime"
      },
      exportAs: ["nbTimepicker"],
      standalone: false,
      features: [ɵɵNgOnChangesFeature],
      decls: 1,
      vars: 0,
      consts: [["fullTimeHeadersBlock", ""], ["fullTimeColumnBlock", ""], ["class", "nb-timepicker-container", 3, "supports-scrollbar-theming", 4, "nbPortal"], [1, "nb-timepicker-container"], [1, "column-header"], [4, "ngIf", "ngIfElse"], [1, "picker-body"], ["class", "actions-footer", 4, "ngIf"], [1, "header-cell"], ["class", "header-cell", 4, "ngIf"], [3, "ngIf"], [1, "values-list"], ["class", "list-item", 3, "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "list-item"], [3, "select", "value", "selected"], ["class", "values-list", 4, "ngIf"], ["class", "list-item am-pm-item", 3, "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "list-item", "am-pm-item"], [1, "actions-footer"], [3, "setCurrentTime", "saveValue", "applyButtonText", "currentTimeButtonText"]],
      template: function NbTimePickerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbTimePickerComponent_nb_card_0_Template, 10, 7, "nb-card", 2);
        }
      },
      dependencies: [NgForOf, NgIf, NbPortalDirective, NbListComponent, NbListItemComponent, NbCardComponent, NbCardFooterComponent, NbCardHeaderComponent, NbCalendarActionsComponent, NbTimePickerCellComponent],
      styles: [".nb-timepicker-container[_ngcontent-%COMP%]{overflow:hidden;margin-bottom:0}.values-list[_ngcontent-%COMP%]{width:100%;overflow:hidden;scroll-snap-type:y proximity}.values-list[_ngcontent-%COMP%]:hover{overflow-y:auto}.list-item[_ngcontent-%COMP%]{border:0;padding:0;cursor:pointer}.picker-body[_ngcontent-%COMP%]{display:flex;width:100%;flex:1 0 0;overflow:hidden}.column-header[_ngcontent-%COMP%]{width:100%;display:flex;justify-content:space-between;padding:0}.header-cell[_ngcontent-%COMP%]{width:100%;display:flex;align-items:center;justify-content:center}.actions-footer[_ngcontent-%COMP%]{width:100%}nb-card-header[_ngcontent-%COMP%], nb-card-footer[_ngcontent-%COMP%]{flex:0 0 auto}\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-timepicker",
      exportAs: "nbTimepicker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<nb-card *nbPortal [class.supports-scrollbar-theming]="!isFirefox()" class="nb-timepicker-container">\n  <nb-card-header class="column-header">\n    <ng-container *ngIf="singleColumn; else fullTimeHeadersBlock">\n      <div class="header-cell">Time</div>\n    </ng-container>\n    <ng-template #fullTimeHeadersBlock>\n      <div class="header-cell">{{ hoursText }}</div>\n      <div class="header-cell">{{ minutesText }}</div>\n      <div *ngIf="withSeconds" class="header-cell">{{ secondsText }}</div>\n      <div *ngIf="twelveHoursFormat" class="header-cell">\n        <ng-template [ngIf]="showAmPmLabel">{{ ampmText }}</ng-template>\n      </div>\n    </ng-template>\n  </nb-card-header>\n\n  <div class="picker-body">\n    <ng-container *ngIf="singleColumn; else fullTimeColumnBlock">\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedFullTimeValue(item)"\n          *ngFor="let item of fullTimeOptions; trackBy: trackBySingleColumnValue.bind(this)"\n        >\n          <nb-timepicker-cell\n            [value]="getFullTimeString(item)"\n            [selected]="isSelectedFullTimeValue(item)"\n            (select)="selectFullTime(item)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n    </ng-container>\n\n    <ng-template #fullTimeColumnBlock>\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedHour(item.value)"\n          *ngFor="let item of hoursColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedHour(item.value)"\n            (select)="setHour(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedMinute(item.value)"\n          *ngFor="let item of minutesColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedMinute(item.value)"\n            (select)="setMinute(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list *ngIf="showSeconds()" class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedSecond(item.value)"\n          *ngFor="let item of secondsColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedSecond(item.value)"\n            (select)="setSecond(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list *ngIf="twelveHoursFormat" class="values-list">\n        <nb-list-item\n          class="list-item am-pm-item"\n          [class.selected]="isSelectedDayPeriod(dayPeriod)"\n          *ngFor="let dayPeriod of dayPeriodColumnOptions; trackBy: trackByDayPeriod"\n        >\n          <nb-timepicker-cell\n            [value]="dayPeriod"\n            [selected]="isSelectedDayPeriod(dayPeriod)"\n            (select)="changeDayPeriod(dayPeriod)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n    </ng-template>\n  </div>\n\n  <nb-card-footer *ngIf="showFooter" class="actions-footer">\n    <nb-calendar-actions\n      [applyButtonText]="applyButtonText"\n      [currentTimeButtonText]="currentTimeButtonText"\n      (setCurrentTime)="setCurrentTime()"\n      (saveValue)="saveValue()"\n    ></nb-calendar-actions>\n  </nb-card-footer>\n</nb-card>\n',
      styles: [".nb-timepicker-container{overflow:hidden;margin-bottom:0}.values-list{width:100%;overflow:hidden;scroll-snap-type:y proximity}.values-list:hover{overflow-y:auto}.list-item{border:0;padding:0;cursor:pointer}.picker-body{display:flex;width:100%;flex:1 0 0;overflow:hidden}.column-header{width:100%;display:flex;justify-content:space-between;padding:0}.header-cell{width:100%;display:flex;align-items:center;justify-content:center}.actions-footer{width:100%}nb-card-header,nb-card-footer{flex:0 0 auto}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TIME_PICKER_CONFIG]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }, {
    type: NbDateService
  }], {
    timeFormat: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    hoursText: [{
      type: Input
    }],
    minutesText: [{
      type: Input
    }],
    secondsText: [{
      type: Input
    }],
    ampmText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    onSelectTime: [{
      type: Output
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective, {
        static: true
      }]
    }]
  });
})();
var NbCalendarWithTimeComponent = class _NbCalendarWithTimeComponent extends NbCalendarComponent {
  constructor(dateService, cd, calendarTimeModelService) {
    super();
    this.dateService = dateService;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
  }
  ngOnInit() {
    if (!this.date) {
      this.date = this.calendarTimeModelService.getResetTime();
    }
  }
  ngAfterViewInit() {
    this.portalOutlet.attachTemplatePortal(this.timepicker.portal);
  }
  onDateValueChange(date) {
    const hours = this.dateService.getHours(this.date);
    const minutes = this.dateService.getMinutes(this.date);
    const seconds = this.dateService.getSeconds(this.date);
    const milliseconds = this.dateService.getMilliseconds(this.date);
    let newDate = this.dateService.setHours(date, hours);
    newDate = this.dateService.setMinutes(newDate, minutes);
    newDate = this.dateService.setMinutes(newDate, minutes);
    newDate = this.dateService.setSeconds(newDate, seconds);
    newDate = this.dateService.setMilliseconds(newDate, milliseconds);
    this.date = newDate;
  }
  onTimeChange(selectedTime) {
    let newDate = this.dateService.clone(this.date);
    newDate = this.dateService.setHours(newDate, this.dateService.getHours(selectedTime.time));
    newDate = this.dateService.setMinutes(newDate, this.dateService.getMinutes(selectedTime.time));
    newDate = this.dateService.setSeconds(newDate, this.dateService.getSeconds(selectedTime.time));
    newDate = this.dateService.setMilliseconds(newDate, this.dateService.getMilliseconds(selectedTime.time));
    this.date = newDate;
  }
  saveValue() {
    this.dateChange.emit(this.date);
  }
  saveCurrentTime() {
    this.dateChange.emit(this.dateService.today());
  }
  showSeconds() {
    return this.withSeconds && !this.singleColumn;
  }
  isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  static {
    this.ɵfac = function NbCalendarWithTimeComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCalendarWithTimeComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbCalendarTimeModelService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCalendarWithTimeComponent,
      selectors: [["nb-calendar-with-time"]],
      viewQuery: function NbCalendarWithTimeComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbPortalOutletDirective, 5);
          ɵɵviewQuery(NbTimePickerComponent, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timepicker = _t.first);
        }
      },
      inputs: {
        visibleDate: "visibleDate",
        twelveHoursFormat: "twelveHoursFormat",
        showAmPmLabel: "showAmPmLabel",
        withSeconds: "withSeconds",
        singleColumn: "singleColumn",
        step: "step",
        timeFormat: "timeFormat",
        title: "title",
        applyButtonText: "applyButtonText",
        currentTimeButtonText: "currentTimeButtonText",
        showCurrentTimeButton: "showCurrentTimeButton"
      },
      standalone: false,
      features: [ɵɵInheritDefinitionFeature],
      decls: 10,
      vars: 32,
      consts: [[1, "calendar-with-time"], [1, "picker-body"], [3, "dateChange", "boundingMonth", "startView", "date", "min", "max", "filter", "dayCellComponent", "monthCellComponent", "yearCellComponent", "size", "visibleDate", "showNavigation", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek"], [1, "timepicker-section"], [1, "picker-title"], [3, "onSelectTime", "date", "twelveHoursFormat", "showAmPmLabel", "withSeconds", "showFooter", "singleColumn", "step"], ["nbPortalOutlet", ""], [1, "picker-footer"], [3, "setCurrentTime", "saveValue", "applyButtonText", "currentTimeButtonText", "showCurrentTimeButton"]],
      template: function NbCalendarWithTimeComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "nb-card", 0)(1, "nb-card-body", 1)(2, "nb-base-calendar", 2);
          ɵɵlistener("dateChange", function NbCalendarWithTimeComponent_Template_nb_base_calendar_dateChange_2_listener($event) {
            return ctx.onDateValueChange($event);
          });
          ɵɵelementEnd();
          ɵɵelementStart(3, "div", 3)(4, "div", 4);
          ɵɵtext(5);
          ɵɵelementEnd();
          ɵɵelementStart(6, "nb-timepicker", 5);
          ɵɵlistener("onSelectTime", function NbCalendarWithTimeComponent_Template_nb_timepicker_onSelectTime_6_listener($event) {
            return ctx.onTimeChange($event);
          });
          ɵɵelementEnd();
          ɵɵelementContainer(7, 6);
          ɵɵelementEnd()();
          ɵɵelementStart(8, "nb-card-footer", 7)(9, "nb-calendar-actions", 8);
          ɵɵlistener("setCurrentTime", function NbCalendarWithTimeComponent_Template_nb_calendar_actions_setCurrentTime_9_listener() {
            return ctx.saveCurrentTime();
          })("saveValue", function NbCalendarWithTimeComponent_Template_nb_calendar_actions_saveValue_9_listener() {
            return ctx.saveValue();
          });
          ɵɵelementEnd()()();
        }
        if (rf & 2) {
          ɵɵadvance(2);
          ɵɵproperty("boundingMonth", ctx.boundingMonth)("startView", ctx.startView)("date", ctx.date)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("size", ctx.size)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
          ɵɵadvance();
          ɵɵclassProp("size-large", ctx.isLarge())("timepicker-single-column-width", ctx.singleColumn)("timepicker-multiple-column-width", !ctx.singleColumn);
          ɵɵadvance(2);
          ɵɵtextInterpolate(ctx.title);
          ɵɵadvance();
          ɵɵproperty("date", ctx.date)("twelveHoursFormat", ctx.twelveHoursFormat)("showAmPmLabel", ctx.showAmPmLabel)("withSeconds", ctx.showSeconds())("showFooter", false)("singleColumn", ctx.singleColumn)("step", ctx.step);
          ɵɵadvance(3);
          ɵɵproperty("applyButtonText", ctx.applyButtonText)("currentTimeButtonText", ctx.currentTimeButtonText)("showCurrentTimeButton", ctx.showCurrentTimeButton);
        }
      },
      dependencies: [NbPortalOutletDirective, NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbBaseCalendarComponent, NbTimePickerComponent, NbCalendarActionsComponent],
      styles: ["[_nghost-%COMP%]     nb-card.nb-timepicker-container{flex:1 0 0;border-radius:0;width:auto;border-right:0;border-bottom:0}[dir=ltr]   [_nghost-%COMP%]   .picker-footer[_ngcontent-%COMP%]{padding-left:.625rem}[dir=rtl]   [_nghost-%COMP%]   .picker-footer[_ngcontent-%COMP%]{padding-right:.625rem}.picker-body[_ngcontent-%COMP%]{align-items:stretch;display:flex;padding:0}.picker-body[_ngcontent-%COMP%]   nb-base-calendar[_ngcontent-%COMP%]     nb-card{border-radius:0}.calendar-with-time[_ngcontent-%COMP%]{overflow:hidden}.timepicker-section[_ngcontent-%COMP%]{display:flex;flex-direction:column}\n\n\n\n\n\n\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarWithTimeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-with-time",
      template: `
    <nb-card class="calendar-with-time">
      <nb-card-body class="picker-body">
        <nb-base-calendar
          [boundingMonth]="boundingMonth"
          [startView]="startView"
          [date]="date"
          [min]="min"
          [max]="max"
          [filter]="filter"
          [dayCellComponent]="dayCellComponent"
          [monthCellComponent]="monthCellComponent"
          [yearCellComponent]="yearCellComponent"
          [size]="size"
          [visibleDate]="visibleDate"
          [showNavigation]="showNavigation"
          [showWeekNumber]="showWeekNumber"
          [weekNumberSymbol]="weekNumberSymbol"
          [firstDayOfWeek]="firstDayOfWeek"
          (dateChange)="onDateValueChange($event)"
        >
        </nb-base-calendar>
        <div
          class="timepicker-section"
          [class.size-large]="isLarge()"
          [class.timepicker-single-column-width]="singleColumn"
          [class.timepicker-multiple-column-width]="!singleColumn"
        >
          <div class="picker-title">{{ title }}</div>
          <nb-timepicker
            (onSelectTime)="onTimeChange($event)"
            [date]="date"
            [twelveHoursFormat]="twelveHoursFormat"
            [showAmPmLabel]="showAmPmLabel"
            [withSeconds]="showSeconds()"
            [showFooter]="false"
            [singleColumn]="singleColumn"
            [step]="step"
          >
          </nb-timepicker>
          <ng-container nbPortalOutlet></ng-container>
        </div>
      </nb-card-body>
      <nb-card-footer class="picker-footer">
        <nb-calendar-actions
          [applyButtonText]="applyButtonText"
          [currentTimeButtonText]="currentTimeButtonText"
          [showCurrentTimeButton]="showCurrentTimeButton"
          (setCurrentTime)="saveCurrentTime()"
          (saveValue)="saveValue()"
        ></nb-calendar-actions>
      </nb-card-footer>
    </nb-card>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host ::ng-deep nb-card.nb-timepicker-container{flex:1 0 0;border-radius:0;width:auto;border-right:0;border-bottom:0}[dir=ltr] :host .picker-footer{padding-left:.625rem}[dir=rtl] :host .picker-footer{padding-right:.625rem}.picker-body{align-items:stretch;display:flex;padding:0}.picker-body nb-base-calendar ::ng-deep nb-card{border-radius:0}.calendar-with-time{overflow:hidden}.timepicker-section{display:flex;flex-direction:column}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }], {
    visibleDate: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective]
    }],
    timepicker: [{
      type: ViewChild,
      args: [NbTimePickerComponent]
    }]
  });
})();
var NbDatepickerContainerComponent = class _NbDatepickerContainerComponent extends NbPositionedContainerComponent {
  attach(portal) {
    return this.overlayContainer.attachComponentPortal(portal);
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbDatepickerContainerComponent_BaseFactory;
      return function NbDatepickerContainerComponent_Factory(__ngFactoryType__) {
        return (ɵNbDatepickerContainerComponent_BaseFactory || (ɵNbDatepickerContainerComponent_BaseFactory = ɵɵgetInheritedFactory(_NbDatepickerContainerComponent)))(__ngFactoryType__ || _NbDatepickerContainerComponent);
      };
    })();
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbDatepickerContainerComponent,
      selectors: [["nb-datepicker-container"]],
      viewQuery: function NbDatepickerContainerComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbOverlayContainerComponent, 7);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
        }
      },
      standalone: false,
      features: [ɵɵInheritDefinitionFeature],
      decls: 1,
      vars: 0,
      template: function NbDatepickerContainerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelement(0, "nb-overlay-container");
        }
      },
      dependencies: [NbOverlayContainerComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-datepicker-container",
      template: `
    <nb-overlay-container></nb-overlay-container>
  `,
      standalone: false
    }]
  }], null, {
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent, {
        static: true
      }]
    }]
  });
})();
var NbDatepickerAdapter = class {
};
var NbDatepicker = class {
};
var NB_DATE_ADAPTER = new InjectionToken("Datepicker Adapter");
var NB_DATE_SERVICE_OPTIONS = new InjectionToken("Date service options");
var NbDatepickerDirective = class _NbDatepickerDirective {
  /**
   * Provides datepicker component.
   * */
  // eslint-disable-next-line @angular-eslint/no-input-rename
  set setPicker(picker) {
    this.picker = picker;
    this.setupPicker();
  }
  constructor(document2, datepickerAdapters, hostRef, dateService, changeDetector) {
    this.document = document2;
    this.datepickerAdapters = datepickerAdapters;
    this.hostRef = hostRef;
    this.dateService = dateService;
    this.changeDetector = changeDetector;
    this.destroy$ = new Subject();
    this.isDatepickerReady = false;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.validator = Validators.compose([this.parseValidator, this.minValidator, this.maxValidator, this.filterValidator].map((fn) => fn.bind(this)));
    this.subscribeOnInputChange();
  }
  /**
   * Returns html input element.
   * */
  get input() {
    return this.hostRef.nativeElement;
  }
  /**
   * Returns host input value.
   * */
  get inputValue() {
    return this.input.value;
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Writes value in picker and html input element.
   * */
  writeValue(value) {
    if (this.isDatepickerReady) {
      this.writePicker(value);
      this.writeInput(value);
    } else {
      this.queue = value;
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.input.disabled = isDisabled;
  }
  /**
   * Form control validation based on picker validator config.
   * */
  validate() {
    return this.validator(null);
  }
  /**
   * Hides picker, focuses the input
   */
  hidePicker() {
    this.input.focus();
    this.picker.hide();
  }
  /**
   * Validates that we can parse value correctly.
   * */
  parseValidator() {
    if (this.inputValue === "") {
      return null;
    }
    const isValid = this.datepickerAdapter.isValid(this.inputValue, this.picker.format);
    return isValid ? null : {
      nbDatepickerParse: {
        value: this.inputValue
      }
    };
  }
  /**
   * Validates passed value is greater than min.
   * */
  minValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.min || !date || this.dateService.compareDates(config.min, date) <= 0 ? null : {
      nbDatepickerMin: {
        min: config.min,
        actual: date
      }
    };
  }
  /**
   * Validates passed value is smaller than max.
   * */
  maxValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.max || !date || this.dateService.compareDates(config.max, date) >= 0 ? null : {
      nbDatepickerMax: {
        max: config.max,
        actual: date
      }
    };
  }
  /**
   * Validates passed value satisfy the filter.
   * */
  filterValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.filter || !date || config.filter(date) ? null : {
      nbDatepickerFilter: true
    };
  }
  /**
   * Chooses datepicker adapter based on passed picker component.
   * */
  chooseDatepickerAdapter() {
    this.datepickerAdapter = this.datepickerAdapters.find(({
      picker
    }) => this.picker instanceof picker);
    if (this.noDatepickerAdapterProvided()) {
      throw new Error("No datepickerAdapter provided for picker");
    }
  }
  /**
   * Attaches picker to the host input element and subscribes on value changes.
   * */
  setupPicker() {
    this.chooseDatepickerAdapter();
    this.picker.attach(this.hostRef);
    if (this.inputValue) {
      this.picker.value = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    }
    this.pickerInputsChangedSubscription?.unsubscribe();
    this.pickerInputsChangedSubscription = this.picker.formatChanged$.pipe(map(() => this.picker.format), startWith(this.picker.format), distinctUntilChanged(), pairwise(), takeUntil(this.destroy$)).subscribe(([prevFormat, nextFormat]) => {
      if (this.inputValue) {
        const date = this.datepickerAdapter.parse(this.inputValue, prevFormat);
        this.writeInput(date);
      }
    });
    if (!this.isDatepickerReady) {
      this.picker.init.pipe(take(1), tap(() => this.isDatepickerReady = true), filter(() => !!this.queue), takeUntil(this.destroy$)).subscribe(() => {
        this.writeValue(this.queue);
        this.changeDetector.detectChanges();
        this.queue = void 0;
      });
    }
    this.picker.valueChange.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      this.writePicker(value);
      this.writeInput(value);
      this.onChange(value);
      if (this.picker.shouldHide()) {
        this.hidePicker();
      }
    });
    merge(this.picker.blur, fromEvent(this.input, "blur").pipe(filter(() => !this.picker.isShown && this.document.activeElement !== this.input))).pipe(takeUntil(this.destroy$)).subscribe(() => this.onTouched());
  }
  writePicker(value) {
    this.picker.value = value;
  }
  writeInput(value) {
    this.hostRef.nativeElement.value = this.datepickerAdapter.format(value, this.picker.format);
  }
  /**
   * Validates if no datepicker adapter provided.
   * */
  noDatepickerAdapterProvided() {
    return !this.datepickerAdapter || !(this.datepickerAdapter instanceof NbDatepickerAdapter);
  }
  subscribeOnInputChange() {
    fromEvent(this.input, "input").pipe(map(() => this.inputValue), takeUntil(this.destroy$)).subscribe((value) => this.handleInputChange(value));
  }
  /**
   * Parses input value and write if it isn't null.
   * */
  handleInputChange(value) {
    const date = this.parseInputValue(value);
    this.onChange(date);
    this.writePicker(date);
  }
  parseInputValue(value) {
    if (this.datepickerAdapter.isValid(value, this.picker.format)) {
      return this.datepickerAdapter.parse(value, this.picker.format);
    }
    return null;
  }
  static {
    this.ɵfac = function NbDatepickerDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbDatepickerDirective)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NB_DATE_ADAPTER), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbDatepickerDirective,
      selectors: [["input", "nbDatepicker", ""]],
      inputs: {
        setPicker: [0, "nbDatepicker", "setPicker"]
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _NbDatepickerDirective),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => _NbDatepickerDirective),
        multi: true
      }])]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbDatepicker]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbDatepickerDirective),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => NbDatepickerDirective),
        multi: true
      }],
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DATE_ADAPTER]
    }]
  }, {
    type: ElementRef
  }, {
    type: NbDateService
  }, {
    type: ChangeDetectorRef
  }], {
    setPicker: [{
      type: Input,
      args: ["nbDatepicker"]
    }]
  });
})();
var NbBasePicker = class extends NbDatepicker {
  constructor(overlay, positionBuilder, triggerStrategyBuilder, cfr, dateService, dateServiceOptions) {
    super();
    this.overlay = overlay;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.cfr = cfr;
    this.dateService = dateService;
    this.dateServiceOptions = dateServiceOptions;
    this.formatChanged$ = new Subject();
    this.init$ = new ReplaySubject();
    this.onChange$ = new Subject();
    this.overlayOffset = 8;
    this.adjustment = NbAdjustment.COUNTERCLOCKWISE;
    this.destroy$ = new Subject();
    this.blur$ = new Subject();
  }
  /**
   * Returns picker instance.
   * */
  get picker() {
    return this.pickerRef && this.pickerRef.instance;
  }
  /**
   * Stream of picker value changes.
   * */
  get valueChange() {
    return this.onChange$.asObservable();
  }
  get isShown() {
    return this.ref && this.ref.hasAttached();
  }
  get init() {
    return this.init$.asObservable();
  }
  /**
   * Emits when datepicker looses focus.
   */
  get blur() {
    return this.blur$.asObservable();
  }
  /**
   * Datepicker knows nothing about host html input element.
   * So, attach method attaches datepicker to the host input element.
   * */
  attach(hostRef) {
    this.hostRef = hostRef;
    this.subscribeOnTriggers();
  }
  getValidatorConfig() {
    return {
      min: this.min,
      max: this.max,
      filter: this.filter
    };
  }
  show() {
    if (!this.ref) {
      this.createOverlay();
    }
    this.openDatepicker();
  }
  shouldHide() {
    return this.hideOnSelect && !!this.value;
  }
  hide() {
    if (this.ref) {
      this.ref.detach();
    }
    if (this.picker) {
      this.queue = this.value;
      this.pickerRef.destroy();
      this.pickerRef = null;
      this.container = null;
    }
  }
  createOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy: this.overlay.scrollStrategies.reposition()
    });
    this.subscribeOnPositionChange();
  }
  openDatepicker() {
    this.container = this.ref.attach(new NbComponentPortal(NbDatepickerContainerComponent, null, null, this.cfr));
    this.instantiatePicker();
    this.subscribeOnValueChange();
    this.writeQueue();
    this.patchWithInputs();
    this.pickerRef.changeDetectorRef.markForCheck();
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(this.adjustment);
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => patch(this.container, {
      position
    }));
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.container).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.subscribe(() => {
      this.blur$.next();
      this.hide();
    });
  }
  instantiatePicker() {
    this.pickerRef = this.container.instance.attach(new NbComponentPortal(this.pickerClass, null, null, this.cfr));
  }
  /**
   * Subscribes on picker value changes and emit data through this.onChange$ subject.
   * */
  subscribeOnValueChange() {
    this.pickerValueChange.subscribe((date) => {
      this.onChange$.next(date);
    });
  }
  patchWithInputs() {
    this.picker.boundingMonth = this.boundingMonth;
    this.picker.startView = this.startView;
    this.picker.min = this.min;
    this.picker.max = this.max;
    this.picker.filter = this.filter;
    this.picker._cellComponent = this.dayCellComponent;
    this.picker._monthCellComponent = this.monthCellComponent;
    this.picker._yearCellComponent = this.yearCellComponent;
    this.picker.size = this.size;
    this.picker.showNavigation = this.showNavigation;
    this.picker.visibleDate = this.visibleDate;
    this.picker.showWeekNumber = this.showWeekNumber;
    this.picker.weekNumberSymbol = this.weekNumberSymbol;
    this.picker.firstDayOfWeek = this.firstDayOfWeek;
  }
  checkFormat() {
    if (this.dateService.getId() === "native" && this.format) {
      throw new Error(`Can't format native date. To use custom formatting you have to install @nebular/moment or @nebular/date-fns package and import NbMomentDateModule or NbDateFnsDateModule accordingly.More information at "Formatting issue" https://akveo.github.io/nebular/docs/components/datepicker/overview#nbdatepickercomponent`);
    }
    const isFormatSet = this.format || this.dateServiceOptions && this.dateServiceOptions.format;
    if (this.dateService.getId() === "date-fns" && !isFormatSet) {
      throw new Error("format is required when using NbDateFnsDateModule");
    }
  }
};
var NbBasePickerComponent = class _NbBasePickerComponent extends NbBasePicker {
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(document2, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions) {
    super(overlay, positionBuilder, triggerStrategyBuilder, cfr, dateService, dateServiceOptions);
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.hideOnSelect = true;
    this.showNavigation = true;
    this.weekNumberSymbol = "#";
    this._showWeekNumber = false;
    this.overlayOffset = 8;
    this.adjustment = NbAdjustment.COUNTERCLOCKWISE;
  }
  ngOnInit() {
    this.checkFormat();
    this.init$.next();
  }
  ngOnChanges(changes) {
    if (changes.format) {
      if (!changes.format.isFirstChange()) {
        this.checkFormat();
      }
      this.formatChanged$.next();
    }
    if (this.picker) {
      this.patchWithInputs();
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.hide();
    this.init$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  get pickerValueChange() {
    return void 0;
  }
  get value() {
    return void 0;
  }
  set value(value) {
  }
  writeQueue() {
  }
  static {
    this.ɵfac = function NbBasePickerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbBasePickerComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NB_DATE_SERVICE_OPTIONS, 8));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbBasePickerComponent,
      selectors: [["ng-component"]],
      inputs: {
        format: "format",
        boundingMonth: "boundingMonth",
        startView: "startView",
        min: "min",
        max: "max",
        filter: "filter",
        dayCellComponent: "dayCellComponent",
        monthCellComponent: "monthCellComponent",
        yearCellComponent: "yearCellComponent",
        size: "size",
        visibleDate: "visibleDate",
        hideOnSelect: "hideOnSelect",
        showNavigation: "showNavigation",
        weekNumberSymbol: "weekNumberSymbol",
        showWeekNumber: "showWeekNumber",
        firstDayOfWeek: "firstDayOfWeek",
        overlayOffset: "overlayOffset",
        adjustment: "adjustment"
      },
      standalone: false,
      features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
      decls: 0,
      vars: 0,
      template: function NbBasePickerComponent_Template(rf, ctx) {
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBasePickerComponent, [{
    type: Component,
    args: [{
      template: "",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: NbDateService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_DATE_SERVICE_OPTIONS]
    }]
  }], {
    format: [{
      type: Input
    }],
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    hideOnSelect: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    overlayOffset: [{
      type: Input
    }],
    adjustment: [{
      type: Input
    }]
  });
})();
var NbDatepickerComponent = class _NbDatepickerComponent extends NbBasePickerComponent {
  constructor() {
    super(...arguments);
    this.pickerClass = NbCalendarComponent;
  }
  /**
   * Date which will be rendered as selected.
   * */
  set date(date) {
    this.value = date;
  }
  /**
   * Emits date when selected.
   * */
  get dateChange() {
    return this.valueChange;
  }
  get value() {
    return this.picker ? this.picker.date : void 0;
  }
  set value(date) {
    if (!this.picker) {
      this.queue = date;
      return;
    }
    if (date) {
      this.visibleDate = date;
      this.picker.visibleDate = date;
      this.picker.date = date;
    }
  }
  get pickerValueChange() {
    return this.picker.dateChange;
  }
  writeQueue() {
    if (this.queue) {
      const date = this.queue;
      this.queue = null;
      this.value = date;
    }
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbDatepickerComponent_BaseFactory;
      return function NbDatepickerComponent_Factory(__ngFactoryType__) {
        return (ɵNbDatepickerComponent_BaseFactory || (ɵNbDatepickerComponent_BaseFactory = ɵɵgetInheritedFactory(_NbDatepickerComponent)))(__ngFactoryType__ || _NbDatepickerComponent);
      };
    })();
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbDatepickerComponent,
      selectors: [["nb-datepicker"]],
      inputs: {
        date: "date"
      },
      outputs: {
        dateChange: "dateChange"
      },
      standalone: false,
      features: [ɵɵInheritDefinitionFeature],
      decls: 0,
      vars: 0,
      template: function NbDatepickerComponent_Template(rf, ctx) {
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-datepicker",
      template: "",
      standalone: false
    }]
  }], null, {
    date: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }]
  });
})();
var NbRangepickerComponent = class _NbRangepickerComponent extends NbBasePickerComponent {
  constructor() {
    super(...arguments);
    this.pickerClass = NbCalendarRangeComponent;
  }
  /**
   * Range which will be rendered as selected.
   * */
  set range(range2) {
    this.value = range2;
  }
  /**
   * Emits range when start selected and emits again when end selected.
   * */
  get rangeChange() {
    return this.valueChange;
  }
  get value() {
    return this.picker ? this.picker.range : void 0;
  }
  set value(range2) {
    if (!this.picker) {
      this.queue = range2;
      return;
    }
    if (range2) {
      const visibleDate = range2 && range2.start;
      this.visibleDate = visibleDate;
      this.picker.visibleDate = visibleDate;
      this.picker.range = range2;
    }
  }
  get pickerValueChange() {
    return this.picker.rangeChange;
  }
  shouldHide() {
    return super.shouldHide() && !!(this.value && this.value.start && this.value.end);
  }
  writeQueue() {
    if (this.queue) {
      const range2 = this.queue;
      this.queue = null;
      this.value = range2;
    }
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbRangepickerComponent_BaseFactory;
      return function NbRangepickerComponent_Factory(__ngFactoryType__) {
        return (ɵNbRangepickerComponent_BaseFactory || (ɵNbRangepickerComponent_BaseFactory = ɵɵgetInheritedFactory(_NbRangepickerComponent)))(__ngFactoryType__ || _NbRangepickerComponent);
      };
    })();
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbRangepickerComponent,
      selectors: [["nb-rangepicker"]],
      inputs: {
        range: "range"
      },
      outputs: {
        rangeChange: "rangeChange"
      },
      standalone: false,
      features: [ɵɵInheritDefinitionFeature],
      decls: 0,
      vars: 0,
      template: function NbRangepickerComponent_Template(rf, ctx) {
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRangepickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-rangepicker",
      template: "",
      standalone: false
    }]
  }], null, {
    range: [{
      type: Input
    }],
    rangeChange: [{
      type: Output
    }]
  });
})();
var NbDateTimePickerComponent = class _NbDateTimePickerComponent extends NbBasePickerComponent {
  get value() {
    return this.picker ? this.picker.date : void 0;
  }
  set value(date) {
    if (!this.picker) {
      this.queue = date;
      return;
    }
    if (date) {
      this.visibleDate = date;
      this.picker.visibleDate = date;
      this.picker.date = date;
      this.picker.cd.markForCheck();
    }
  }
  /**
   * Defines 12 hours format like '07:00 PM'.
   * */
  get twelveHoursFormat() {
    return this._twelveHoursFormat;
  }
  set twelveHoursFormat(value) {
    this._twelveHoursFormat = convertToBoolProperty(value);
  }
  /**
   * Defines should show am/pm label if twelveHoursFormat enabled.
   * */
  get showAmPmLabel() {
    return this._showAmPmLabel;
  }
  set showAmPmLabel(value) {
    this._showAmPmLabel = convertToBoolProperty(value);
  }
  /**
   * Show seconds in timepicker.
   * Ignored when singleColumn is true.
   * */
  get withSeconds() {
    return this._withSeconds;
  }
  set withSeconds(value) {
    this._withSeconds = convertToBoolProperty(value);
  }
  /**
   * Show timepicker values in one column with 60 minutes step by default.
   * */
  get singleColumn() {
    return this._singleColumn;
  }
  set singleColumn(value) {
    this._singleColumn = convertToBoolProperty(value);
  }
  /**
   * Emits date with time when selected.
   * */
  get dateTimeChange() {
    return this.valueChange;
  }
  constructor(document2, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions, calendarWithTimeModelService) {
    super(document2, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions);
    this.calendarWithTimeModelService = calendarWithTimeModelService;
    this.pickerClass = NbCalendarWithTimeComponent;
    this.showCurrentTimeButton = true;
    this._showAmPmLabel = true;
  }
  ngOnInit() {
    this.format = this.format || this.buildTimeFormat();
    this.init$.next();
  }
  patchWithInputs() {
    this.picker.singleColumn = this.singleColumn;
    this.picker.twelveHoursFormat = this.twelveHoursFormat;
    this.picker.showAmPmLabel = this.showAmPmLabel;
    this.picker.withSeconds = this.withSeconds;
    this.picker.step = this.step;
    this.picker.title = this.title;
    this.picker.applyButtonText = this.applyButtonText;
    this.picker.currentTimeButtonText = this.currentTimeButtonText;
    this.picker.showCurrentTimeButton = this.showCurrentTimeButton;
    if (this.twelveHoursFormat) {
      this.picker.timeFormat = this.dateService.getTwelveHoursFormat();
    } else {
      this.picker.timeFormat = this.withSeconds && !this.singleColumn ? this.dateService.getTwentyFourHoursFormatWithSeconds() : this.dateService.getTwentyFourHoursFormat();
    }
    super.patchWithInputs();
    this.picker.cd.markForCheck();
  }
  get pickerValueChange() {
    return this.picker.dateChange;
  }
  writeQueue() {
    if (this.queue) {
      const date = this.queue;
      this.queue = null;
      this.value = date;
    }
  }
  buildTimeFormat() {
    if (this.singleColumn) {
      return this.calendarWithTimeModelService.buildDateFormat(this.twelveHoursFormat);
    } else {
      return this.calendarWithTimeModelService.buildDateFormat(this.twelveHoursFormat, this.withSeconds);
    }
  }
  static {
    this.ɵfac = function NbDateTimePickerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbDateTimePickerComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NB_DATE_SERVICE_OPTIONS, 8), ɵɵdirectiveInject(NbCalendarTimeModelService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbDateTimePickerComponent,
      selectors: [["nb-date-timepicker"]],
      inputs: {
        step: "step",
        title: "title",
        applyButtonText: "applyButtonText",
        currentTimeButtonText: "currentTimeButtonText",
        showCurrentTimeButton: "showCurrentTimeButton",
        twelveHoursFormat: "twelveHoursFormat",
        showAmPmLabel: "showAmPmLabel",
        withSeconds: "withSeconds",
        singleColumn: "singleColumn"
      },
      outputs: {
        dateTimeChange: "dateTimeChange"
      },
      standalone: false,
      features: [ɵɵInheritDefinitionFeature],
      decls: 0,
      vars: 0,
      template: function NbDateTimePickerComponent_Template(rf, ctx) {
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateTimePickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-date-timepicker",
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: NbDateService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_DATE_SERVICE_OPTIONS]
    }]
  }, {
    type: NbCalendarTimeModelService
  }], {
    step: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    dateTimeChange: [{
      type: Output
    }]
  });
})();
function isUrlPathEqual(path, link) {
  const locationPath = getPathPartOfUrl(path);
  return link === locationPath;
}
function isUrlPathContain(path, link) {
  const locationPath = getPathPartOfUrl(path);
  const endOfUrlSegmentRegExp = /\/|^$/;
  return locationPath.startsWith(link) && locationPath.slice(link.length).charAt(0).search(endOfUrlSegmentRegExp) !== -1;
}
function getPathPartOfUrl(url) {
  return url.match(/.*?(?=[?;#]|$)/)[0];
}
function getFragmentPartOfUrl(url) {
  const matched = url.match(/#(.+)/);
  return matched ? matched[1] : "";
}
function isFragmentEqual(path, fragment) {
  return getFragmentPartOfUrl(path) === fragment;
}
function isFragmentContain(path, fragment) {
  return getFragmentPartOfUrl(path).includes(fragment);
}
var NbRestoreScrollTopHelper = class _NbRestoreScrollTopHelper {
  constructor(router) {
    this.router = router;
  }
  shouldRestore() {
    return this.router.events.pipe(startWith(null), filter((event) => event === null || event instanceof NavigationEnd), pairwise(), map(([prev, current]) => this.pageChanged(prev, current)), filter((res) => !!res));
  }
  pageChanged(prev, current) {
    return !prev || getPathPartOfUrl(prev.url) !== getPathPartOfUrl(current.url);
  }
  static {
    this.ɵfac = function NbRestoreScrollTopHelper_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbRestoreScrollTopHelper)(ɵɵinject(Router));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbRestoreScrollTopHelper,
      factory: _NbRestoreScrollTopHelper.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRestoreScrollTopHelper, [{
    type: Injectable
  }], () => [{
    type: Router
  }], null);
})();
var NbLayoutComponent = class _NbLayoutComponent {
  /**
   * Defines whether the layout columns will be centered after some width
   * @param {boolean} val
   */
  set center(val) {
    this.centerValue = convertToBoolProperty(val);
  }
  /**
   * Defines whether the layout enters a 'window' mode, when the layout content (including sidebars and fixed header)
   * becomes centered by width with a margin from the top of the screen, like a floating window.
   * Automatically enables `withScroll` mode, as in the window mode scroll must be inside the layout and cannot be on
   * window. (TODO: check this)
   * @param {boolean} val
   */
  set windowMode(val) {
    this.windowModeValue = convertToBoolProperty(val);
    this.withScroll = this.windowModeValue;
  }
  /**
   * Defines whether to move the scrollbars to layout or leave it at the body level.
   * Automatically set to true when `windowMode` is enabled.
   * @param {boolean} val
   */
  set withScroll(val) {
    this.withScrollValue = convertToBoolProperty(val);
    const body = this.document.getElementsByTagName("body")[0];
    if (this.withScrollValue) {
      this.renderer.setStyle(body, "overflow", "hidden");
    } else {
      this.renderer.setStyle(body, "overflow", "initial");
    }
  }
  /**
   * Restores scroll to the top of the page after navigation
   * @param {boolean} val
   */
  set restoreScrollTop(val) {
    this.restoreScrollTopValue = convertToBoolProperty(val);
  }
  constructor(themeService, spinnerService, elementRef, renderer, window2, document2, platformId, layoutDirectionService, scrollService, rulerService, scrollTop, overlayContainer) {
    this.themeService = themeService;
    this.spinnerService = spinnerService;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.window = window2;
    this.document = document2;
    this.platformId = platformId;
    this.layoutDirectionService = layoutDirectionService;
    this.scrollService = scrollService;
    this.rulerService = rulerService;
    this.scrollTop = scrollTop;
    this.overlayContainer = overlayContainer;
    this.scrollBlockClass = "nb-global-scrollblock";
    this.isScrollBlocked = false;
    this.centerValue = false;
    this.restoreScrollTopValue = true;
    this.windowModeValue = false;
    this.withScrollValue = false;
    this.withSubheader = false;
    this.afterViewInit$ = new BehaviorSubject(null);
    this.destroy$ = new Subject();
    this.registerAsOverlayContainer();
    this.themeService.onThemeChange().pipe(takeUntil(this.destroy$)).subscribe((theme) => {
      const body = this.document.getElementsByTagName("body")[0];
      if (theme.previous) {
        this.renderer.removeClass(body, `nb-theme-${theme.previous}`);
      }
      this.renderer.addClass(body, `nb-theme-${theme.name}`);
    });
    this.themeService.onAppendLayoutClass().pipe(takeUntil(this.destroy$)).subscribe((className) => {
      this.renderer.addClass(this.elementRef.nativeElement, className);
    });
    this.themeService.onRemoveLayoutClass().pipe(takeUntil(this.destroy$)).subscribe((className) => {
      this.renderer.removeClass(this.elementRef.nativeElement, className);
    });
    this.spinnerService.registerLoader(new Promise((resolve) => {
      this.afterViewInit$.pipe(takeUntil(this.destroy$)).subscribe((_) => resolve());
    }));
    this.spinnerService.load();
    this.rulerService.onGetDimensions().pipe(takeUntil(this.destroy$)).subscribe(({
      listener
    }) => {
      listener.next(this.getDimensions());
      listener.complete();
    });
    this.scrollService.onGetPosition().pipe(takeUntil(this.destroy$)).subscribe(({
      listener
    }) => {
      listener.next(this.getScrollPosition());
      listener.complete();
    });
    this.scrollTop.shouldRestore().pipe(filter(() => this.restoreScrollTopValue), takeUntil(this.destroy$)).subscribe(() => {
      this.scroll(0, 0);
    });
    this.scrollService.onScrollableChange().pipe(filter(() => this.withScrollValue), takeUntil(this.destroy$)).subscribe((scrollable) => {
      if (scrollable) {
        this.enableScroll();
      } else {
        this.blockScroll();
      }
    });
    if (isPlatformBrowser(this.platformId)) {
      this.themeService.changeWindowWidth(this.window.innerWidth);
    }
  }
  ngAfterViewInit() {
    this.layoutDirectionService.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe((direction) => this.document.dir = direction);
    this.scrollService.onManualScroll().pipe(takeUntil(this.destroy$)).subscribe(({
      x,
      y
    }) => this.scroll(x, y));
    this.afterViewInit$.next(true);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.unregisterAsOverlayContainer();
  }
  onScroll($event) {
    this.scrollService.fireScrollChange($event);
  }
  onResize(event) {
    this.themeService.changeWindowWidth(event.target.innerWidth);
  }
  /**
   * Returns scroll and client height/width
   *
   * Depending on the current scroll mode (`withScroll=true`) returns sizes from the body element
   * or from the `.scrollable-container`
   * @returns {NbLayoutDimensions}
   */
  getDimensions() {
    let clientWidth, clientHeight, scrollWidth, scrollHeight = 0;
    if (this.withScrollValue) {
      const container = this.scrollableContainerRef.nativeElement;
      clientWidth = container.clientWidth;
      clientHeight = container.clientHeight;
      scrollWidth = container.scrollWidth;
      scrollHeight = container.scrollHeight;
    } else {
      const {
        documentElement,
        body
      } = this.document;
      clientWidth = documentElement.clientWidth || body.clientWidth;
      clientHeight = documentElement.clientHeight || body.clientHeight;
      scrollWidth = documentElement.scrollWidth || body.scrollWidth;
      scrollHeight = documentElement.scrollHeight || body.scrollHeight;
    }
    return {
      clientWidth,
      clientHeight,
      scrollWidth,
      scrollHeight
    };
  }
  /**
   * Returns scroll position of current scroll container.
   *
   * If `withScroll` = true, returns scroll position of the `.scrollable-container` element,
   * otherwise - of the scrollable element of the window (which may be different depending of a browser)
   *
   * @returns {NbScrollPosition}
   */
  getScrollPosition() {
    if (!isPlatformBrowser(this.platformId)) {
      return {
        x: 0,
        y: 0
      };
    }
    if (this.withScrollValue) {
      const container = this.scrollableContainerRef.nativeElement;
      return {
        x: container.scrollLeft,
        y: container.scrollTop
      };
    }
    const documentRect = this.document.documentElement.getBoundingClientRect();
    const x = -documentRect.left || this.document.body.scrollLeft || this.window.scrollX || this.document.documentElement.scrollLeft || 0;
    const y = -documentRect.top || this.document.body.scrollTop || this.window.scrollY || this.document.documentElement.scrollTop || 0;
    return {
      x,
      y
    };
  }
  registerAsOverlayContainer() {
    if (this.overlayContainer.setContainer) {
      this.overlayContainer.setContainer(this.elementRef.nativeElement);
    }
  }
  unregisterAsOverlayContainer() {
    if (this.overlayContainer.clearContainer) {
      this.overlayContainer.clearContainer();
    }
  }
  scroll(x = null, y = null) {
    const {
      x: currentX,
      y: currentY
    } = this.getScrollPosition();
    x = x == null ? currentX : x;
    y = y == null ? currentY : y;
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    if (this.withScrollValue) {
      const scrollable = this.scrollableContainerRef.nativeElement;
      if (scrollable.scrollTo) {
        scrollable.scrollTo(x, y);
      } else {
        scrollable.scrollLeft = x;
        scrollable.scrollTop = y;
      }
    } else {
      this.window.scrollTo(x, y);
    }
  }
  // TODO: Extract into block scroll strategy
  blockScroll() {
    if (this.isScrollBlocked) {
      return;
    }
    this.isScrollBlocked = true;
    this.renderer.addClass(this.document.documentElement, this.scrollBlockClass);
    const scrollableContainerElement = this.scrollableContainerRef.nativeElement;
    const layoutElement = this.layoutContainerRef.nativeElement;
    const layoutWithScrollWidth = layoutElement.clientWidth;
    this.scrollableContainerOverflowOldValue = scrollableContainerElement.style.overflow;
    scrollableContainerElement.style.overflow = "hidden";
    const layoutWithoutScrollWidth = layoutElement.clientWidth;
    const scrollWidth = layoutWithoutScrollWidth - layoutWithScrollWidth;
    if (!scrollWidth) {
      return;
    }
    this.layoutPaddingOldValue = {
      left: layoutElement.style.paddingLeft,
      right: layoutElement.style.paddingRight
    };
    if (this.layoutDirectionService.isLtr()) {
      layoutElement.style.paddingRight = `${scrollWidth}px`;
    } else {
      layoutElement.style.paddingLeft = `${scrollWidth}px`;
    }
  }
  enableScroll() {
    if (this.isScrollBlocked) {
      this.isScrollBlocked = false;
      this.renderer.removeClass(this.document.documentElement, this.scrollBlockClass);
      this.scrollableContainerRef.nativeElement.style.overflow = this.scrollableContainerOverflowOldValue;
      if (this.layoutPaddingOldValue) {
        const layoutElement = this.layoutContainerRef.nativeElement;
        layoutElement.style.paddingLeft = this.layoutPaddingOldValue.left;
        layoutElement.style.paddingRight = this.layoutPaddingOldValue.right;
        this.layoutPaddingOldValue = null;
      }
    }
  }
  static {
    this.ɵfac = function NbLayoutComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbLayoutComponent)(ɵɵdirectiveInject(NbThemeService), ɵɵdirectiveInject(NbSpinnerService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbLayoutScrollService), ɵɵdirectiveInject(NbLayoutRulerService), ɵɵdirectiveInject(NbRestoreScrollTopHelper), ɵɵdirectiveInject(NbOverlayContainerAdapter));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbLayoutComponent,
      selectors: [["nb-layout"]],
      viewQuery: function NbLayoutComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c122, 5, ViewContainerRef);
          ɵɵviewQuery(_c132, 7, ElementRef);
          ɵɵviewQuery(_c14, 5, ElementRef);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.veryTopRef = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.scrollableContainerRef = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.layoutContainerRef = _t.first);
        }
      },
      hostVars: 6,
      hostBindings: function NbLayoutComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("scroll", function NbLayoutComponent_scroll_HostBindingHandler($event) {
            return ctx.onScroll($event);
          }, false, ɵɵresolveWindow)("resize", function NbLayoutComponent_resize_HostBindingHandler($event) {
            return ctx.onResize($event);
          }, false, ɵɵresolveWindow);
        }
        if (rf & 2) {
          ɵɵclassProp("window-mode", ctx.windowModeValue)("with-scroll", ctx.withScrollValue)("with-subheader", ctx.withSubheader);
        }
      },
      inputs: {
        center: "center",
        windowMode: "windowMode",
        withScroll: "withScroll",
        restoreScrollTop: "restoreScrollTop"
      },
      standalone: false,
      ngContentSelectors: _c16,
      decls: 12,
      vars: 2,
      consts: [["scrollableContainer", ""], ["layoutContainer", ""], [1, "scrollable-container", 3, "scroll"], [1, "layout"], [1, "layout-container"], [1, "content"], [1, "columns"]],
      template: function NbLayoutComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵprojectionDef(_c15);
          ɵɵelementStart(0, "div", 2, 0);
          ɵɵlistener("scroll", function NbLayoutComponent_Template_div_scroll_0_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.onScroll($event));
          });
          ɵɵelementStart(2, "div", 3, 1);
          ɵɵprojection(4);
          ɵɵelementStart(5, "div", 4);
          ɵɵprojection(6, 1);
          ɵɵelementStart(7, "div", 5);
          ɵɵprojection(8, 2);
          ɵɵelementStart(9, "div", 6);
          ɵɵprojection(10, 3);
          ɵɵelementEnd();
          ɵɵprojection(11, 4);
          ɵɵelementEnd()()()();
        }
        if (rf & 2) {
          ɵɵadvance(7);
          ɵɵclassProp("center", ctx.centerValue);
        }
      },
      styles: ["[_nghost-%COMP%]{-webkit-font-smoothing:antialiased}[dir=ltr]   [_nghost-%COMP%]{text-align:left}[dir=rtl]   [_nghost-%COMP%]{text-align:right}[_nghost-%COMP%]   .layout[_ngcontent-%COMP%]{display:flex;flex-direction:column}[_nghost-%COMP%]     nb-layout-header{display:block}[_nghost-%COMP%]     nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}[_nghost-%COMP%]     nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:2}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:2}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.end{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content.center[_ngcontent-%COMP%]{max-width:100%;position:relative;margin-left:auto;margin-right:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.start{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer{display:block;margin-top:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer nav{justify-content:center;display:flex}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout",
      template: `
    <div class="scrollable-container" #scrollableContainer (scroll)="onScroll($event)">
      <div class="layout" #layoutContainer>
        <ng-content select="nb-layout-header:not([subheader])"></ng-content>
        <div class="layout-container">
          <ng-content select="nb-sidebar"></ng-content>
          <div class="content" [class.center]="centerValue">
            <ng-content select="nb-layout-header[subheader]"></ng-content>
            <div class="columns">
              <ng-content select="nb-layout-column"></ng-content>
            </div>
            <ng-content select="nb-layout-footer"></ng-content>
          </div>
        </div>
      </div>
    </div>
  `,
      standalone: false,
      styles: [":host{-webkit-font-smoothing:antialiased}[dir=ltr] :host{text-align:left}[dir=rtl] :host{text-align:right}:host .layout{display:flex;flex-direction:column}:host ::ng-deep nb-layout-header{display:block}:host ::ng-deep nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}:host ::ng-deep nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}:host .layout-container{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.left{order:0}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.left{order:2}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.right{order:2}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.right{order:0}:host .layout-container ::ng-deep nb-sidebar.end{order:2}:host .layout-container ::ng-deep nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}:host .layout-container .content{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}:host .layout-container .content.center{max-width:100%;position:relative;margin-left:auto;margin-right:auto}:host .layout-container .content .columns{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}:host .layout-container .content .columns ::ng-deep nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:0}[dir=rtl] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:2}:host .layout-container .content .columns ::ng-deep nb-layout-column.start{order:0}:host .layout-container .content ::ng-deep nb-layout-footer{display:block;margin-top:auto}:host .layout-container .content ::ng-deep nb-layout-footer nav{justify-content:center;display:flex}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbThemeService
  }, {
    type: NbSpinnerService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbLayoutScrollService
  }, {
    type: NbLayoutRulerService
  }, {
    type: NbRestoreScrollTopHelper
  }, {
    type: NbOverlayContainerAdapter
  }], {
    windowModeValue: [{
      type: HostBinding,
      args: ["class.window-mode"]
    }],
    withScrollValue: [{
      type: HostBinding,
      args: ["class.with-scroll"]
    }],
    withSubheader: [{
      type: HostBinding,
      args: ["class.with-subheader"]
    }],
    center: [{
      type: Input
    }],
    windowMode: [{
      type: Input
    }],
    withScroll: [{
      type: Input
    }],
    restoreScrollTop: [{
      type: Input
    }],
    veryTopRef: [{
      type: ViewChild,
      args: ["layoutTopDynamicArea", {
        read: ViewContainerRef
      }]
    }],
    scrollableContainerRef: [{
      type: ViewChild,
      args: ["scrollableContainer", {
        read: ElementRef,
        static: true
      }]
    }],
    layoutContainerRef: [{
      type: ViewChild,
      args: ["layoutContainer", {
        read: ElementRef
      }]
    }],
    onScroll: [{
      type: HostListener,
      args: ["window:scroll", ["$event"]]
    }],
    onResize: [{
      type: HostListener,
      args: ["window:resize", ["$event"]]
    }]
  });
})();
var NbLayoutColumnComponent = class _NbLayoutColumnComponent {
  /**
   * Move the column to the very left position in the layout.
   * @param {boolean} val
   */
  set left(val) {
    this.leftValue = convertToBoolProperty(val);
    this.startValue = false;
  }
  /**
   * Make column first in the layout.
   * @param {boolean} val
   */
  set start(val) {
    this.startValue = convertToBoolProperty(val);
    this.leftValue = false;
  }
  static {
    this.ɵfac = function NbLayoutColumnComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbLayoutColumnComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbLayoutColumnComponent,
      selectors: [["nb-layout-column"]],
      hostVars: 4,
      hostBindings: function NbLayoutColumnComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("left", ctx.leftValue)("start", ctx.startValue);
        }
      },
      inputs: {
        left: "left",
        start: "start"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 1,
      vars: 0,
      template: function NbLayoutColumnComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵprojection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutColumnComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-column",
      template: `<ng-content></ng-content>`,
      standalone: false
    }]
  }], null, {
    leftValue: [{
      type: HostBinding,
      args: ["class.left"]
    }],
    startValue: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    left: [{
      type: Input
    }],
    start: [{
      type: Input
    }]
  });
})();
var NbLayoutHeaderComponent = class _NbLayoutHeaderComponent {
  constructor(layout) {
    this.layout = layout;
  }
  /**
   * Makes the header sticky to the top of the nb-layout.
   * @param {boolean} val
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
  /**
   * Places header on a side of the sidebar, and not above.
   * Disables fixed mode for this header and remove a shadow from the sidebar.
   * @param {boolean} val
   */
  set subheader(val) {
    this.subheaderValue = convertToBoolProperty(val);
    this.fixedValue = false;
    this.layout.withSubheader = this.subheaderValue;
  }
  static {
    this.ɵfac = function NbLayoutHeaderComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbLayoutHeaderComponent)(ɵɵdirectiveInject(NbLayoutComponent));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbLayoutHeaderComponent,
      selectors: [["nb-layout-header"]],
      hostVars: 4,
      hostBindings: function NbLayoutHeaderComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("fixed", ctx.fixedValue)("subheader", ctx.subheaderValue);
        }
      },
      inputs: {
        fixed: "fixed",
        subheader: "subheader"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 2,
      vars: 2,
      template: function NbLayoutHeaderComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵelementStart(0, "nav");
          ɵɵprojection(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵclassProp("fixed", ctx.fixedValue);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-header",
      template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `,
      standalone: false
    }]
  }], () => [{
    type: NbLayoutComponent
  }], {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    subheaderValue: [{
      type: HostBinding,
      args: ["class.subheader"]
    }],
    fixed: [{
      type: Input
    }],
    subheader: [{
      type: Input
    }]
  });
})();
var NbLayoutFooterComponent = class _NbLayoutFooterComponent {
  /**
   * Makes the footer sticky to the bottom of the window.
   * @param {boolean} val
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
  static {
    this.ɵfac = function NbLayoutFooterComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbLayoutFooterComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbLayoutFooterComponent,
      selectors: [["nb-layout-footer"]],
      hostVars: 2,
      hostBindings: function NbLayoutFooterComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("fixed", ctx.fixedValue);
        }
      },
      inputs: {
        fixed: "fixed"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 2,
      vars: 2,
      template: function NbLayoutFooterComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵelementStart(0, "nav");
          ɵɵprojection(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵclassProp("fixed", ctx.fixedValue);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-footer",
      template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `,
      standalone: false
    }]
  }], null, {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    fixed: [{
      type: Input
    }]
  });
})();
var NbBaseLayoutDirectionDirective = class _NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService, directionToShow) {
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
    this.directionToShow = directionToShow;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.directionService.onDirectionChange().pipe(map((layoutDirection) => layoutDirection === this.directionToShow), distinctUntilChanged(), takeUntil(this.destroy$)).subscribe((shouldShow) => this.updateView(shouldShow));
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  updateView(shouldShow) {
    if (shouldShow && !this.viewContainer.length) {
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.cd.markForCheck();
    } else if (!shouldShow && this.viewContainer.length) {
      this.viewContainer.clear();
    }
  }
  static {
    this.ɵfac = function NbBaseLayoutDirectionDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbBaseLayoutDirectionDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbLayoutDirection));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbBaseLayoutDirectionDirective
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseLayoutDirectionDirective, [{
    type: Directive
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbLayoutDirection
  }], null);
})();
var NbLtrDirective = class _NbLtrDirective extends NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService) {
    super(templateRef, viewContainer, cd, directionService, NbLayoutDirection.LTR);
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
  }
  static {
    this.ɵfac = function NbLtrDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbLtrDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbLtrDirective,
      selectors: [["", "nbLtr", ""]],
      standalone: false,
      features: [ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLtrDirective, [{
    type: Directive,
    args: [{
      selector: "[nbLtr]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var NbRtlDirective = class _NbRtlDirective extends NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService) {
    super(templateRef, viewContainer, cd, directionService, NbLayoutDirection.RTL);
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
  }
  static {
    this.ɵfac = function NbRtlDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbRtlDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbRtlDirective,
      selectors: [["", "nbRtl", ""]],
      standalone: false,
      features: [ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRtlDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRtl]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var NB_LAYOUT_COMPONENTS = [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent];
var NB_LAYOUT_DIRECTIVES = [NbLtrDirective, NbRtlDirective];
var NbLayoutModule = class _NbLayoutModule {
  static {
    this.ɵfac = function NbLayoutModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbLayoutModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbLayoutModule,
      declarations: [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent, NbLtrDirective, NbRtlDirective],
      imports: [NbSharedModule],
      exports: [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent, NbLtrDirective, NbRtlDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [NbRestoreScrollTopHelper],
      imports: [NbSharedModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_LAYOUT_COMPONENTS, ...NB_LAYOUT_DIRECTIVES],
      providers: [NbRestoreScrollTopHelper],
      exports: [...NB_LAYOUT_COMPONENTS, ...NB_LAYOUT_DIRECTIVES]
    }]
  }], null, null);
})();
var itemClick$ = new Subject();
var addItems$ = new ReplaySubject(1);
var navigateHome$ = new ReplaySubject(1);
var getSelectedItem$ = new ReplaySubject(1);
var itemSelect$ = new ReplaySubject(1);
var itemHover$ = new ReplaySubject(1);
var submenuToggle$ = new ReplaySubject(1);
var collapseAll$ = new ReplaySubject(1);
var NbMenuItem = class {
  constructor() {
    this.pathMatch = "full";
  }
  /**
   * @returns item parents in top-down order
   */
  static getParents(item) {
    const parents = [];
    let parent = item.parent;
    while (parent) {
      parents.unshift(parent);
      parent = parent.parent;
    }
    return parents;
  }
  static isParent(item, possibleChild) {
    return possibleChild.parent ? possibleChild.parent === item || this.isParent(item, possibleChild.parent) : false;
  }
};
var NbMenuService = class _NbMenuService {
  /**
   * Add items to the end of the menu items list
   * @param {List<NbMenuItem>} items
   * @param {string} tag
   */
  addItems(items, tag) {
    addItems$.next({
      tag,
      items
    });
  }
  /**
   * Collapses all menu items
   * @param {string} tag
   */
  collapseAll(tag) {
    collapseAll$.next({
      tag
    });
  }
  /**
   * Navigate to the home menu item
   * @param {string} tag
   */
  navigateHome(tag) {
    navigateHome$.next({
      tag
    });
  }
  /**
   * Returns currently selected item. Won't subscribe to the future events.
   * @param {string} tag
   * @returns {Observable<{tag: string; item: NbMenuItem}>}
   */
  getSelectedItem(tag) {
    const listener = new BehaviorSubject(null);
    getSelectedItem$.next({
      tag,
      listener
    });
    return listener.asObservable();
  }
  onItemClick() {
    return itemClick$.pipe(share());
  }
  onItemSelect() {
    return itemSelect$.pipe(share());
  }
  onItemHover() {
    return itemHover$.pipe(share());
  }
  onSubmenuToggle() {
    return submenuToggle$.pipe(share());
  }
  static {
    this.ɵfac = function NbMenuService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbMenuService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbMenuService,
      factory: _NbMenuService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuService, [{
    type: Injectable
  }], null, null);
})();
var NbMenuInternalService = class _NbMenuInternalService {
  constructor(location) {
    this.location = location;
  }
  prepareItems(items) {
    const defaultItem = new NbMenuItem();
    items.forEach((i) => {
      this.applyDefaults(i, defaultItem);
      this.setParent(i);
    });
  }
  selectFromUrl(items, tag, collapseOther = false) {
    const selectedItem = this.findItemByUrl(items);
    if (selectedItem) {
      this.selectItem(selectedItem, items, collapseOther, tag);
    }
  }
  selectItem(item, items, collapseOther = false, tag) {
    const unselectedItems = this.resetSelection(items);
    const collapsedItems = collapseOther ? this.collapseItems(items) : [];
    for (const parent of NbMenuItem.getParents(item)) {
      parent.selected = true;
      if (!unselectedItems.includes(parent)) {
        this.itemSelect(parent, tag);
      }
      const wasNotExpanded = !parent.expanded;
      parent.expanded = true;
      const i = collapsedItems.indexOf(parent);
      if (i === -1 && wasNotExpanded) {
        this.submenuToggle(parent, tag);
      } else {
        collapsedItems.splice(i, 1);
      }
    }
    item.selected = true;
    if (!unselectedItems.includes(item)) {
      this.itemSelect(item, tag);
    }
    for (const collapsedItem of collapsedItems) {
      this.submenuToggle(collapsedItem, tag);
    }
  }
  collapseAll(items, tag, except) {
    const collapsedItems = this.collapseItems(items, except);
    for (const item of collapsedItems) {
      this.submenuToggle(item, tag);
    }
  }
  onAddItem() {
    return addItems$.pipe(share());
  }
  onNavigateHome() {
    return navigateHome$.pipe(share());
  }
  onCollapseAll() {
    return collapseAll$.pipe(share());
  }
  onGetSelectedItem() {
    return getSelectedItem$.pipe(share());
  }
  itemHover(item, tag) {
    itemHover$.next({
      tag,
      item
    });
  }
  submenuToggle(item, tag) {
    submenuToggle$.next({
      tag,
      item
    });
  }
  itemSelect(item, tag) {
    itemSelect$.next({
      tag,
      item
    });
  }
  itemClick(item, tag) {
    itemClick$.next({
      tag,
      item
    });
  }
  /**
   * Unselect all given items deeply.
   * @param items array of items to unselect.
   * @returns items which selected value was changed.
   */
  resetSelection(items) {
    const unselectedItems = [];
    for (const item of items) {
      if (item.selected) {
        unselectedItems.push(item);
      }
      item.selected = false;
      if (item.children) {
        unselectedItems.push(...this.resetSelection(item.children));
      }
    }
    return unselectedItems;
  }
  /**
   * Collapse all given items deeply.
   * @param items array of items to collapse.
   * @param except menu item which shouldn't be collapsed, also disables collapsing for parents of this item.
   * @returns items which expanded value was changed.
   */
  collapseItems(items, except) {
    const collapsedItems = [];
    for (const item of items) {
      if (except && (item === except || NbMenuItem.isParent(item, except))) {
        continue;
      }
      if (item.expanded) {
        collapsedItems.push(item);
      }
      item.expanded = false;
      if (item.children) {
        collapsedItems.push(...this.collapseItems(item.children));
      }
    }
    return collapsedItems;
  }
  applyDefaults(item, defaultItem) {
    const menuItem = __spreadValues({}, item);
    Object.assign(item, defaultItem, menuItem);
    item.children && item.children.forEach((child) => {
      this.applyDefaults(child, defaultItem);
    });
  }
  setParent(item) {
    item.children && item.children.forEach((child) => {
      child.parent = item;
      this.setParent(child);
    });
  }
  /**
   * Find deepest item which link matches current URL path.
   * @param items array of items to search in.
   * @returns found item of undefined.
   */
  findItemByUrl(items) {
    let selectedItem;
    items.some((item) => {
      if (item.children) {
        selectedItem = this.findItemByUrl(item.children);
      }
      if (!selectedItem && this.isSelectedInUrl(item)) {
        selectedItem = item;
      }
      return selectedItem;
    });
    return selectedItem;
  }
  isSelectedInUrl(item) {
    const exact = item.pathMatch === "full";
    const link = item.link;
    const isSelectedInPath = exact ? isUrlPathEqual(this.location.path(), link) : isUrlPathContain(this.location.path(), link);
    if (isSelectedInPath && item.fragment != null) {
      return exact ? isFragmentEqual(this.location.path(true), item.fragment) : isFragmentContain(this.location.path(true), item.fragment);
    }
    return isSelectedInPath;
  }
  static {
    this.ɵfac = function NbMenuInternalService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbMenuInternalService)(ɵɵinject(Location));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbMenuInternalService,
      factory: _NbMenuInternalService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuInternalService, [{
    type: Injectable
  }], () => [{
    type: Location
  }], null);
})();
var NbBadgeComponent = class _NbBadgeComponent {
  /**
   * Badge position
   *
   * Can be set to any class or to one of predefined positions:
   * 'top left', 'top right', 'bottom left', 'bottom right',
   * 'top start', 'top end', 'bottom start', 'bottom end'
   * @type string
   */
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value || this._defaultPosition;
  }
  /**
   * Shows badge as a dot. No text is shown.
   * @type boolean
   */
  get dotMode() {
    return this._dotMode;
  }
  set dotMode(value) {
    this._dotMode = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get top() {
    return this.position.includes("top");
  }
  get right() {
    return this.position.includes("right");
  }
  get bottom() {
    return this.position.includes("bottom");
  }
  get left() {
    return this.position.includes("left");
  }
  get start() {
    return this.position.includes("start");
  }
  get end() {
    return this.position.includes("end");
  }
  get center() {
    return this.position.includes("center");
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.text = "";
    this._defaultPosition = "top right";
    this._position = this._defaultPosition;
    this.status = "basic";
  }
  static {
    this.ɵfac = function NbBadgeComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbBadgeComponent)(ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbBadgeComponent,
      selectors: [["nb-badge"]],
      hostVars: 32,
      hostBindings: function NbBadgeComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("dot-mode", ctx.dotMode)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("position-top", ctx.top)("position-right", ctx.right)("position-bottom", ctx.bottom)("position-left", ctx.left)("position-start", ctx.start)("position-end", ctx.end)("position-center", ctx.center);
        }
      },
      inputs: {
        text: "text",
        position: "position",
        dotMode: "dotMode",
        status: "status"
      },
      standalone: false,
      decls: 1,
      vars: 1,
      template: function NbBadgeComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtext(0);
        }
        if (rf & 2) {
          ɵɵtextInterpolate(ctx.dotMode ? "" : ctx.text);
        }
      },
      styles: ["[_nghost-%COMP%]{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}.position-top[_nghost-%COMP%]{top:0}.position-right[_nghost-%COMP%]{right:0}.position-bottom[_nghost-%COMP%]{bottom:0}.position-left[_nghost-%COMP%]{left:0}.position-center[_nghost-%COMP%]{top:50%;transform:translateY(-50%)}[dir=ltr]   .position-start[_nghost-%COMP%]{left:0}[dir=rtl]   .position-start[_nghost-%COMP%]{right:0}[dir=ltr]   .position-end[_nghost-%COMP%]{right:0}[dir=rtl]   .position-end[_nghost-%COMP%]{left:0}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBadgeComponent, [{
    type: Component,
    args: [{
      selector: "nb-badge",
      template: `{{dotMode ? '' : text}}`,
      standalone: false,
      styles: [":host{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}:host(.position-top){top:0}:host(.position-right){right:0}:host(.position-bottom){bottom:0}:host(.position-left){left:0}:host(.position-center){top:50%;transform:translateY(-50%)}[dir=ltr] :host(.position-start){left:0}[dir=rtl] :host(.position-start){right:0}[dir=ltr] :host(.position-end){right:0}[dir=rtl] :host(.position-end){left:0}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    text: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    dotMode: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.dot-mode"]
    }],
    status: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    top: [{
      type: HostBinding,
      args: ["class.position-top"]
    }],
    right: [{
      type: HostBinding,
      args: ["class.position-right"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.position-bottom"]
    }],
    left: [{
      type: HostBinding,
      args: ["class.position-left"]
    }],
    start: [{
      type: HostBinding,
      args: ["class.position-start"]
    }],
    end: [{
      type: HostBinding,
      args: ["class.position-end"]
    }],
    center: [{
      type: HostBinding,
      args: ["class.position-center"]
    }]
  });
})();
var NbToggleStates;
(function(NbToggleStates2) {
  NbToggleStates2["Expanded"] = "expanded";
  NbToggleStates2["Collapsed"] = "collapsed";
})(NbToggleStates || (NbToggleStates = {}));
var NbMenuItemComponent = class _NbMenuItemComponent {
  constructor(menuService, directionService) {
    this.menuService = menuService;
    this.directionService = directionService;
    this.menuItem = null;
    this.hoverItem = new EventEmitter();
    this.toggleSubMenu = new EventEmitter();
    this.selectItem = new EventEmitter();
    this.itemClick = new EventEmitter();
    this.destroy$ = new Subject();
  }
  ngDoCheck() {
    this.toggleState = this.menuItem.expanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed;
  }
  ngAfterViewInit() {
    this.menuService.onSubmenuToggle().pipe(filter(({
      item
    }) => item === this.menuItem), map(({
      item
    }) => item.expanded), takeUntil(this.destroy$)).subscribe((isExpanded) => this.toggleState = isExpanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  onToggleSubMenu(item) {
    this.toggleSubMenu.emit(item);
  }
  onHoverItem(item) {
    this.hoverItem.emit(item);
  }
  onSelectItem(item) {
    this.selectItem.emit(item);
  }
  onItemClick(item) {
    this.itemClick.emit(item);
  }
  getExpandStateIcon() {
    if (this.menuItem.expanded) {
      return "chevron-down-outline";
    }
    return this.directionService.isLtr() ? "chevron-left-outline" : "chevron-right-outline";
  }
  static {
    this.ɵfac = function NbMenuItemComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbMenuItemComponent)(ɵɵdirectiveInject(NbMenuService), ɵɵdirectiveInject(NbLayoutDirectionService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbMenuItemComponent,
      selectors: [["", "nbMenuItem", ""]],
      inputs: {
        menuItem: "menuItem",
        badge: "badge"
      },
      outputs: {
        hoverItem: "hoverItem",
        toggleSubMenu: "toggleSubMenu",
        selectItem: "selectItem",
        itemClick: "itemClick"
      },
      standalone: false,
      attrs: _c17,
      decls: 8,
      vars: 6,
      consts: [["badgeTemplate", ""], [4, "ngIf"], [3, "routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "active", "mouseenter", "click", 4, "ngIf"], [3, "active", "mouseenter", "click", 4, "ngIf"], ["href", "#", 3, "active", "click", "mouseenter", 4, "ngIf"], ["class", "menu-items", 3, "collapsed", "expanded", 4, "ngIf"], ["class", "menu-icon", 3, "config", 4, "ngIf"], [1, "menu-icon", 3, "config"], [3, "mouseenter", "click", "routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange"], [1, "menu-title"], [3, "ngTemplateOutlet", 4, "ngIf"], [3, "ngTemplateOutlet"], [3, "mouseenter", "click"], ["href", "#", 3, "click", "mouseenter"], ["pack", "nebular-essentials", 1, "expand-state", 3, "icon"], [1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "badge", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "hoverItem", "toggleSubMenu", "selectItem", "itemClick", "menuItem", "badge"], [3, "text", "dotMode", "status"]],
      template: function NbMenuItemComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbMenuItemComponent_span_0_Template, 3, 2, "span", 1)(1, NbMenuItemComponent_a_1_Template, 5, 14, "a", 2)(2, NbMenuItemComponent_a_2_Template, 5, 9, "a", 3)(3, NbMenuItemComponent_a_3_Template, 5, 8, "a", 3)(4, NbMenuItemComponent_a_4_Template, 6, 10, "a", 4)(5, NbMenuItemComponent_ul_5_Template, 2, 6, "ul", 5)(6, NbMenuItemComponent_ng_template_6_Template, 1, 3, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.menuItem.group);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.group);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.group);
          ɵɵadvance();
          ɵɵproperty("ngIf", !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.group);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.menuItem.children);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.menuItem.children);
        }
      },
      dependencies: [NgForOf, NgIf, NgTemplateOutlet, RouterLink, NbIconComponent, NbBadgeComponent, _NbMenuItemComponent],
      encapsulation: 2,
      data: {
        animation: [trigger("toggle", [state(NbToggleStates.Collapsed, style({
          height: "0",
          margin: "0"
        })), state(NbToggleStates.Expanded, style({
          height: "*"
        })), transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300))])]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuItemComponent, [{
    type: Component,
    args: [{
      selector: "[nbMenuItem]",
      animations: [trigger("toggle", [state(NbToggleStates.Collapsed, style({
        height: "0",
        margin: "0"
      })), state(NbToggleStates.Expanded, style({
        height: "*"
      })), transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300))])],
      standalone: false,
      template: '<span *ngIf="menuItem.group">\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  {{ menuItem.title }}\n</span>\n<a\n  *ngIf="menuItem.link && !menuItem.url && !menuItem.children && !menuItem.group"\n  [routerLink]="menuItem.link"\n  [queryParams]="menuItem.queryParams"\n  [fragment]="menuItem.fragment"\n  [queryParamsHandling]="menuItem.queryParamsHandling"\n  [preserveFragment]="menuItem.preserveFragment"\n  [skipLocationChange]="menuItem.skipLocationChange"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="onItemClick(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="menuItem.url && !menuItem.children && !menuItem.link && !menuItem.group"\n  [attr.href]="menuItem.url"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="onSelectItem(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="!menuItem.children && !menuItem.link && !menuItem.url && !menuItem.group"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="$event.preventDefault(); onItemClick(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="menuItem.children"\n  (click)="$event.preventDefault(); onToggleSubMenu(menuItem)"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.aria-expanded]="menuItem.expanded ?? false"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  href="#"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n  <nb-icon class="expand-state" [icon]="getExpandStateIcon()" pack="nebular-essentials"></nb-icon>\n</a>\n<ul\n  *ngIf="menuItem.children"\n  [class.collapsed]="!(menuItem.children && menuItem.expanded)"\n  [class.expanded]="menuItem.expanded"\n  [@toggle]="toggleState"\n  class="menu-items"\n>\n  <ng-container *ngFor="let item of menuItem.children">\n    <li\n      nbMenuItem\n      *ngIf="!item.hidden"\n      [menuItem]="item"\n      [badge]="item.badge"\n      [class.menu-group]="item.group"\n      (hoverItem)="onHoverItem($event)"\n      (toggleSubMenu)="onToggleSubMenu($event)"\n      (selectItem)="onSelectItem($event)"\n      (itemClick)="onItemClick($event)"\n      class="menu-item"\n    ></li>\n  </ng-container>\n</ul>\n\n<ng-template #badgeTemplate>\n  <nb-badge [text]="badge.text" [dotMode]="badge.dotMode" [status]="badge.status"> </nb-badge>\n</ng-template>\n'
    }]
  }], () => [{
    type: NbMenuService
  }, {
    type: NbLayoutDirectionService
  }], {
    menuItem: [{
      type: Input
    }],
    badge: [{
      type: Input
    }],
    hoverItem: [{
      type: Output
    }],
    toggleSubMenu: [{
      type: Output
    }],
    selectItem: [{
      type: Output
    }],
    itemClick: [{
      type: Output
    }]
  });
})();
var NbMenuComponent = class _NbMenuComponent {
  /**
   * Collapse all opened submenus on the toggle event
   * Default value is "false"
   * @type boolean
   */
  get autoCollapse() {
    return this._autoCollapse;
  }
  set autoCollapse(value) {
    this._autoCollapse = convertToBoolProperty(value);
  }
  constructor(window2, platformId, menuInternalService, router) {
    this.window = window2;
    this.platformId = platformId;
    this.menuInternalService = menuInternalService;
    this.router = router;
    this._autoCollapse = false;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.menuInternalService.prepareItems(this.items);
    this.menuInternalService.onAddItem().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe((data) => this.onAddItem(data));
    this.menuInternalService.onNavigateHome().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe(() => this.navigateHome());
    this.menuInternalService.onGetSelectedItem().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe((data) => {
      data.listener.next({
        tag: this.tag,
        item: this.getSelectedItem(this.items)
      });
    });
    this.menuInternalService.onCollapseAll().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe(() => this.collapseAll());
    this.router.events.pipe(filter((event) => event instanceof NavigationEnd), takeUntil(this.destroy$)).subscribe(() => {
      this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
    });
  }
  ngAfterViewInit() {
    setTimeout(() => this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse));
  }
  onAddItem(data) {
    this.items.push(...data.items);
    this.menuInternalService.prepareItems(this.items);
    this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
  }
  onHoverItem(item) {
    this.menuInternalService.itemHover(item, this.tag);
  }
  onToggleSubMenu(item) {
    if (this.autoCollapse) {
      this.menuInternalService.collapseAll(this.items, this.tag, item);
    }
    item.expanded = !item.expanded;
    this.menuInternalService.submenuToggle(item, this.tag);
  }
  // TODO: is not fired on page reload
  onSelectItem(item) {
    this.menuInternalService.selectItem(item, this.items, this.autoCollapse, this.tag);
  }
  onItemClick(item) {
    this.menuInternalService.itemClick(item, this.tag);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  navigateHome() {
    const homeItem = this.getHomeItem(this.items);
    if (homeItem) {
      if (homeItem.link) {
        const extras = {
          queryParams: homeItem.queryParams,
          queryParamsHandling: homeItem.queryParamsHandling,
          fragment: homeItem.fragment,
          preserveFragment: homeItem.preserveFragment
        };
        this.router.navigate([homeItem.link], extras);
      }
      if (homeItem.url && isPlatformBrowser(this.platformId)) {
        this.window.location.href = homeItem.url;
      }
    }
  }
  collapseAll() {
    this.menuInternalService.collapseAll(this.items, this.tag);
  }
  getHomeItem(items) {
    for (const item of items) {
      if (item.home) {
        return item;
      }
      const homeItem = item.children && this.getHomeItem(item.children);
      if (homeItem) {
        return homeItem;
      }
    }
    return void 0;
  }
  compareTag(tag) {
    return !tag || tag === this.tag;
  }
  getSelectedItem(items) {
    let selected = null;
    items.forEach((item) => {
      if (item.selected) {
        selected = item;
      }
      if (item.selected && item.children && item.children.length > 0) {
        selected = this.getSelectedItem(item.children);
      }
    });
    return selected;
  }
  static {
    this.ɵfac = function NbMenuComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbMenuComponent)(ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NbMenuInternalService), ɵɵdirectiveInject(Router));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbMenuComponent,
      selectors: [["nb-menu"]],
      inputs: {
        tag: "tag",
        items: "items",
        autoCollapse: "autoCollapse"
      },
      standalone: false,
      decls: 2,
      vars: 1,
      consts: [[1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "badge", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "hoverItem", "toggleSubMenu", "selectItem", "itemClick", "menuItem", "badge"]],
      template: function NbMenuComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "ul", 0);
          ɵɵtemplate(1, NbMenuComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("ngForOf", ctx.items);
        }
      },
      dependencies: [NgForOf, NgIf, NbMenuItemComponent],
      styles: ["[_nghost-%COMP%]    {display:block}[_nghost-%COMP%]     .menu-items, [_nghost-%COMP%]     .menu-item>.menu-items{list-style-type:none;overflow:hidden}[_nghost-%COMP%]     .menu-item a{display:flex;text-decoration:none;align-items:center}[_nghost-%COMP%]     .menu-item a .menu-title{flex:1 0 auto;pointer-events:none}[dir=rtl]   [_nghost-%COMP%]     .menu-item a .menu-title{text-align:right}[_nghost-%COMP%]     .menu-item nb-badge{position:static}[_nghost-%COMP%]     .menu-group span{display:flex}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuComponent, [{
    type: Component,
    args: [{
      selector: "nb-menu",
      template: `
    <ul class="menu-items">
      <ng-container *ngFor="let item of items">
        <li nbMenuItem *ngIf="!item.hidden"
            [menuItem]="item"
            [badge]="item.badge"
            [class.menu-group]="item.group"
            (hoverItem)="onHoverItem($event)"
            (toggleSubMenu)="onToggleSubMenu($event)"
            (selectItem)="onSelectItem($event)"
            (itemClick)="onItemClick($event)"
            class="menu-item">
        </li>
      </ng-container>
    </ul>
  `,
      standalone: false,
      styles: [":host ::ng-deep{display:block}:host ::ng-deep .menu-items,:host ::ng-deep .menu-item>.menu-items{list-style-type:none;overflow:hidden}:host ::ng-deep .menu-item a{display:flex;text-decoration:none;align-items:center}:host ::ng-deep .menu-item a .menu-title{flex:1 0 auto;pointer-events:none}[dir=rtl] :host ::ng-deep .menu-item a .menu-title{text-align:right}:host ::ng-deep .menu-item nb-badge{position:static}:host ::ng-deep .menu-group span{display:flex}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NbMenuInternalService
  }, {
    type: Router
  }], {
    tag: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    autoCollapse: [{
      type: Input
    }]
  });
})();
var NbBadgeModule = class _NbBadgeModule {
  static {
    this.ɵfac = function NbBadgeModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbBadgeModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbBadgeModule,
      declarations: [NbBadgeComponent],
      exports: [NbBadgeComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBadgeModule, [{
    type: NgModule,
    args: [{
      exports: [NbBadgeComponent],
      declarations: [NbBadgeComponent]
    }]
  }], null, null);
})();
var nbMenuComponents = [NbMenuComponent, NbMenuItemComponent];
var NB_MENU_PROVIDERS = [NbMenuService, NbMenuInternalService];
var NbMenuModule = class _NbMenuModule {
  static forRoot() {
    return {
      ngModule: _NbMenuModule,
      providers: [...NB_MENU_PROVIDERS]
    };
  }
  static {
    this.ɵfac = function NbMenuModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbMenuModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbMenuModule,
      declarations: [NbMenuComponent, NbMenuItemComponent],
      imports: [NbSharedModule, NbIconModule, NbBadgeModule],
      exports: [NbMenuComponent, NbMenuItemComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbIconModule, NbBadgeModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule, NbBadgeModule],
      declarations: [...nbMenuComponents],
      exports: [...nbMenuComponents]
    }]
  }], null, null);
})();
var NbMergeConfigsPipe = class _NbMergeConfigsPipe {
  transform(...configs) {
    return Object.assign({}, ...configs);
  }
  static {
    this.ɵfac = function NbMergeConfigsPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbMergeConfigsPipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "nbMergeConfigs",
      type: _NbMergeConfigsPipe,
      pure: true,
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMergeConfigsPipe, [{
    type: Pipe,
    args: [{
      name: "nbMergeConfigs",
      standalone: false
    }]
  }], null, null);
})();
var NbRouteTabsetComponent = class _NbRouteTabsetComponent {
  constructor() {
    this.fullWidthValue = false;
    this.activeLinkOptions = {
      exact: true
    };
    this.changeTab = new EventEmitter();
  }
  /**
   * Take full width of a parent
   * @param {boolean} val
   */
  set fullWidth(val) {
    this.fullWidthValue = convertToBoolProperty(val);
  }
  selectTab(tab) {
    this.changeTab.emit(tab);
  }
  static {
    this.ɵfac = function NbRouteTabsetComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbRouteTabsetComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbRouteTabsetComponent,
      selectors: [["nb-route-tabset"]],
      hostVars: 2,
      hostBindings: function NbRouteTabsetComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("full-width", ctx.fullWidthValue);
        }
      },
      inputs: {
        tabs: "tabs",
        activeLinkOptions: "activeLinkOptions",
        fullWidth: "fullWidth"
      },
      outputs: {
        changeTab: "changeTab"
      },
      standalone: false,
      decls: 3,
      vars: 1,
      consts: [["enabled", ""], [1, "route-tabset"], [4, "ngFor", "ngForOf"], ["class", "route-tab disabled", "tabindex", "-1", 3, "responsive", 4, "ngIf", "ngIfElse"], ["tabindex", "-1", 1, "route-tab", "disabled"], ["tabindex", "-1", 1, "tab-link"], [3, "config", 4, "ngIf"], ["class", "tab-text", 4, "ngIf"], [3, "config"], [1, "tab-text"], ["routerLinkActive", "active", 1, "route-tab", 3, "routerLinkActiveOptions"], [1, "tab-link", 3, "click", "routerLink", "queryParams", "queryParamsHandling", "fragment", "preserveFragment", "skipLocationChange", "replaceUrl", "state"]],
      template: function NbRouteTabsetComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "ul", 1);
          ɵɵtemplate(1, NbRouteTabsetComponent_ng_container_1_Template, 4, 2, "ng-container", 2);
          ɵɵelementEnd();
          ɵɵelement(2, "router-outlet");
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("ngForOf", ctx.tabs);
        }
      },
      dependencies: [NgForOf, NgIf, RouterOutlet, RouterLink, RouterLinkActive, NbIconComponent, NbMergeConfigsPipe],
      styles: ['.route-tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;padding:0}.route-tabset[_ngcontent-%COMP%]   .route-tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{display:block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{position:relative;text-decoration:none;display:inline-block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr]   [_nghost-%COMP%]   .tab-link[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .tab-link[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}.full-width[_nghost-%COMP%]   .route-tabset[_ngcontent-%COMP%]{justify-content:space-around}\n\n\n\n\n\n']
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRouteTabsetComponent, [{
    type: Component,
    args: [{
      selector: "nb-route-tabset",
      template: `
    <ul class="route-tabset">
      <ng-container *ngFor="let tab of tabs">
        <li
          *ngIf="tab.disabled; else enabled"
          [class.responsive]="tab.responsive"
          class="route-tab disabled"
          tabindex="-1"
        >
          <a tabindex="-1" class="tab-link">
            <nb-icon *ngIf="tab.icon" [config]="tab.icon"></nb-icon>
            <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
          </a>
        </li>

        <ng-template #enabled>
          <li
            routerLinkActive="active"
            [routerLinkActiveOptions]="activeLinkOptions | nbMergeConfigs: tab.activeLinkOptions"
            class="route-tab"
          >
            <a
              (click)="selectTab(tab)"
              [routerLink]="tab.route"
              [class.responsive]="tab.responsive"
              [queryParams]="tab.queryParams"
              [queryParamsHandling]="tab.queryParamsHandling"
              [fragment]="tab.fragment"
              [preserveFragment]="tab.preserveFragment"
              [skipLocationChange]="tab.skipLocationChange"
              [replaceUrl]="tab.replaceUrl"
              [state]="tab.state"
              class="tab-link"
            >
              <nb-icon *ngIf="tab.icon" [config]="tab.icon"></nb-icon>
              <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
            </a>
          </li>
        </ng-template>
      </ng-container>
    </ul>
    <router-outlet></router-outlet>
  `,
      standalone: false,
      styles: ['.route-tabset{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}.route-tabset .route-tab{margin-bottom:-1px;text-align:center;padding:0}.route-tabset .route-tab.active a:before{display:block}.route-tabset .route-tab a{position:relative;text-decoration:none;display:inline-block}.route-tabset .route-tab a:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset .route-tab a nb-icon{vertical-align:middle}[dir=ltr] :host .tab-link nb-icon+span{margin-left:.5rem}[dir=rtl] :host .tab-link nb-icon+span{margin-right:.5rem}:host(.full-width) .route-tabset{justify-content:space-around}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n']
    }]
  }], null, {
    fullWidthValue: [{
      type: HostBinding,
      args: ["class.full-width"]
    }],
    tabs: [{
      type: Input
    }],
    activeLinkOptions: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }],
    changeTab: [{
      type: Output
    }]
  });
})();
var NbRouteTabsetModule = class _NbRouteTabsetModule {
  static {
    this.ɵfac = function NbRouteTabsetModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbRouteTabsetModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbRouteTabsetModule,
      declarations: [NbRouteTabsetComponent, NbMergeConfigsPipe],
      imports: [NbSharedModule, NbIconModule],
      exports: [NbRouteTabsetComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRouteTabsetModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbRouteTabsetComponent, NbMergeConfigsPipe],
      exports: [NbRouteTabsetComponent]
    }]
  }], null, null);
})();
var getSidebarState$ = new Subject();
var getSidebarResponsiveState$ = new Subject();
var NbSidebarService = class _NbSidebarService {
  constructor() {
    this.toggle$ = new Subject();
    this.expand$ = new Subject();
    this.collapse$ = new Subject();
    this.compact$ = new Subject();
  }
  /**
   * Subscribe to toggle events
   *
   * @returns Observable<{ compact: boolean, tag: string }>
   */
  onToggle() {
    return this.toggle$.pipe(share());
  }
  /**
   * Subscribe to expand events
   * @returns Observable<{ tag: string }>
   */
  onExpand() {
    return this.expand$.pipe(share());
  }
  /**
   * Subscribe to collapse evens
   * @returns Observable<{ tag: string }>
   */
  onCollapse() {
    return this.collapse$.pipe(share());
  }
  /**
   * Subscribe to compact evens
   * @returns Observable<{ tag: string }>
   */
  onCompact() {
    return this.compact$.pipe(share());
  }
  /**
   * Toggle a sidebar
   * @param {boolean} compact
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  toggle(compact = false, tag) {
    this.toggle$.next({
      compact,
      tag
    });
  }
  /**
   * Expands a sidebar
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  expand(tag) {
    this.expand$.next({
      tag
    });
  }
  /**
   * Collapses a sidebar
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  collapse(tag) {
    this.collapse$.next({
      tag
    });
  }
  /**
   * Makes sidebar compact
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  compact(tag) {
    this.compact$.next({
      tag
    });
  }
  /**
   * Returns sidebar state observable which emits once
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar state you need
   */
  getSidebarState(tag) {
    const observer = new ReplaySubject(1);
    getSidebarState$.next({
      observer,
      tag
    });
    return observer.pipe(publish(), refCount());
  }
  /**
   * Returns sidebar state observable which emits once
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar responsive state you need
   */
  getSidebarResponsiveState(tag) {
    const observer = new ReplaySubject();
    getSidebarResponsiveState$.next({
      observer,
      tag
    });
    return observer.pipe(publish(), refCount());
  }
  static {
    this.ɵfac = function NbSidebarService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSidebarService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbSidebarService,
      factory: _NbSidebarService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarService, [{
    type: Injectable
  }], null, null);
})();
var NbSidebarHeaderComponent = class _NbSidebarHeaderComponent {
  static {
    this.ɵfac = function NbSidebarHeaderComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSidebarHeaderComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbSidebarHeaderComponent,
      selectors: [["nb-sidebar-header"]],
      standalone: false,
      ngContentSelectors: _c03,
      decls: 1,
      vars: 0,
      template: function NbSidebarHeaderComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵprojection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar-header",
      template: ` <ng-content></ng-content> `,
      standalone: false
    }]
  }], null, null);
})();
var NbSidebarFooterComponent = class _NbSidebarFooterComponent {
  static {
    this.ɵfac = function NbSidebarFooterComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSidebarFooterComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbSidebarFooterComponent,
      selectors: [["nb-sidebar-footer"]],
      standalone: false,
      ngContentSelectors: _c03,
      decls: 1,
      vars: 0,
      template: function NbSidebarFooterComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵprojection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar-footer",
      template: ` <ng-content></ng-content> `,
      standalone: false
    }]
  }], null, null);
})();
var NbSidebarComponent = class _NbSidebarComponent {
  get expanded() {
    return this.state === "expanded";
  }
  get collapsed() {
    return this.state === "collapsed";
  }
  get compacted() {
    return this.state === "compacted";
  }
  /**
   * Places sidebar on the right side
   * @type {boolean}
   */
  set right(val) {
    this.rightValue = convertToBoolProperty(val);
    this.leftValue = !this.rightValue;
    this.startValue = false;
    this.endValue = false;
  }
  /**
   * Places sidebar on the left side
   * @type {boolean}
   */
  set left(val) {
    this.leftValue = convertToBoolProperty(val);
    this.rightValue = !this.leftValue;
    this.startValue = false;
    this.endValue = false;
  }
  /**
   * Places sidebar on the start edge of layout
   * @type {boolean}
   */
  set start(val) {
    this.startValue = convertToBoolProperty(val);
    this.endValue = !this.startValue;
    this.leftValue = false;
    this.rightValue = false;
  }
  /**
   * Places sidebar on the end edge of layout
   * @type {boolean}
   */
  set end(val) {
    this.endValue = convertToBoolProperty(val);
    this.startValue = !this.endValue;
    this.leftValue = false;
    this.rightValue = false;
  }
  /**
   * Makes sidebar fixed (shown above the layout content)
   * @type {boolean}
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
  /**
   * Makes sidebar container fixed
   * @type {boolean}
   */
  set containerFixed(val) {
    this.containerFixedValue = convertToBoolProperty(val);
  }
  /**
   * Initial sidebar state, `expanded`|`collapsed`|`compacted`
   * @type {string}
   */
  get state() {
    return this._state;
  }
  set state(value) {
    this._state = value;
  }
  /**
   * Makes sidebar listen to media query events and change its behaviour
   * @type {boolean}
   */
  get responsive() {
    return this._responsive;
  }
  set responsive(value) {
    if (this.responsive !== convertToBoolProperty(value)) {
      this._responsive = !this.responsive;
      this.responsiveValueChange$.next(this.responsive);
    }
  }
  constructor(sidebarService, themeService, element, cd) {
    this.sidebarService = sidebarService;
    this.themeService = themeService;
    this.element = element;
    this.cd = cd;
    this.responsiveValueChange$ = new Subject();
    this.responsiveState = "pc";
    this.destroy$ = new Subject();
    this.containerFixedValue = true;
    this.fixedValue = false;
    this.rightValue = false;
    this.leftValue = true;
    this.startValue = false;
    this.endValue = false;
    this._state = "expanded";
    this._responsive = false;
    this.compactedBreakpoints = ["xs", "is", "sm", "md", "lg"];
    this.collapsedBreakpoints = ["xs", "is"];
    this.stateChange = new EventEmitter();
    this.responsiveStateChange = new EventEmitter();
  }
  ngOnInit() {
    this.sidebarService.onToggle().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      compact
    }) => this.toggle(compact));
    this.sidebarService.onExpand().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.expand());
    this.sidebarService.onCollapse().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.collapse());
    this.sidebarService.onCompact().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.compact());
    getSidebarState$.pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      observer
    }) => observer.next(this.state));
    getSidebarResponsiveState$.pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      observer
    }) => observer.next(this.responsiveState));
    this.responsiveValueChange$.pipe(filter((responsive) => !responsive), takeUntil(this.destroy$)).subscribe(() => this.expand());
    this.subscribeToMediaQueryChange();
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  // TODO: this is more of a workaround, should be a better way to make components communicate to each other
  onClick(event) {
    const menu = this.element.nativeElement.querySelector("nb-menu");
    if (menu && menu.contains(event.target)) {
      const link = this.getMenuLink(event.target);
      if (link && link.nextElementSibling && link.nextElementSibling.classList.contains("menu-items")) {
        this.sidebarService.expand(this.tag);
      }
    }
  }
  /**
   * Collapses the sidebar
   */
  collapse() {
    this.updateState("collapsed");
  }
  /**
   * Expands the sidebar
   */
  expand() {
    this.updateState("expanded");
  }
  /**
   * Compacts the sidebar (minimizes)
   */
  compact() {
    this.updateState("compacted");
  }
  /**
   * Toggles sidebar state (expanded|collapsed|compacted)
   * @param {boolean} compact If true, then sidebar state will be changed between expanded & compacted,
   * otherwise - between expanded & collapsed. False by default.
   *
   * Toggle sidebar state
   *
   * ```ts
   * this.sidebar.toggle(true);
   * ```
   */
  toggle(compact = false) {
    if (this.responsive) {
      if (this.responsiveState === "mobile") {
        compact = false;
      }
    }
    if (this.state === "compacted" || this.state === "collapsed") {
      this.updateState("expanded");
    } else {
      this.updateState(compact ? "compacted" : "collapsed");
    }
  }
  subscribeToMediaQueryChange() {
    combineLatest([this.responsiveValueChange$.pipe(startWith(this.responsive)), this.themeService.onMediaQueryChange()]).pipe(filter(([responsive]) => responsive), map(([, breakpoints]) => breakpoints), takeUntil(this.destroy$)).subscribe(([prev, current]) => {
      const isCollapsed = this.collapsedBreakpoints.includes(current.name);
      const isCompacted = this.compactedBreakpoints.includes(current.name);
      let newResponsiveState;
      if (isCompacted) {
        this.fixed = this.containerFixedValue;
        this.compact();
        newResponsiveState = "tablet";
      }
      if (isCollapsed) {
        this.fixed = true;
        this.collapse();
        newResponsiveState = "mobile";
      }
      if (!isCollapsed && !isCompacted && (!prev.width || prev.width < current.width)) {
        this.expand();
        this.fixed = false;
        newResponsiveState = "pc";
      }
      if (newResponsiveState && newResponsiveState !== this.responsiveState) {
        this.responsiveState = newResponsiveState;
        this.responsiveStateChange.emit(this.responsiveState);
        this.cd.markForCheck();
      }
    });
  }
  getMenuLink(element) {
    if (!element || element.tagName.toLowerCase() === "nb-menu") {
      return void 0;
    }
    if (element.tagName.toLowerCase() === "a") {
      return element;
    }
    return this.getMenuLink(element.parentElement);
  }
  updateState(state2) {
    if (this.state !== state2) {
      this.state = state2;
      this.stateChange.emit(this.state);
      this.cd.markForCheck();
    }
  }
  static {
    this.ɵfac = function NbSidebarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSidebarComponent)(ɵɵdirectiveInject(NbSidebarService), ɵɵdirectiveInject(NbThemeService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbSidebarComponent,
      selectors: [["nb-sidebar"]],
      hostVars: 16,
      hostBindings: function NbSidebarComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("fixed", ctx.fixedValue)("right", ctx.rightValue)("left", ctx.leftValue)("start", ctx.startValue)("end", ctx.endValue)("expanded", ctx.expanded)("collapsed", ctx.collapsed)("compacted", ctx.compacted);
        }
      },
      inputs: {
        right: "right",
        left: "left",
        start: "start",
        end: "end",
        fixed: "fixed",
        containerFixed: "containerFixed",
        state: "state",
        responsive: "responsive",
        tag: "tag",
        compactedBreakpoints: "compactedBreakpoints",
        collapsedBreakpoints: "collapsedBreakpoints"
      },
      outputs: {
        stateChange: "stateChange",
        responsiveStateChange: "responsiveStateChange"
      },
      standalone: false,
      ngContentSelectors: _c19,
      decls: 5,
      vars: 2,
      consts: [[1, "main-container"], [1, "scrollable", 3, "click"]],
      template: function NbSidebarComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c18);
          ɵɵelementStart(0, "div", 0);
          ɵɵprojection(1);
          ɵɵelementStart(2, "div", 1);
          ɵɵlistener("click", function NbSidebarComponent_Template_div_click_2_listener($event) {
            return ctx.onClick($event);
          });
          ɵɵprojection(3, 1);
          ɵɵelementEnd();
          ɵɵprojection(4, 2);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵclassProp("main-container-fixed", ctx.containerFixedValue);
        }
      },
      styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}[_nghost-%COMP%]   .scrollable[_ngcontent-%COMP%]{overflow-y:auto;overflow-x:hidden;flex:1}[_nghost-%COMP%]   .main-container[_ngcontent-%COMP%]{transform:translateZ(0);display:flex;flex-direction:column}[_nghost-%COMP%]   .main-container-fixed[_ngcontent-%COMP%]{position:fixed}.right[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=ltr]   .right[_nghost-%COMP%]{order:4}[dir=rtl]   .right[_nghost-%COMP%]{order:0}.end[_nghost-%COMP%]{order:4}[dir=ltr]   .end[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=rtl]   .end[_nghost-%COMP%]{margin-left:0;margin-right:auto}.fixed[_nghost-%COMP%]{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}.fixed.right[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.start[_nghost-%COMP%]{left:0}[dir=rtl]   .fixed.start[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.end[_nghost-%COMP%]{right:0}[dir=rtl]   .fixed.end[_nghost-%COMP%]{left:0}[_nghost-%COMP%]     nb-sidebar-footer{margin-top:auto;display:block}[_nghost-%COMP%]     nb-sidebar-header{display:block}\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar",
      template: `
    <div class="main-container" [class.main-container-fixed]="containerFixedValue">
      <ng-content select="nb-sidebar-header"></ng-content>
      <div class="scrollable" (click)="onClick($event)">
        <ng-content></ng-content>
      </div>
      <ng-content select="nb-sidebar-footer"></ng-content>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}:host .scrollable{overflow-y:auto;overflow-x:hidden;flex:1}:host .main-container{transform:translateZ(0);display:flex;flex-direction:column}:host .main-container-fixed{position:fixed}:host.right{margin-right:0;margin-left:auto}[dir=ltr] :host.right{order:4}[dir=rtl] :host.right{order:0}:host.end{order:4}[dir=ltr] :host.end{margin-right:0;margin-left:auto}[dir=rtl] :host.end{margin-left:0;margin-right:auto}:host.fixed{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}:host.fixed.right{right:0}[dir=ltr] :host.fixed.start{left:0}[dir=rtl] :host.fixed.start{right:0}[dir=ltr] :host.fixed.end{right:0}[dir=rtl] :host.fixed.end{left:0}:host ::ng-deep nb-sidebar-footer{margin-top:auto;display:block}:host ::ng-deep nb-sidebar-header{display:block}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbSidebarService
  }, {
    type: NbThemeService
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    rightValue: [{
      type: HostBinding,
      args: ["class.right"]
    }],
    leftValue: [{
      type: HostBinding,
      args: ["class.left"]
    }],
    startValue: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    endValue: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.expanded"]
    }],
    collapsed: [{
      type: HostBinding,
      args: ["class.collapsed"]
    }],
    compacted: [{
      type: HostBinding,
      args: ["class.compacted"]
    }],
    right: [{
      type: Input
    }],
    left: [{
      type: Input
    }],
    start: [{
      type: Input
    }],
    end: [{
      type: Input
    }],
    fixed: [{
      type: Input
    }],
    containerFixed: [{
      type: Input
    }],
    state: [{
      type: Input
    }],
    responsive: [{
      type: Input
    }],
    tag: [{
      type: Input
    }],
    compactedBreakpoints: [{
      type: Input
    }],
    collapsedBreakpoints: [{
      type: Input
    }],
    stateChange: [{
      type: Output
    }],
    responsiveStateChange: [{
      type: Output
    }]
  });
})();
var NB_SIDEBAR_COMPONENTS = [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent];
var NB_SIDEBAR_PROVIDERS = [NbSidebarService];
var NbSidebarModule = class _NbSidebarModule {
  static forRoot() {
    return {
      ngModule: _NbSidebarModule,
      providers: [...NB_SIDEBAR_PROVIDERS]
    };
  }
  static {
    this.ɵfac = function NbSidebarModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSidebarModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbSidebarModule,
      declarations: [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent],
      imports: [NbSharedModule],
      exports: [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_SIDEBAR_COMPONENTS],
      exports: [...NB_SIDEBAR_COMPONENTS]
    }]
  }], null, null);
})();
var NbTabContentDirective = class _NbTabContentDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static {
    this.ɵfac = function NbTabContentDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTabContentDirective)(ɵɵdirectiveInject(TemplateRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTabContentDirective,
      selectors: [["", "nbTabContent", ""]],
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabContentDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTabContent]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var NbTabTitleDirective = class _NbTabTitleDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static {
    this.ɵfac = function NbTabTitleDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTabTitleDirective)(ɵɵdirectiveInject(TemplateRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTabTitleDirective,
      selectors: [["", "nbTabTitle", ""]],
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabTitleDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTabTitle]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var NbTabComponent = class _NbTabComponent {
  constructor() {
    this.activeValue = false;
    this.responsiveValue = false;
    this.disabledValue = false;
    this.badgeStatus = "basic";
    this.init = false;
  }
  /**
   * Use badge dot mode
   * @type {boolean}
   */
  get badgeDot() {
    return this._badgeDot;
  }
  set badgeDot(val) {
    this._badgeDot = convertToBoolProperty(val);
  }
  /**
   * Item is disabled and cannot be opened.
   * @type {boolean}
   */
  get disabled() {
    return this.disabledValue;
  }
  set disabled(val) {
    this.disabledValue = convertToBoolProperty(val);
  }
  /**
   * Show only icons when width is smaller than `tabs-icon-only-max-width`
   * @type {boolean}
   */
  set responsive(val) {
    this.responsiveValue = convertToBoolProperty(val);
  }
  get responsive() {
    return this.responsiveValue;
  }
  /**
   * Specifies active tab
   * @returns {boolean}
   */
  get active() {
    return this.activeValue;
  }
  set active(val) {
    this.activeValue = convertToBoolProperty(val);
    if (this.activeValue) {
      this.init = true;
    }
  }
  /**
   * Lazy load content before tab selection
   * @docs-private
   * @deprecated This setting never worked. Wrap content into a `nbTabContent` to make it lazy.
   * @breaking-change Remove 12.0.0
   */
  set lazyLoad(val) {
    this.init = convertToBoolProperty(val);
  }
  static {
    this.ɵfac = function NbTabComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTabComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTabComponent,
      selectors: [["nb-tab"]],
      contentQueries: function NbTabComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbTabContentDirective, 5);
          ɵɵcontentQuery(dirIndex, NbTabTitleDirective, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabContentDirective = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabTitleDirective = _t.first);
        }
      },
      hostVars: 4,
      hostBindings: function NbTabComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("disabled", ctx.disabled)("content-active", ctx.activeValue);
        }
      },
      inputs: {
        tabTitle: "tabTitle",
        tabId: "tabId",
        badgeDot: "badgeDot",
        tabIcon: "tabIcon",
        disabled: "disabled",
        responsive: "responsive",
        route: "route",
        active: "active",
        lazyLoad: "lazyLoad",
        badgeText: "badgeText",
        badgeStatus: "badgeStatus",
        badgePosition: "badgePosition"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 3,
      vars: 2,
      consts: [["projectedContent", ""], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"]],
      template: function NbTabComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, NbTabComponent_ng_container_0_Template, 1, 1, "ng-container", 1)(1, NbTabComponent_ng_template_1_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        }
        if (rf & 2) {
          const projectedContent_r2 = ɵɵreference(2);
          ɵɵproperty("ngIf", ctx.tabContentDirective)("ngIfElse", projectedContent_r2);
        }
      },
      dependencies: [NgIf, NgTemplateOutlet],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabComponent, [{
    type: Component,
    args: [{
      selector: "nb-tab",
      template: `
    <ng-container
      *ngIf="tabContentDirective; else projectedContent"
      [ngTemplateOutlet]="tabContentDirective.templateRef"
    ></ng-container>

    <ng-template #projectedContent>
      <ng-content></ng-content>
    </ng-template>
  `,
      standalone: false
    }]
  }], null, {
    tabContentDirective: [{
      type: ContentChild,
      args: [NbTabContentDirective]
    }],
    tabTitleDirective: [{
      type: ContentChild,
      args: [NbTabTitleDirective]
    }],
    tabTitle: [{
      type: Input
    }],
    tabId: [{
      type: Input
    }],
    badgeDot: [{
      type: Input
    }],
    tabIcon: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    responsive: [{
      type: Input
    }],
    route: [{
      type: Input
    }],
    activeValue: [{
      type: HostBinding,
      args: ["class.content-active"]
    }],
    active: [{
      type: Input
    }],
    lazyLoad: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }]
  });
})();
var NbTabsetComponent = class _NbTabsetComponent {
  /**
   * Take full width of a parent
   * @param {boolean} val
   */
  set fullWidth(val) {
    this.fullWidthValue = convertToBoolProperty(val);
  }
  constructor(route, changeDetectorRef) {
    this.route = route;
    this.changeDetectorRef = changeDetectorRef;
    this.fullWidthValue = false;
    this.changeTab = new EventEmitter();
    this.destroy$ = new Subject();
  }
  // TODO: refactoring this component, avoid change detection loop
  ngAfterContentInit() {
    this.route.params.pipe(map((params) => this.tabs.find((tab) => this.routeParam ? tab.route === params[this.routeParam] : tab.active)), delay(0), map((tab) => tab || this.tabs.first), filter((tab) => !!tab), takeUntil(this.destroy$)).subscribe((tabToSelect) => {
      this.selectTab(tabToSelect);
      this.changeDetectorRef.markForCheck();
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  // TODO: navigate to routeParam
  selectTab(selectedTab) {
    if (!selectedTab.disabled) {
      this.tabs.forEach((tab) => tab.active = tab === selectedTab);
      this.changeTab.emit(selectedTab);
    }
  }
  static {
    this.ɵfac = function NbTabsetComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTabsetComponent)(ɵɵdirectiveInject(ActivatedRoute), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTabsetComponent,
      selectors: [["nb-tabset"]],
      contentQueries: function NbTabsetComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbTabComponent, 4);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabs = _t);
        }
      },
      hostVars: 2,
      hostBindings: function NbTabsetComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("full-width", ctx.fullWidthValue);
        }
      },
      inputs: {
        fullWidth: "fullWidth",
        routeParam: "routeParam"
      },
      outputs: {
        changeTab: "changeTab"
      },
      standalone: false,
      ngContentSelectors: _c21,
      decls: 3,
      vars: 1,
      consts: [["textTitleTemplate", ""], [1, "tabset"], ["class", "tab", 3, "responsive", "active", "disabled", "click", "keyup.space", "keyup.enter", 4, "ngFor", "ngForOf"], [1, "tab", 3, "click", "keyup.space", "keyup.enter"], ["href", "", "tabindex", "-1", 1, "tab-link", 3, "click"], [3, "config", 4, "ngIf"], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], [3, "text", "dotMode", "status", "position", 4, "ngIf"], [3, "config"], [3, "ngTemplateOutlet"], [1, "tab-text"], [3, "text", "dotMode", "status", "position"]],
      template: function NbTabsetComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c20);
          ɵɵelementStart(0, "ul", 1);
          ɵɵtemplate(1, NbTabsetComponent_li_1_Template, 7, 12, "li", 2);
          ɵɵelementEnd();
          ɵɵprojection(2);
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("ngForOf", ctx.tabs);
        }
      },
      dependencies: [NgForOf, NgIf, NgTemplateOutlet, NbBadgeComponent, NbIconComponent],
      styles: ['[_nghost-%COMP%]{display:block}.full-width[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{justify-content:space-around}[_nghost-%COMP%]     nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}[_nghost-%COMP%]     nb-tab.content-active{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;position:relative}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{display:flex;position:relative;text-decoration:none}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}\n\n\n\n\n\n']
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabsetComponent, [{
    type: Component,
    args: [{
      selector: "nb-tabset",
      template: `
    <ul class="tabset">
      <li
        *ngFor="let tab of tabs"
        (click)="selectTab(tab)"
        (keyup.space)="selectTab(tab)"
        (keyup.enter)="selectTab(tab)"
        [class.responsive]="tab.responsive"
        [class.active]="tab.active"
        [class.disabled]="tab.disabled"
        [attr.tabindex]="tab.disabled ? -1 : 0"
        [attr.data-tab-id]="tab.tabId"
        class="tab"
      >
        <a href (click)="$event.preventDefault()" tabindex="-1" class="tab-link">
          <nb-icon *ngIf="tab.tabIcon" [config]="tab.tabIcon"></nb-icon>
          <ng-container
            *ngIf="tab.tabTitleDirective; else textTitleTemplate"
            [ngTemplateOutlet]="tab.tabTitleDirective.templateRef"
          ></ng-container>
          <ng-template #textTitleTemplate>
            <span class="tab-text">{{ tab.tabTitle }}</span>
          </ng-template>
        </a>
        <nb-badge
          *ngIf="tab.badgeText || tab.badgeDot"
          [text]="tab.badgeText"
          [dotMode]="tab.badgeDot"
          [status]="tab.badgeStatus"
          [position]="tab.badgePosition"
        >
        </nb-badge>
      </li>
    </ul>
    <ng-content select="nb-tab"></ng-content>
  `,
      standalone: false,
      styles: [':host{display:block}:host.full-width .tabset{justify-content:space-around}:host ::ng-deep nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}:host ::ng-deep nb-tab.content-active{display:block}:host .tabset{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}:host .tabset .tab{margin-bottom:-1px;text-align:center;position:relative}:host .tabset .tab.active a:before{display:block}:host .tabset .tab a{display:flex;position:relative;text-decoration:none}:host .tabset .tab a:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}:host .tabset .tab a nb-icon{vertical-align:middle}[dir=ltr] :host .tabset .tab a nb-icon+span{margin-left:.5rem}[dir=rtl] :host .tabset .tab a nb-icon+span{margin-right:.5rem}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n']
    }]
  }], () => [{
    type: ActivatedRoute
  }, {
    type: ChangeDetectorRef
  }], {
    tabs: [{
      type: ContentChildren,
      args: [NbTabComponent]
    }],
    fullWidthValue: [{
      type: HostBinding,
      args: ["class.full-width"]
    }],
    fullWidth: [{
      type: Input
    }],
    routeParam: [{
      type: Input
    }],
    changeTab: [{
      type: Output
    }]
  });
})();
var NB_TABSET_COMPONENTS = [NbTabsetComponent, NbTabComponent];
var NB_TABSET_DIRECTIVES = [NbTabContentDirective, NbTabTitleDirective];
var NbTabsetModule = class _NbTabsetModule {
  static {
    this.ɵfac = function NbTabsetModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTabsetModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbTabsetModule,
      declarations: [NbTabsetComponent, NbTabComponent, NbTabContentDirective, NbTabTitleDirective],
      imports: [NbSharedModule, NbBadgeModule, NbIconModule],
      exports: [NbTabsetComponent, NbTabComponent, NbTabContentDirective, NbTabTitleDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbBadgeModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabsetModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule, NbIconModule],
      declarations: [...NB_TABSET_COMPONENTS, ...NB_TABSET_DIRECTIVES],
      exports: [...NB_TABSET_COMPONENTS, ...NB_TABSET_DIRECTIVES]
    }]
  }], null, null);
})();
var NbUserComponent = class _NbUserComponent {
  /**
   * Absolute path to a user picture or base64 image.
   * User name initials will be shown if no picture specified (JD for John Doe).
   * @type string
   */
  set picture(value) {
    this.imageBackgroundStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
  }
  /**
   * Whether to show a user name or not
   */
  get showName() {
    return this._showName;
  }
  set showName(val) {
    this._showName = convertToBoolProperty(val);
  }
  /**
   * Whether to show a user title or not
   * @type boolean
   */
  get showTitle() {
    return this._showTitle;
  }
  set showTitle(val) {
    this._showTitle = convertToBoolProperty(val);
  }
  /**
   * Whether to show a user initials (if no picture specified) or not
   * @type boolean
   */
  get showInitials() {
    return this._showInitials;
  }
  set showInitials(val) {
    this._showInitials = convertToBoolProperty(val);
  }
  /**
   * Whether to show only a picture or also show the name and title
   * @type boolean
   */
  get onlyPicture() {
    return !this.showName && !this.showTitle;
  }
  set onlyPicture(val) {
    this.showName = this.showTitle = !convertToBoolProperty(val);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get round() {
    return this.shape === "round";
  }
  constructor(domSanitizer) {
    this.domSanitizer = domSanitizer;
    this.name = "Anonymous";
    this.size = "medium";
    this.shape = "round";
    this._showName = true;
    this._showTitle = true;
    this._showInitials = true;
    this.badgeStatus = "basic";
  }
  getInitials() {
    if (this.name) {
      const names = this.name.split(" ");
      return names.map((n) => n.charAt(0)).splice(0, 2).join("").toUpperCase();
    }
    return "";
  }
  static {
    this.ɵfac = function NbUserComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbUserComponent)(ɵɵdirectiveInject(DomSanitizer));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbUserComponent,
      selectors: [["nb-user"]],
      hostVars: 16,
      hostBindings: function NbUserComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
        }
      },
      inputs: {
        name: "name",
        title: "title",
        picture: "picture",
        color: "color",
        size: "size",
        shape: "shape",
        showName: "showName",
        showTitle: "showTitle",
        showInitials: "showInitials",
        onlyPicture: "onlyPicture",
        badgeText: "badgeText",
        badgeStatus: "badgeStatus",
        badgePosition: "badgePosition"
      },
      standalone: false,
      decls: 6,
      vars: 4,
      consts: [[1, "user-container"], ["class", "user-picture image", 3, "background-image", 4, "ngIf"], ["class", "user-picture initials", 3, "background-color", 4, "ngIf"], [1, "info-container"], ["class", "user-name", 4, "ngIf"], ["class", "user-title", 4, "ngIf"], [1, "user-picture", "image"], [3, "text", "status", "position", 4, "ngIf"], [3, "text", "status", "position"], [1, "user-picture", "initials"], [4, "ngIf"], [1, "user-name"], [1, "user-title"]],
      template: function NbUserComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtemplate(1, NbUserComponent_div_1_Template, 2, 3, "div", 1)(2, NbUserComponent_div_2_Template, 3, 4, "div", 2);
          ɵɵelementStart(3, "div", 3);
          ɵɵtemplate(4, NbUserComponent_div_4_Template, 2, 1, "div", 4)(5, NbUserComponent_div_5_Template, 2, 1, "div", 5);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.imageBackgroundStyle);
          ɵɵadvance();
          ɵɵproperty("ngIf", !ctx.imageBackgroundStyle);
          ɵɵadvance(2);
          ɵɵproperty("ngIf", ctx.showName && ctx.name);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.showTitle && ctx.title);
        }
      },
      dependencies: [NgIf, NbBadgeComponent],
      styles: ["[_nghost-%COMP%]{display:flex}[_nghost-%COMP%]   .user-container[_ngcontent-%COMP%]{position:relative;display:flex;align-items:center}[_nghost-%COMP%]   .user-picture[_ngcontent-%COMP%]{position:relative;flex-shrink:0}[_nghost-%COMP%]   .user-picture.image[_ngcontent-%COMP%]{background-size:cover;background-repeat:no-repeat}[_nghost-%COMP%]   .user-picture.initials[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}[dir=rtl]   [_nghost-%COMP%]   .user-name[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .user-title[_ngcontent-%COMP%]{text-align:right}[dir=ltr]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-right:.5rem}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbUserComponent, [{
    type: Component,
    args: [{
      selector: "nb-user",
      standalone: false,
      template: '<div class="user-container">\n  <div *ngIf="imageBackgroundStyle" class="user-picture image" [style.background-image]="imageBackgroundStyle">\n    <nb-badge *ngIf="badgeText" [text]="badgeText" [status]="badgeStatus" [position]="badgePosition"></nb-badge>\n  </div>\n  <div *ngIf="!imageBackgroundStyle" class="user-picture initials" [style.background-color]="color">\n    <ng-container *ngIf="showInitials">\n      {{ getInitials() }}\n    </ng-container>\n    <nb-badge *ngIf="badgeText" [text]="badgeText" [status]="badgeStatus" [position]="badgePosition"></nb-badge>\n  </div>\n\n  <div class="info-container">\n    <div *ngIf="showName && name" class="user-name">{{ name }}</div>\n    <div *ngIf="showTitle && title" class="user-title">{{ title }}</div>\n  </div>\n</div>\n',
      styles: [":host{display:flex}:host .user-container{position:relative;display:flex;align-items:center}:host .user-picture{position:relative;flex-shrink:0}:host .user-picture.image{background-size:cover;background-repeat:no-repeat}:host .user-picture.initials{display:flex;align-items:center;justify-content:center}[dir=rtl] :host .user-name,[dir=rtl] :host .user-title{text-align:right}[dir=ltr] :host .info-container{margin-left:.5rem}[dir=rtl] :host .info-container{margin-right:.5rem}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: DomSanitizer
  }], {
    name: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    picture: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    showName: [{
      type: Input
    }],
    showTitle: [{
      type: Input
    }],
    showInitials: [{
      type: Input
    }],
    onlyPicture: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }]
  });
})();
var NB_USER_COMPONENTS = [NbUserComponent];
var NbUserModule = class _NbUserModule {
  static {
    this.ɵfac = function NbUserModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbUserModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbUserModule,
      declarations: [NbUserComponent],
      imports: [NbSharedModule, NbBadgeModule],
      exports: [NbUserComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbBadgeModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbUserModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule],
      declarations: [...NB_USER_COMPONENTS],
      exports: [...NB_USER_COMPONENTS]
    }]
  }], null, null);
})();
var NbActionComponent = class _NbActionComponent {
  constructor() {
    this.title = "";
    this._disabled = false;
    this.badgeStatus = "basic";
  }
  /**
   * Visually disables the item
   * @type boolean
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * Use badge dot mode
   * @type boolean
   */
  get badgeDot() {
    return this._badgeDot;
  }
  set badgeDot(value) {
    this._badgeDot = convertToBoolProperty(value);
  }
  static {
    this.ɵfac = function NbActionComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbActionComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbActionComponent,
      selectors: [["nb-action"]],
      hostVars: 2,
      hostBindings: function NbActionComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("disabled", ctx.disabled);
        }
      },
      inputs: {
        link: "link",
        href: "href",
        title: "title",
        icon: "icon",
        disabled: "disabled",
        badgeDot: "badgeDot",
        badgeText: "badgeText",
        badgeStatus: "badgeStatus",
        badgePosition: "badgePosition"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 5,
      vars: 2,
      consts: [["projectedContent", ""], ["badgeTemplate", ""], [4, "ngIf", "ngIfElse"], ["class", "icon-container", 3, "routerLink", "title", 4, "ngIf"], ["class", "icon-container", 3, "href", "title", 4, "ngIf"], ["class", "icon-container", "href", "#", 3, "title", "click", 4, "ngIf"], [1, "icon-container", 3, "routerLink", "title"], [3, "config"], [3, "ngTemplateOutlet"], [1, "icon-container", 3, "href", "title"], ["href", "#", 1, "icon-container", 3, "click", "title"], [3, "text", "dotMode", "status", "position", 4, "ngIf"], [3, "text", "dotMode", "status", "position"]],
      template: function NbActionComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, NbActionComponent_ng_container_0_Template, 4, 3, "ng-container", 2)(1, NbActionComponent_ng_template_1_Template, 2, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(3, NbActionComponent_ng_template_3_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        }
        if (rf & 2) {
          const projectedContent_r4 = ɵɵreference(2);
          ɵɵproperty("ngIf", ctx.icon)("ngIfElse", projectedContent_r4);
        }
      },
      dependencies: [NgIf, NgTemplateOutlet, RouterLink, NbBadgeComponent, NbIconComponent],
      styles: ["[_nghost-%COMP%]{background:transparent;display:flex;align-items:center;position:relative}.disabled[_nghost-%COMP%]{cursor:not-allowed}.disabled[_nghost-%COMP%]   a[_ngcontent-%COMP%], .disabled[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{cursor:not-allowed}nb-actions.full-width[_nghost-%COMP%], nb-actions.full-width   [_nghost-%COMP%]{justify-content:center;width:100%}a.icon-container[_ngcontent-%COMP%]{position:relative}a.icon-container[_ngcontent-%COMP%]:hover, a.icon-container[_ngcontent-%COMP%]:focus{text-decoration:none}nb-icon[_ngcontent-%COMP%]:hover{cursor:pointer}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionComponent, [{
    type: Component,
    args: [{
      selector: "nb-action",
      template: `
    <ng-container *ngIf="icon; else projectedContent">
      <a class="icon-container"
         [routerLink]="link"
         [title]="title"
         *ngIf="link">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
      <a class="icon-container"
         [href]="href"
         [title]="title"
         *ngIf="href && !link">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
      <a class="icon-container"
         href="#"
         [title]="title"
         *ngIf="!href && !link"
         (click)="$event.preventDefault()">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
    </ng-container>

    <ng-template #projectedContent>
      <ng-content></ng-content>
      <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
    </ng-template>
    <ng-template #badgeTemplate>
      <nb-badge *ngIf="badgeText || badgeDot"
                [text]="badgeText"
                [dotMode]="badgeDot"
                [status]="badgeStatus"
                [position]="badgePosition">
      </nb-badge>
    </ng-template>
  `,
      standalone: false,
      styles: [":host{background:transparent;display:flex;align-items:center;position:relative}:host(.disabled){cursor:not-allowed}:host(.disabled) a,:host(.disabled) nb-icon{cursor:not-allowed}:host-context(nb-actions.full-width){justify-content:center;width:100%}a.icon-container{position:relative}a.icon-container:hover,a.icon-container:focus{text-decoration:none}nb-icon:hover{cursor:pointer}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    link: [{
      type: Input
    }],
    href: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    badgeDot: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }]
  });
})();
var NbActionsComponent = class _NbActionsComponent {
  constructor() {
    this._size = "small";
    this._fullWidth = false;
  }
  /**
   * Size of the component: 'tiny', 'small' (default), 'medium', 'large', 'giant'
   */
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
  }
  /**
   * Component will fill full width of the container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  static {
    this.ɵfac = function NbActionsComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbActionsComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbActionsComponent,
      selectors: [["nb-actions"]],
      hostVars: 12,
      hostBindings: function NbActionsComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
        }
      },
      inputs: {
        size: "size",
        fullWidth: "fullWidth"
      },
      standalone: false,
      ngContentSelectors: _c23,
      decls: 1,
      vars: 0,
      template: function NbActionsComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c22);
          ɵɵprojection(0);
        }
      },
      styles: ["[_nghost-%COMP%]{display:flex;align-items:center}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionsComponent, [{
    type: Component,
    args: [{
      selector: "nb-actions",
      template: `
    <ng-content select="nb-action"></ng-content>
  `,
      standalone: false,
      styles: [":host{display:flex;align-items:center}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    size: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var NB_ACTIONS_COMPONENTS = [NbActionComponent, NbActionsComponent];
var NbActionsModule = class _NbActionsModule {
  static {
    this.ɵfac = function NbActionsModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbActionsModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbActionsModule,
      declarations: [NbActionComponent, NbActionsComponent],
      imports: [NbSharedModule, NbBadgeModule, NbIconModule],
      exports: [NbActionComponent, NbActionsComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbBadgeModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionsModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule, NbIconModule],
      declarations: [...NB_ACTIONS_COMPONENTS],
      exports: [...NB_ACTIONS_COMPONENTS]
    }]
  }], null, null);
})();
var NbSearchService = class _NbSearchService {
  constructor() {
    this.searchSubmittings$ = new Subject();
    this.searchActivations$ = new Subject();
    this.searchDeactivations$ = new Subject();
    this.searchInput$ = new Subject();
  }
  /***
   * Activate (open) search component
   * @param {string} searchType
   * @param {string} tag
   */
  activateSearch(searchType, tag) {
    this.searchActivations$.next({
      searchType,
      tag
    });
  }
  /**
   * Deactibate (close) search component
   * @param {string} searchType
   * @param {string} tag
   */
  deactivateSearch(searchType, tag) {
    this.searchDeactivations$.next({
      searchType,
      tag
    });
  }
  /**
   * Trigger search submit
   * @param {string} term
   * @param {string} tag
   */
  submitSearch(term, tag) {
    this.searchSubmittings$.next({
      term,
      tag
    });
  }
  /**
   * Trigger search submit by input event
   * @param {string} term
   * @param {string} tag
   */
  searchInput(term, tag) {
    this.searchInput$.next({
      term,
      tag
    });
  }
  /**
   * Subscribe to 'activate' event
   * @returns Observable<{searchType: string; tag?: string}>
   */
  onSearchActivate() {
    return this.searchActivations$.pipe(share());
  }
  /**
   * Subscribe to 'deactivate' event
   * @returns Observable<{searchType: string; tag?: string}>
   */
  onSearchDeactivate() {
    return this.searchDeactivations$.pipe(share());
  }
  /**
   * Subscribe to 'submit' event (when submit button clicked)
   * @returns Observable<{term: string; tag?: string}>
   */
  onSearchSubmit() {
    return this.searchSubmittings$.pipe(share());
  }
  /**
   * Subscribe to input event
   * @returns Observable<{term: string; tag?: string}>
   */
  onSearchInput() {
    return this.searchInput$.pipe(share());
  }
  static {
    this.ɵfac = function NbSearchService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSearchService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbSearchService,
      factory: _NbSearchService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchService, [{
    type: Injectable
  }], null, null);
})();
var NbSearchFieldComponent = class _NbSearchFieldComponent {
  constructor() {
    this.show = false;
    this.close = new EventEmitter();
    this.search = new EventEmitter();
    this.searchInput = new EventEmitter();
  }
  static {
    this.TYPE_MODAL_ZOOMIN = "modal-zoomin";
  }
  static {
    this.TYPE_ROTATE_LAYOUT = "rotate-layout";
  }
  static {
    this.TYPE_MODAL_MOVE = "modal-move";
  }
  static {
    this.TYPE_CURTAIN = "curtain";
  }
  static {
    this.TYPE_COLUMN_CURTAIN = "column-curtain";
  }
  static {
    this.TYPE_MODAL_DROP = "modal-drop";
  }
  static {
    this.TYPE_MODAL_HALF = "modal-half";
  }
  get showClass() {
    return this.show;
  }
  get modalZoomin() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_ZOOMIN;
  }
  get rotateLayout() {
    return this.type === _NbSearchFieldComponent.TYPE_ROTATE_LAYOUT;
  }
  get modalMove() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_MOVE;
  }
  get curtain() {
    return this.type === _NbSearchFieldComponent.TYPE_CURTAIN;
  }
  get columnCurtain() {
    return this.type === _NbSearchFieldComponent.TYPE_COLUMN_CURTAIN;
  }
  get modalDrop() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_DROP;
  }
  get modalHalf() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_HALF;
  }
  ngOnChanges({
    show
  }) {
    const becameHidden = !show.isFirstChange() && show.currentValue === false;
    if (becameHidden && this.inputElement) {
      this.inputElement.nativeElement.value = "";
    }
    this.focusInput();
  }
  ngAfterViewInit() {
    this.focusInput();
  }
  emitClose() {
    this.close.emit();
  }
  submitSearch(term) {
    if (term) {
      this.search.emit(term);
    }
  }
  emitSearchInput(term) {
    this.searchInput.emit(term);
  }
  focusInput() {
    if (this.show && this.inputElement) {
      this.inputElement.nativeElement.focus();
    }
  }
  static {
    this.ɵfac = function NbSearchFieldComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSearchFieldComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbSearchFieldComponent,
      selectors: [["nb-search-field"]],
      viewQuery: function NbSearchFieldComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c24, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputElement = _t.first);
        }
      },
      hostVars: 16,
      hostBindings: function NbSearchFieldComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("show", ctx.showClass)("modal-zoomin", ctx.modalZoomin)("rotate-layout", ctx.rotateLayout)("modal-move", ctx.modalMove)("curtain", ctx.curtain)("column-curtain", ctx.columnCurtain)("modal-drop", ctx.modalDrop)("modal-half", ctx.modalHalf);
        }
      },
      inputs: {
        type: "type",
        placeholder: "placeholder",
        hint: "hint",
        show: "show"
      },
      outputs: {
        close: "close",
        search: "search",
        searchInput: "searchInput"
      },
      standalone: false,
      features: [ɵɵNgOnChangesFeature],
      decls: 10,
      vars: 2,
      consts: [["searchInput", ""], [1, "search", 3, "keyup.esc"], ["nbButton", "", "ghost", "", 1, "close-button", 3, "click"], ["icon", "close-outline", "pack", "nebular-essentials"], [1, "form-wrapper"], [1, "form", 3, "keyup.enter"], [1, "form-content"], ["autocomplete", "off", "tabindex", "-1", 1, "search-input", 3, "input", "blur"], [1, "info"]],
      template: function NbSearchFieldComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵelementStart(0, "div", 1);
          ɵɵlistener("keyup.esc", function NbSearchFieldComponent_Template_div_keyup_esc_0_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.emitClose());
          });
          ɵɵelementStart(1, "button", 2);
          ɵɵlistener("click", function NbSearchFieldComponent_Template_button_click_1_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.emitClose());
          });
          ɵɵelement(2, "nb-icon", 3);
          ɵɵelementEnd();
          ɵɵelementStart(3, "div", 4)(4, "form", 5);
          ɵɵlistener("keyup.enter", function NbSearchFieldComponent_Template_form_keyup_enter_4_listener() {
            ɵɵrestoreView(_r1);
            const searchInput_r2 = ɵɵreference(7);
            return ɵɵresetView(ctx.submitSearch(searchInput_r2.value));
          });
          ɵɵelementStart(5, "div", 6)(6, "input", 7, 0);
          ɵɵlistener("input", function NbSearchFieldComponent_Template_input_input_6_listener() {
            ɵɵrestoreView(_r1);
            const searchInput_r2 = ɵɵreference(7);
            return ɵɵresetView(ctx.emitSearchInput(searchInput_r2.value));
          })("blur", function NbSearchFieldComponent_Template_input_blur_6_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.focusInput());
          });
          ɵɵelementEnd()();
          ɵɵelementStart(8, "span", 8);
          ɵɵtext(9);
          ɵɵelementEnd()()()();
        }
        if (rf & 2) {
          ɵɵadvance(6);
          ɵɵattribute("placeholder", ctx.placeholder);
          ɵɵadvance(3);
          ɵɵtextInterpolate(ctx.hint);
        }
      },
      dependencies: [ɵNgNoValidate, NgControlStatusGroup, NgForm, NbIconComponent, NbButtonComponent],
      styles: ['[_nghost-%COMP%]   button[_ngcontent-%COMP%]{margin:0;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:.05rem 0;-webkit-appearance:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]:focus{outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]::placeholder{opacity:.3}[_nghost-%COMP%]   span[_ngcontent-%COMP%]{font-size:90%;font-weight:700;display:block;width:75%;margin:0 auto;padding:.85rem 0;text-align:right}.modal-zoomin[_nghost-%COMP%]{display:block}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before, .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{content:"";position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px,-15px,0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px,15px,0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before, .modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{transform:translateZ(0);transition:transform .5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40rem){.modal-zoomin[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0 1rem}.modal-zoomin[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}\n\n\n\n\n\n\n\n\n\n\n\n', "nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}  nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform .5s cubic-bezier(.2,1,.3,1)}  nb-layout.rotate-layout.with-search .scrollable-container{transition:transform .5s cubic-bezier(.2,1,.3,1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0,50vh,0) rotateX(30deg);pointer-events:none}.rotate-layout[_nghost-%COMP%]{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:.4s}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(.7,.7,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:75%}.rotate-layout.show[_nghost-%COMP%]{opacity:1;transition-delay:0s}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}\n\n\n\n\n\n", "nb-layout.modal-move .layout{transition:transform .5s}  nb-layout.modal-move.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{transform:scaleZ(1);transition-duration:.5s}@media screen and (max-width: 40rem){.modal-move[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}\n\n\n\n\n\n", '.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform .3s;transition-delay:.4s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transition:transform .3s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;transition:opacity .1s;transition-delay:.3s}[dir=ltr]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:50%;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:100%;font-size:6vw}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{width:100%;pointer-events:auto;transform:translate3d(-100%,0,0);transition-delay:0s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{transform:translate3d(100%,0,0);transition-delay:.4s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40em){.curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2em;width:90%}}  nb-layout.curtain .scrollable-container{position:relative;z-index:0}\n\n\n\n\n\n\n\n\n\n\n\n', 'nb-layout.column-curtain.with-search .layout{pointer-events:none}.column-curtain[_nghost-%COMP%]{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}.column-curtain[_nghost-%COMP%]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s;transition-timing-function:cubic-bezier(.86,0,.07,1)}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:relative;padding:2.5rem 1.5rem 0;background:transparent}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:2rem}[dir=rtl]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:2rem}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:85%;transform:translate3d(-150%,0,0);transition:transform .3s}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:2.5rem;width:100%}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:85%}.column-curtain.show[_nghost-%COMP%]{pointer-events:auto}.column-curtain.show[_nghost-%COMP%]:before{transform:scaleZ(1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{transform:translateZ(0);transition-delay:.15s;transition-timing-function:cubic-bezier(.86,0,.07,1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;z-index:100}@media screen and (max-width: 40rem){.column-curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.column-curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2rem;width:90%}}\n\n\n\n\n\n\n\n\n\n\n\n', 'nb-layout.modal-drop .layout{position:relative;transition:transform .4s,opacity .4s;transition-timing-function:cubic-bezier(.4,0,.2,1)}  nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(.9,.9,1);pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{content:"";position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity .4s}[dir=ltr]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{position:relative;margin:5rem 0 2rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:6vw;width:60%;padding:.25rem;text-align:center;opacity:0;transition:opacity .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{position:relative;z-index:9;display:block;width:60%;padding:.85rem 0;opacity:0;transform:translate3d(0,-50px,0);transition:opacity .4s,transform .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{position:relative;z-index:10;overflow:hidden;transform:translate3d(0,-50px,0);transition:transform .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]:after{content:"";position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{transform:translateZ(0);transition:none}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]:after{animation:_ngcontent-%COMP%_scaleUpDown .8s cubic-bezier(.4,0,.2,1) forwards}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{opacity:1;transition:opacity 0s .4s}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{opacity:1;transform:translateZ(0);transition-delay:.4s;transition-timing-function:ease-out}@keyframes _ngcontent-%COMP%_scaleUpDown{0%{opacity:1;transform:scale3d(1,0,1)}50%{transform:scaleZ(1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}to{opacity:1;transform:scale3d(1,0,1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){.modal-drop[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:2rem 0}.modal-drop[_nghost-%COMP%]   input[_ngcontent-%COMP%]{width:100%;left:0}}\n\n\n\n\n\n', 'nb-layout.modal-half .layout{transition:transform .6s,opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}  nb-layout.modal-half.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .6s,transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1);transform:translate3d(0,-100%,0)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:75%;margin:0 auto}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:100%}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{opacity:1}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{transform:translateZ(0)}\n\n\n\n\n\n'],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchFieldComponent, [{
    type: Component,
    args: [{
      selector: "nb-search-field",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <div class="search" (keyup.esc)="emitClose()">
      <button (click)="emitClose()" nbButton ghost class="close-button">
        <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
      </button>
      <div class="form-wrapper">
        <form class="form" (keyup.enter)="submitSearch(searchInput.value)">
          <div class="form-content">
            <input class="search-input"
                   #searchInput
                   (input)="emitSearchInput(searchInput.value)"
                   autocomplete="off"
                   [attr.placeholder]="placeholder"
                   tabindex="-1"
                   (blur)="focusInput()"/>
          </div>
          <span class="info">{{ hint }}</span>
        </form>
      </div>
    </div>
  `,
      standalone: false,
      styles: [':host button{margin:0;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}:host input{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:.05rem 0;-webkit-appearance:none}:host input:focus{outline:none}:host input::placeholder{opacity:.3}:host span{font-size:90%;font-weight:700;display:block;width:75%;margin:0 auto;padding:.85rem 0;text-align:right}:host.modal-zoomin{display:block}:host.modal-zoomin .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}:host.modal-zoomin .search:before,:host.modal-zoomin .search:after{content:"";position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}:host.modal-zoomin .search:before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px,-15px,0)}:host.modal-zoomin .search:after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px,15px,0)}:host.modal-zoomin .search button{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr] :host.modal-zoomin .search button{right:3rem}[dir=rtl] :host.modal-zoomin .search button{left:3rem}:host.modal-zoomin .search input{font-size:10vw;width:75%}:host.modal-zoomin .search button{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-zoomin .search form{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-zoomin.show .search{pointer-events:auto;opacity:1}:host.modal-zoomin.show .search:before,:host.modal-zoomin.show .search:after{transform:translateZ(0);transition:transform .5s}:host.modal-zoomin.show .search button{opacity:1;transform:scaleZ(1)}:host.modal-zoomin.show .search form{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40rem){:host.modal-zoomin form{margin:5rem 0 1rem}:host.modal-zoomin span{text-align:left}}\n/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n', "::ng-deep nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}::ng-deep nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform .5s cubic-bezier(.2,1,.3,1)}::ng-deep nb-layout.rotate-layout.with-search .scrollable-container{transition:transform .5s cubic-bezier(.2,1,.3,1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0,50vh,0) rotateX(30deg);pointer-events:none}:host.rotate-layout{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:.4s}:host.rotate-layout .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.rotate-layout .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr] :host.rotate-layout .search button{right:3rem}[dir=rtl] :host.rotate-layout .search button{left:3rem}:host.rotate-layout .search form{margin:5rem 0;opacity:0;transform:scale3d(.7,.7,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.rotate-layout .search input{font-size:7vw;width:75%}:host.rotate-layout.show{opacity:1;transition-delay:0s}:host.rotate-layout.show .search{pointer-events:auto;opacity:1}:host.rotate-layout.show .search button{opacity:1;transform:scaleZ(1)}:host.rotate-layout.show .search form{opacity:1;transform:scaleZ(1)}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n", "::ng-deep nb-layout.modal-move .layout{transition:transform .5s}::ng-deep nb-layout.modal-move.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}:host.modal-move .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}:host.modal-move .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr] :host.modal-move .search button{right:3rem}[dir=rtl] :host.modal-move .search button{left:3rem}:host.modal-move .search form{margin:5rem 0;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-move .search input{font-size:10vw;width:75%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s}:host.modal-move.show .search{pointer-events:auto;opacity:1}:host.modal-move.show .search button{opacity:1}:host.modal-move.show .search form{opacity:1;transform:scaleZ(1)}:host.modal-move.show .search input{transform:scaleZ(1);transition-duration:.5s}@media screen and (max-width: 40rem){:host.modal-move span{text-align:left}}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n", ':host.curtain .search{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform .3s;transition-delay:.4s;transition-timing-function:ease-out}:host.curtain .search:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transition:transform .3s;transition-timing-function:ease-out}:host.curtain .search button{font-size:2.5rem;position:absolute;top:3rem;transition:opacity .1s;transition-delay:.3s}[dir=ltr] :host.curtain .search button{right:3rem}[dir=rtl] :host.curtain .search button{left:3rem}:host.curtain .search form{width:50%;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.curtain .search input{width:100%;font-size:6vw}:host.curtain.show .search{width:100%;pointer-events:auto;transform:translate3d(-100%,0,0);transition-delay:0s}:host.curtain.show .search:after{transform:translate3d(100%,0,0);transition-delay:.4s}:host.curtain.show .search button{opacity:1;transform:scaleZ(1)}:host.curtain.show .search form{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40em){:host.curtain span{width:90%}:host.curtain input{font-size:2em;width:90%}}::ng-deep nb-layout.curtain .scrollable-container{position:relative;z-index:0}\n/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n', '::ng-deep nb-layout.column-curtain.with-search .layout{pointer-events:none}:host.column-curtain{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}:host.column-curtain:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s;transition-timing-function:cubic-bezier(.86,0,.07,1)}:host.column-curtain .search{position:relative;padding:2.5rem 1.5rem 0;background:transparent}:host.column-curtain .search button{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr] :host.column-curtain .search button{right:2rem}[dir=rtl] :host.column-curtain .search button{left:2rem}:host.column-curtain .search form{width:85%;transform:translate3d(-150%,0,0);transition:transform .3s}:host.column-curtain .search input{font-size:2.5rem;width:100%}:host.column-curtain .search span{font-size:85%}:host.column-curtain.show{pointer-events:auto}:host.column-curtain.show:before{transform:scaleZ(1)}:host.column-curtain.show .search form{transform:translateZ(0);transition-delay:.15s;transition-timing-function:cubic-bezier(.86,0,.07,1)}:host.column-curtain.show .search button{opacity:1;z-index:100}@media screen and (max-width: 40rem){:host.column-curtain span{width:90%}:host.column-curtain input{font-size:2rem;width:90%}}\n/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n', '::ng-deep nb-layout.modal-drop .layout{position:relative;transition:transform .4s,opacity .4s;transition-timing-function:cubic-bezier(.4,0,.2,1)}::ng-deep nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(.9,.9,1);pointer-events:none}:host.modal-drop .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-drop .search:before{content:"";position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity .4s}:host.modal-drop .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity .4s}[dir=ltr] :host.modal-drop .search button{right:3rem}[dir=rtl] :host.modal-drop .search button{left:3rem}:host.modal-drop .search form{position:relative;margin:5rem 0 2rem}:host.modal-drop .search input{font-size:6vw;width:60%;padding:.25rem;text-align:center;opacity:0;transition:opacity .4s}:host.modal-drop .search span{position:relative;z-index:9;display:block;width:60%;padding:.85rem 0;opacity:0;transform:translate3d(0,-50px,0);transition:opacity .4s,transform .4s}:host.modal-drop .search .form-content{position:relative;z-index:10;overflow:hidden;transform:translate3d(0,-50px,0);transition:transform .4s}:host.modal-drop .search .form-content:after{content:"";position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}:host.modal-drop.show .search{pointer-events:auto}:host.modal-drop.show .search:before{opacity:1}:host.modal-drop.show .search button{opacity:1}:host.modal-drop.show .search .form-content{transform:translateZ(0);transition:none}:host.modal-drop.show .search .form-content:after{animation:scaleUpDown .8s cubic-bezier(.4,0,.2,1) forwards}:host.modal-drop.show .search input{opacity:1;transition:opacity 0s .4s}:host.modal-drop.show .search span{opacity:1;transform:translateZ(0);transition-delay:.4s;transition-timing-function:ease-out}@keyframes scaleUpDown{0%{opacity:1;transform:scale3d(1,0,1)}50%{transform:scaleZ(1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}to{opacity:1;transform:scale3d(1,0,1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){:host.modal-drop form{margin:2rem 0}:host.modal-drop input{width:100%;left:0}}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n', '::ng-deep nb-layout.modal-half .layout{transition:transform .6s,opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}::ng-deep nb-layout.modal-half.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}:host.modal-half .search{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-half .search:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.modal-half .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .6s,transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr] :host.modal-half .search button{right:3rem}[dir=rtl] :host.modal-half .search button{left:3rem}:host.modal-half .search .form-wrapper{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1);transform:translate3d(0,-100%,0)}:host.modal-half .search form{width:75%;margin:0 auto}:host.modal-half .search input{font-size:7vw;width:100%}:host.modal-half.show .search{pointer-events:auto}:host.modal-half.show .search:before{opacity:1}:host.modal-half.show .search button{opacity:1;transform:scaleZ(1)}:host.modal-half.show .search .form-wrapper{transform:translateZ(0)}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n']
    }]
  }], null, {
    type: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    show: [{
      type: Input
    }],
    close: [{
      type: Output
    }],
    search: [{
      type: Output
    }],
    searchInput: [{
      type: Output
    }],
    inputElement: [{
      type: ViewChild,
      args: ["searchInput"]
    }],
    showClass: [{
      type: HostBinding,
      args: ["class.show"]
    }],
    modalZoomin: [{
      type: HostBinding,
      args: ["class.modal-zoomin"]
    }],
    rotateLayout: [{
      type: HostBinding,
      args: ["class.rotate-layout"]
    }],
    modalMove: [{
      type: HostBinding,
      args: ["class.modal-move"]
    }],
    curtain: [{
      type: HostBinding,
      args: ["class.curtain"]
    }],
    columnCurtain: [{
      type: HostBinding,
      args: ["class.column-curtain"]
    }],
    modalDrop: [{
      type: HostBinding,
      args: ["class.modal-drop"]
    }],
    modalHalf: [{
      type: HostBinding,
      args: ["class.modal-half"]
    }]
  });
})();
var NbSearchComponent = class _NbSearchComponent {
  constructor(searchService, themeService, router, overlayService, changeDetector) {
    this.searchService = searchService;
    this.themeService = themeService;
    this.router = router;
    this.overlayService = overlayService;
    this.changeDetector = changeDetector;
    this.destroy$ = new Subject();
    this.showSearchField = false;
    this.placeholder = "Search...";
    this.hint = "Hit enter to search";
  }
  ngOnInit() {
    this.router.events.pipe(filter((event) => event instanceof NavigationEnd), takeUntil(this.destroy$)).subscribe(() => this.hideSearch());
    this.searchService.onSearchActivate().pipe(filter((data) => !this.tag || data.tag === this.tag), takeUntil(this.destroy$)).subscribe(() => this.openSearch());
    this.searchService.onSearchDeactivate().pipe(filter((data) => !this.tag || data.tag === this.tag), takeUntil(this.destroy$)).subscribe(() => this.hideSearch());
  }
  ngOnDestroy() {
    if (this.overlayRef && this.overlayRef.hasAttached()) {
      this.removeLayoutClasses();
      this.overlayRef.detach();
    }
    this.destroy$.next();
    this.destroy$.complete();
  }
  openSearch() {
    if (!this.overlayRef) {
      this.overlayRef = this.overlayService.create();
      this.overlayRef.attach(this.searchFieldPortal);
    }
    this.themeService.appendLayoutClass(this.type);
    of(null).pipe(delay(0)).subscribe(() => {
      this.themeService.appendLayoutClass("with-search");
      this.showSearchField = true;
      this.changeDetector.detectChanges();
    });
  }
  hideSearch() {
    this.removeLayoutClasses();
    this.showSearchField = false;
    this.changeDetector.detectChanges();
    this.searchButton.nativeElement.focus();
  }
  search(term) {
    this.searchService.submitSearch(term, this.tag);
    this.hideSearch();
  }
  emitInput(term) {
    this.searchService.searchInput(term, this.tag);
  }
  emitActivate() {
    this.searchService.activateSearch(this.type, this.tag);
  }
  emitDeactivate() {
    this.searchService.deactivateSearch(this.type, this.tag);
  }
  removeLayoutClasses() {
    this.themeService.removeLayoutClass("with-search");
    of(null).pipe(delay(500)).subscribe(() => {
      this.themeService.removeLayoutClass(this.type);
    });
  }
  static {
    this.ɵfac = function NbSearchComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSearchComponent)(ɵɵdirectiveInject(NbSearchService), ɵɵdirectiveInject(NbThemeService), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbSearchComponent,
      selectors: [["nb-search"]],
      viewQuery: function NbSearchComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbPortalDirective, 5);
          ɵɵviewQuery(_c25, 5, ElementRef);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchFieldPortal = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchButton = _t.first);
        }
      },
      inputs: {
        tag: "tag",
        placeholder: "placeholder",
        hint: "hint",
        type: "type"
      },
      standalone: false,
      decls: 4,
      vars: 0,
      consts: [["searchButton", ""], ["nbButton", "", "ghost", "", 1, "start-search", 3, "click"], ["icon", "search-outline", "pack", "nebular-essentials"], [3, "show", "type", "placeholder", "hint", "search", "searchInput", "close", 4, "nbPortal"], [3, "search", "searchInput", "close", "show", "type", "placeholder", "hint"]],
      template: function NbSearchComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵelementStart(0, "button", 1, 0);
          ɵɵlistener("click", function NbSearchComponent_Template_button_click_0_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.emitActivate());
          });
          ɵɵelement(2, "nb-icon", 2);
          ɵɵelementEnd();
          ɵɵtemplate(3, NbSearchComponent_nb_search_field_3_Template, 1, 4, "nb-search-field", 3);
        }
      },
      dependencies: [NbPortalDirective, NbIconComponent, NbButtonComponent, NbSearchFieldComponent],
      styles: ["[_nghost-%COMP%]   button[_ngcontent-%COMP%]{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}  nb-layout.with-search .scrollable-container{position:relative;z-index:0}\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchComponent, [{
    type: Component,
    args: [{
      selector: "nb-search",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <button #searchButton class="start-search" (click)="emitActivate()" nbButton ghost>
      <nb-icon icon="search-outline" pack="nebular-essentials"></nb-icon>
    </button>
    <nb-search-field
      *nbPortal
      [show]="showSearchField"
      [type]="type"
      [placeholder]="placeholder"
      [hint]="hint"
      (search)="search($event)"
      (searchInput)="emitInput($event)"
      (close)="emitDeactivate()">
    </nb-search-field>
  `,
      standalone: false,
      styles: [":host button{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}::ng-deep nb-layout.with-search .scrollable-container{position:relative;z-index:0}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbSearchService
  }, {
    type: NbThemeService
  }, {
    type: Router
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }], {
    tag: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    searchFieldPortal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    searchButton: [{
      type: ViewChild,
      args: ["searchButton", {
        read: ElementRef
      }]
    }]
  });
})();
var NbSearchModule = class _NbSearchModule {
  static {
    this.ɵfac = function NbSearchModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSearchModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbSearchModule,
      declarations: [NbSearchComponent, NbSearchFieldComponent],
      imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule],
      exports: [NbSearchComponent, NbSearchFieldComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [NbSearchService],
      imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule],
      declarations: [NbSearchComponent, NbSearchFieldComponent],
      exports: [NbSearchComponent, NbSearchFieldComponent],
      providers: [NbSearchService]
    }]
  }], null, null);
})();
var NbCheckboxComponent = class _NbCheckboxComponent {
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._checked = convertToBoolProperty(value);
  }
  /**
   * Controls input disabled state
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * Controls checkbox indeterminate state
   */
  get indeterminate() {
    return this._indeterminate;
  }
  set indeterminate(value) {
    this._indeterminate = convertToBoolProperty(value);
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get info() {
    return this.status === "info";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(changeDetector, renderer, hostElement, zone, statusService) {
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.zone = zone;
    this.statusService = statusService;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this._indeterminate = false;
    this.checkedChange = new EventEmitter();
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(val) {
    this._checked = val;
    this.changeDetector.markForCheck();
  }
  setDisabledState(val) {
    this.disabled = convertToBoolProperty(val);
    this.changeDetector.markForCheck();
  }
  setTouched() {
    this.onTouched();
  }
  updateValueAndIndeterminate(event) {
    const input = event.target;
    this.checked = input.checked;
    this.checkedChange.emit(this.checked);
    this.onChange(this.checked);
    this.indeterminate = input.indeterminate;
  }
  static {
    this.ɵfac = function NbCheckboxComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCheckboxComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbCheckboxComponent,
      selectors: [["nb-checkbox"]],
      hostVars: 16,
      hostBindings: function NbCheckboxComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control);
        }
      },
      inputs: {
        checked: "checked",
        disabled: "disabled",
        status: "status",
        indeterminate: "indeterminate"
      },
      outputs: {
        checkedChange: "checkedChange"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _NbCheckboxComponent),
        multi: true
      }])],
      ngContentSelectors: _c03,
      decls: 7,
      vars: 9,
      consts: [[1, "label"], ["type", "checkbox", 1, "native-input", "visually-hidden", 3, "change", "blur", "click", "disabled", "checked", "indeterminate"], [1, "custom-checkbox"], ["icon", "minus-bold-outline", "pack", "nebular-essentials", "class", "custom-checkbox-icon", 4, "ngIf"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", "class", "custom-checkbox-icon", 4, "ngIf"], [1, "text"], ["icon", "minus-bold-outline", "pack", "nebular-essentials", 1, "custom-checkbox-icon"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 1, "custom-checkbox-icon"]],
      template: function NbCheckboxComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵelementStart(0, "label", 0)(1, "input", 1);
          ɵɵlistener("change", function NbCheckboxComponent_Template_input_change_1_listener($event) {
            return ctx.updateValueAndIndeterminate($event);
          })("blur", function NbCheckboxComponent_Template_input_blur_1_listener() {
            return ctx.setTouched();
          })("click", function NbCheckboxComponent_Template_input_click_1_listener($event) {
            return $event.stopPropagation();
          });
          ɵɵelementEnd();
          ɵɵelementStart(2, "span", 2);
          ɵɵtemplate(3, NbCheckboxComponent_nb_icon_3_Template, 1, 0, "nb-icon", 3)(4, NbCheckboxComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
          ɵɵelementEnd();
          ɵɵelementStart(5, "span", 5);
          ɵɵprojection(6);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("disabled", ctx.disabled)("checked", ctx.checked)("indeterminate", ctx.indeterminate);
          ɵɵadvance();
          ɵɵclassProp("indeterminate", ctx.indeterminate)("checked", ctx.checked);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.indeterminate);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.checked && !ctx.indeterminate);
        }
      },
      dependencies: [NgIf, NbIconComponent],
      styles: ["[_nghost-%COMP%]   .label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}[_nghost-%COMP%]   .custom-checkbox[_ngcontent-%COMP%]{flex-shrink:0}.nb-transition[_nghost-%COMP%]   .custom-checkbox[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.nb-transition[_nghost-%COMP%]   .text[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:color;transition-timing-function:ease-in}\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCheckboxComponent, [{
    type: Component,
    args: [{
      selector: "nb-checkbox",
      template: `
    <label class="label">
      <input type="checkbox" class="native-input visually-hidden"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValueAndIndeterminate($event)"
             (blur)="setTouched()"
             (click)="$event.stopPropagation()"
             [indeterminate]="indeterminate">
      <span [class.indeterminate]="indeterminate" [class.checked]="checked" class="custom-checkbox">
        <nb-icon *ngIf="indeterminate" icon="minus-bold-outline" pack="nebular-essentials" class="custom-checkbox-icon"></nb-icon>
        <nb-icon *ngIf="checked && !indeterminate" icon="checkmark-bold-outline" pack="nebular-essentials" class="custom-checkbox-icon"></nb-icon>
      </span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbCheckboxComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host .label{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}:host .custom-checkbox{flex-shrink:0}:host(.nb-transition) .custom-checkbox{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}:host(.nb-transition) .text{transition-duration:.15s;transition-property:color;transition-timing-function:ease-in}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    checked: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    indeterminate: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NbCheckboxModule = class _NbCheckboxModule {
  static {
    this.ɵfac = function NbCheckboxModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCheckboxModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbCheckboxModule,
      declarations: [NbCheckboxComponent],
      imports: [NbSharedModule, NbIconModule],
      exports: [NbCheckboxComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCheckboxModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbCheckboxComponent],
      exports: [NbCheckboxComponent]
    }]
  }], null, null);
})();
var NbDynamicOverlay = class _NbDynamicOverlay {
  get isAttached() {
    return this.ref && this.ref.hasAttached();
  }
  get isShown() {
    return this.isShown$.pipe(distinctUntilChanged());
  }
  constructor(overlay, componentFactoryResolver, zone, overlayContainer) {
    this.overlay = overlay;
    this.componentFactoryResolver = componentFactoryResolver;
    this.zone = zone;
    this.overlayContainer = overlayContainer;
    this.context = {};
    this.overlayConfig = {};
    this.disabled = false;
    this.positionStrategyChange$ = new Subject();
    this.isShown$ = new BehaviorSubject(false);
    this.destroy$ = new Subject();
    this.overlayDestroy$ = new Subject();
  }
  create(componentType, content, context, positionStrategy, overlayConfig = {}, disabled = false) {
    this.setContentAndContext(content, context);
    this.setComponent(componentType);
    this.setPositionStrategy(positionStrategy);
    this.setOverlayConfig(overlayConfig);
    this.setDisabled(disabled);
    return this;
  }
  setContent(content) {
    this.content = content;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setContext(context) {
    this.context = context;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setContentAndContext(content, context) {
    this.content = content;
    this.context = context;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setComponent(componentType) {
    this.componentType = componentType;
    const wasAttached = this.isAttached;
    this.disposeOverlayRef();
    if (wasAttached) {
      this.show();
    }
  }
  setPositionStrategy(positionStrategy) {
    this.positionStrategyChange$.next();
    this.positionStrategy = positionStrategy;
    this.positionStrategy.positionChange.pipe(filter(() => !!this.container), takeUntil(merge(this.positionStrategyChange$, this.destroy$))).subscribe((position) => {
      this.lastAppliedPosition = position;
      patch(this.container, {
        position
      });
    });
    if (this.ref) {
      this.ref.updatePositionStrategy(this.positionStrategy);
    }
  }
  setOverlayConfig(overlayConfig) {
    this.overlayConfig = overlayConfig;
    const wasAttached = this.isAttached;
    this.disposeOverlayRef();
    if (wasAttached) {
      this.show();
    }
  }
  setDisabled(disabled) {
    if (disabled && this.isShown$.value) {
      this.hide();
    }
    this.disabled = disabled;
  }
  show() {
    if (this.disabled) {
      return;
    }
    if (!this.ref) {
      this.createOverlay();
    }
    this.renderContainer();
    if (!this.hasOverlayInContainer()) {
      this.disposeOverlayRef();
      return this.show();
    }
    this.isShown$.next(true);
  }
  hide() {
    if (!this.ref) {
      return;
    }
    this.ref.detach();
    this.container = null;
    this.isShown$.next(false);
  }
  toggle() {
    if (this.isAttached) {
      this.hide();
    } else {
      this.show();
    }
  }
  dispose() {
    this.destroy$.next();
    this.destroy$.complete();
    this.hide();
    this.disposeOverlayRef();
    this.isShown$.complete();
    this.positionStrategyChange$.complete();
    this.overlayDestroy$.complete();
  }
  getContainer() {
    return this.container;
  }
  createOverlay() {
    this.ref = this.overlay.create(__spreadValues({
      positionStrategy: this.positionStrategy,
      scrollStrategy: this.overlay.scrollStrategies.reposition()
    }, this.overlayConfig));
    this.updatePositionWhenStable(this.ref);
  }
  renderContainer() {
    const containerContext = this.createContainerContext();
    if (!this.container) {
      this.container = createContainer(this.ref, this.componentType, containerContext, this.componentFactoryResolver);
    }
    this.container.instance.renderContent();
  }
  updateContext() {
    const containerContext = this.createContainerContext();
    Object.assign(this.container.instance, containerContext);
    this.container.instance.renderContent();
    this.container.changeDetectorRef.detectChanges();
  }
  createContainerContext() {
    return {
      content: this.content,
      context: this.context,
      cfr: this.componentFactoryResolver,
      position: this.lastAppliedPosition
    };
  }
  /**
   * Dimensions of the container may change after content update. So we listen to zone.stable event to
   * reposition the container.
   */
  updatePositionWhenStable(overlay) {
    const overlayDestroy$ = this.overlayDestroy$.pipe(filter((destroyedOverlay) => destroyedOverlay === overlay));
    this.zone.onStable.pipe(take(1), takeUntil(merge(this.destroy$, overlayDestroy$))).subscribe(() => this.updatePosition());
  }
  updatePosition() {
    if (this.ref) {
      this.ref.updatePosition();
    }
  }
  hasOverlayInContainer() {
    return this.overlayContainer.getContainerElement().contains(this.ref.hostElement);
  }
  disposeOverlayRef() {
    if (this.ref) {
      this.ref.dispose();
      this.overlayDestroy$.next(this.ref);
      this.ref = null;
      this.container = null;
    }
  }
  static {
    this.ɵfac = function NbDynamicOverlay_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbDynamicOverlay)(ɵɵinject(NbOverlayService), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NgZone), ɵɵinject(NbOverlayContainer));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbDynamicOverlay,
      factory: _NbDynamicOverlay.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDynamicOverlay, [{
    type: Injectable
  }], () => [{
    type: NbOverlayService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: NgZone
  }, {
    type: NbOverlayContainer
  }], null);
})();
var NbDynamicOverlayChange = class extends SimpleChange {
  constructor(previousValue, currentValue, firstChange = false) {
    super(previousValue, currentValue, firstChange);
  }
  isChanged() {
    return this.currentValue !== this.previousValue;
  }
};
var NbDynamicOverlayHandler = class _NbDynamicOverlayHandler {
  constructor(positionBuilder, triggerStrategyBuilder, dynamicOverlayService, directionService) {
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.dynamicOverlayService = dynamicOverlayService;
    this.directionService = directionService;
    this._context = {};
    this._trigger = NbTrigger.NOOP;
    this._disabled = false;
    this._position = NbPosition.TOP;
    this._adjustment = NbAdjustment.NOOP;
    this._offset = 15;
    this._overlayConfig = {};
    this.changes = {};
    this.destroy$ = new Subject();
  }
  host(host) {
    this.changes.host = new NbDynamicOverlayChange(this._host, host);
    this._host = host;
    return this;
  }
  trigger(trigger2) {
    this.changes.trigger = new NbDynamicOverlayChange(this._trigger, trigger2);
    this._trigger = trigger2;
    return this;
  }
  disabled(disabled) {
    this.changes.disabled = new NbDynamicOverlayChange(this._disabled, disabled);
    this._disabled = disabled;
    return this;
  }
  position(position) {
    this.changes.position = new NbDynamicOverlayChange(this._position, position);
    this._position = position;
    return this;
  }
  adjustment(adjustment) {
    this.changes.adjustment = new NbDynamicOverlayChange(this._adjustment, adjustment);
    this._adjustment = adjustment;
    return this;
  }
  componentType(componentType) {
    this.changes.componentType = new NbDynamicOverlayChange(this._componentType, componentType);
    this._componentType = componentType;
    return this;
  }
  content(content) {
    this.changes.content = new NbDynamicOverlayChange(this._content, content);
    this._content = content;
    return this;
  }
  context(context) {
    this.changes.context = new NbDynamicOverlayChange(this._context, context);
    this._context = context;
    return this;
  }
  offset(offset) {
    this.changes.offset = new NbDynamicOverlayChange(this._offset, offset);
    this._offset = offset;
    return this;
  }
  overlayConfig(overlayConfig) {
    this.changes.overlayConfig = new NbDynamicOverlayChange(this._overlayConfig, overlayConfig);
    this._overlayConfig = overlayConfig;
    return this;
  }
  build() {
    if (!this._componentType || !this._host) {
      throw Error(`NbDynamicOverlayHandler: at least 'componentType' and 'host' should be
      passed before building a dynamic overlay.`);
    }
    this.dynamicOverlay = this.dynamicOverlayService.create(this._componentType, this._content, this._context, this.createPositionStrategy(), this._overlayConfig, this._disabled);
    this.connect();
    this.clearChanges();
    return this.dynamicOverlay;
  }
  rebuild() {
    if (!this.dynamicOverlay) {
      return void 0;
    }
    if (this.isPositionStrategyUpdateRequired()) {
      this.dynamicOverlay.setPositionStrategy(this.createPositionStrategy());
    }
    if (this.isTriggerStrategyUpdateRequired()) {
      this.connect();
    }
    if (this.isContainerRerenderRequired()) {
      this.dynamicOverlay.setContentAndContext(this._content, this._context);
    }
    if (this.isComponentTypeUpdateRequired()) {
      this.dynamicOverlay.setComponent(this._componentType);
    }
    if (this.isOverlayConfigUpdateRequired()) {
      this.dynamicOverlay.setOverlayConfig(this._overlayConfig);
    }
    if (this.isDisabledUpdated()) {
      this.dynamicOverlay.setDisabled(this._disabled);
    }
    this.clearChanges();
    return this.dynamicOverlay;
  }
  connect() {
    if (!this.dynamicOverlay) {
      throw new Error(`NbDynamicOverlayHandler: cannot connect to DynamicOverlay
      as it is not created yet. Call build() first`);
    }
    this.disconnect();
    this.subscribeOnTriggers(this.dynamicOverlay);
    this.subscribeOnDirectionChange();
  }
  disconnect() {
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  destroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.disconnect();
    this.clearChanges();
    if (this.dynamicOverlay) {
      this.dynamicOverlay.dispose();
    }
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this._host).position(this._position).adjustment(this._adjustment).offset(this._offset).direction(this.directionService.getDirection());
  }
  subscribeOnTriggers(dynamicOverlay) {
    this.triggerStrategy = this.triggerStrategyBuilder.trigger(this._trigger).host(this._host.nativeElement).container(() => dynamicOverlay.getContainer()).build();
    this.triggerStrategy.show$.subscribe(() => dynamicOverlay.show());
    this.triggerStrategy.hide$.subscribe(() => dynamicOverlay.hide());
  }
  subscribeOnDirectionChange() {
    this.directionService.onDirectionChange().pipe(skip(1), takeUntil(this.destroy$)).subscribe(() => {
      this.dynamicOverlay.setPositionStrategy(this.createPositionStrategy());
    });
  }
  isContainerRerenderRequired() {
    return this.isContentUpdated() || this.isContextUpdated() || this.isPositionStrategyUpdateRequired();
  }
  isPositionStrategyUpdateRequired() {
    return this.isAdjustmentUpdated() || this.isPositionUpdated() || this.isOffsetUpdated() || this.isHostUpdated();
  }
  isTriggerStrategyUpdateRequired() {
    return this.isTriggerUpdated() || this.isHostUpdated();
  }
  isComponentTypeUpdateRequired() {
    return this.isComponentTypeUpdated();
  }
  isOverlayConfigUpdateRequired() {
    return this.isOverlayConfigUpdated();
  }
  isComponentTypeUpdated() {
    return this.changes.componentType && this.changes.componentType.isChanged();
  }
  isContentUpdated() {
    return this.changes.content && this.changes.content.isChanged();
  }
  isContextUpdated() {
    return this.changes.context && this.changes.context.isChanged();
  }
  isAdjustmentUpdated() {
    return this.changes.adjustment && this.changes.adjustment.isChanged();
  }
  isPositionUpdated() {
    return this.changes.position && this.changes.position.isChanged();
  }
  isHostUpdated() {
    return this.changes.host && this.changes.host.isChanged();
  }
  isTriggerUpdated() {
    return this.changes.trigger && this.changes.trigger.isChanged();
  }
  isOffsetUpdated() {
    return this.changes.offset && this.changes.offset.isChanged();
  }
  isOverlayConfigUpdated() {
    return this.changes.overlayConfig && this.changes.overlayConfig.isChanged();
  }
  isDisabledUpdated() {
    return this.changes.disabled && this.changes.disabled.isChanged();
  }
  clearChanges() {
    this.changes = {};
  }
  static {
    this.ɵfac = function NbDynamicOverlayHandler_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbDynamicOverlayHandler)(ɵɵinject(NbPositionBuilderService), ɵɵinject(NbTriggerStrategyBuilderService), ɵɵinject(NbDynamicOverlay), ɵɵinject(NbLayoutDirectionService));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbDynamicOverlayHandler,
      factory: _NbDynamicOverlayHandler.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDynamicOverlayHandler, [{
    type: Injectable
  }], () => [{
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbDynamicOverlay
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var NbPopoverComponent = class _NbPopoverComponent extends NbPositionedContainerComponent {
  renderContent() {
    this.detachContent();
    this.attachContent();
  }
  detachContent() {
    this.overlayContainer.detach();
  }
  attachContent() {
    if (this.content instanceof TemplateRef) {
      this.attachTemplate();
    } else if (this.content instanceof Type) {
      this.attachComponent();
    } else {
      this.attachString();
    }
  }
  attachTemplate() {
    this.overlayContainer.attachTemplatePortal(new NbTemplatePortal(this.content, null, {
      $implicit: this.context
    }));
  }
  attachComponent() {
    const portal = new NbComponentPortal(this.content, null, null, this.cfr);
    const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
    ref.changeDetectorRef.detectChanges();
  }
  attachString() {
    this.overlayContainer.attachStringContent(this.content);
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbPopoverComponent_BaseFactory;
      return function NbPopoverComponent_Factory(__ngFactoryType__) {
        return (ɵNbPopoverComponent_BaseFactory || (ɵNbPopoverComponent_BaseFactory = ɵɵgetInheritedFactory(_NbPopoverComponent)))(__ngFactoryType__ || _NbPopoverComponent);
      };
    })();
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbPopoverComponent,
      selectors: [["nb-popover"]],
      viewQuery: function NbPopoverComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbOverlayContainerComponent, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
        }
      },
      inputs: {
        content: "content",
        context: "context",
        cfr: "cfr"
      },
      standalone: false,
      features: [ɵɵInheritDefinitionFeature],
      decls: 2,
      vars: 0,
      consts: [[1, "arrow"]],
      template: function NbPopoverComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelement(0, "span", 0)(1, "nb-overlay-container");
        }
      },
      dependencies: [NbOverlayContainerComponent],
      styles: ["[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverComponent, [{
    type: Component,
    args: [{
      selector: "nb-popover",
      template: `
    <span class="arrow"></span>
    <nb-overlay-container></nb-overlay-container>
  `,
      standalone: false,
      styles: [":host .arrow{position:absolute;width:0;height:0}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent]
    }],
    content: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    cfr: [{
      type: Input
    }]
  });
})();
var NbPopoverDirective = class _NbPopoverDirective {
  /**
   * Container position will be changes automatically based on this strategy if container can't fit view port.
   * Set this property to `noop` value if you want to disable automatically adjustment.
   * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
   * */
  get adjustment() {
    return this._adjustment;
  }
  set adjustment(value) {
    this._adjustment = value;
  }
  get popoverClass() {
    return this._popoverClass;
  }
  set popoverClass(value) {
    if (value !== this.popoverClass) {
      this._popoverClass = value;
      this.overlayConfig = {
        panelClass: this.popoverClass
      };
    }
  }
  get isShown() {
    return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
  }
  constructor(hostRef, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.popoverComponent = NbPopoverComponent;
    this.destroy$ = new Subject();
    this.context = {};
    this.position = NbPosition.TOP;
    this._adjustment = NbAdjustment.CLOCKWISE;
    this.trigger = NbTrigger.CLICK;
    this.offset = 15;
    this.disabled = false;
    this._popoverClass = "";
    this.nbPopoverShowStateChange = new EventEmitter();
    this.overlayConfig = {
      panelClass: this.popoverClass
    };
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(this.popoverComponent);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.dynamicOverlay.isShown.pipe(skip(1), takeUntil(this.destroy$)).subscribe((isShown) => this.nbPopoverShowStateChange.emit({
      isShown
    }));
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).disabled(this.disabled).offset(this.offset).adjustment(this.adjustment).content(this.content).context(this.context).overlayConfig(this.overlayConfig);
  }
  static {
    this.ɵfac = function NbPopoverDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbPopoverDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbDynamicOverlayHandler));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbPopoverDirective,
      selectors: [["", "nbPopover", ""]],
      inputs: {
        content: [0, "nbPopover", "content"],
        context: [0, "nbPopoverContext", "context"],
        position: [0, "nbPopoverPlacement", "position"],
        adjustment: [0, "nbPopoverAdjustment", "adjustment"],
        trigger: [0, "nbPopoverTrigger", "trigger"],
        offset: [0, "nbPopoverOffset", "offset"],
        disabled: [0, "nbTooltipDisabled", "disabled"],
        popoverClass: [0, "nbPopoverClass", "popoverClass"]
      },
      outputs: {
        nbPopoverShowStateChange: "nbPopoverShowStateChange"
      },
      exportAs: ["nbPopover"],
      standalone: false,
      features: [ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPopover]",
      exportAs: "nbPopover",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbDynamicOverlayHandler
  }], {
    content: [{
      type: Input,
      args: ["nbPopover"]
    }],
    context: [{
      type: Input,
      args: ["nbPopoverContext"]
    }],
    position: [{
      type: Input,
      args: ["nbPopoverPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbPopoverAdjustment"]
    }],
    trigger: [{
      type: Input,
      args: ["nbPopoverTrigger"]
    }],
    offset: [{
      type: Input,
      args: ["nbPopoverOffset"]
    }],
    disabled: [{
      type: Input,
      args: ["nbTooltipDisabled"]
    }],
    popoverClass: [{
      type: Input,
      args: ["nbPopoverClass"]
    }],
    nbPopoverShowStateChange: [{
      type: Output
    }]
  });
})();
var NbPopoverModule = class _NbPopoverModule {
  static {
    this.ɵfac = function NbPopoverModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbPopoverModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbPopoverModule,
      declarations: [NbPopoverDirective, NbPopoverComponent],
      imports: [NbOverlayModule],
      exports: [NbPopoverDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbOverlayModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverModule, [{
    type: NgModule,
    args: [{
      imports: [NbOverlayModule],
      declarations: [NbPopoverDirective, NbPopoverComponent],
      exports: [NbPopoverDirective]
    }]
  }], null, null);
})();
var NbContextMenuComponent = class _NbContextMenuComponent extends NbPositionedContainerComponent {
  constructor() {
    super(...arguments);
    this.items = [];
    this.context = {
      items: []
    };
  }
  /**
   * The method is empty since we don't need to do anything additionally
   * render is handled by change detection
   */
  renderContent() {
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbContextMenuComponent_BaseFactory;
      return function NbContextMenuComponent_Factory(__ngFactoryType__) {
        return (ɵNbContextMenuComponent_BaseFactory || (ɵNbContextMenuComponent_BaseFactory = ɵɵgetInheritedFactory(_NbContextMenuComponent)))(__ngFactoryType__ || _NbContextMenuComponent);
      };
    })();
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbContextMenuComponent,
      selectors: [["nb-context-menu"]],
      inputs: {
        items: "items",
        tag: "tag",
        context: "context"
      },
      standalone: false,
      features: [ɵɵInheritDefinitionFeature],
      decls: 1,
      vars: 2,
      consts: [[1, "context-menu", 3, "items", "tag"]],
      template: function NbContextMenuComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelement(0, "nb-menu", 0);
        }
        if (rf & 2) {
          ɵɵproperty("items", ctx.context.items)("tag", ctx.context.tag);
        }
      },
      dependencies: [NbMenuComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuComponent, [{
    type: Component,
    args: [{
      selector: "nb-context-menu",
      template: `
    <nb-menu class="context-menu" [items]="context.items" [tag]="context.tag"></nb-menu>
  `,
      standalone: false
    }]
  }], null, {
    items: [{
      type: Input
    }],
    tag: [{
      type: Input
    }],
    context: [{
      type: Input
    }]
  });
})();
var NbContextMenuDirective = class _NbContextMenuDirective {
  /**
   * Position will be calculated relatively host element based on the position.
   * Can be top, right, bottom and left.
   * */
  get position() {
    return this._position;
  }
  set position(value) {
    if (value !== this.position) {
      this._position = value;
      this.updateOverlayContext();
    }
  }
  /**
   * Set NbMenu tag, which helps identify menu when working with NbMenuService.
   * */
  get tag() {
    return this._tag;
  }
  set tag(value) {
    if (value !== this.tag) {
      this._tag = value;
      this.updateOverlayContext();
    }
  }
  /**
   * Basic menu items, will be passed to the internal NbMenuComponent.
   * */
  get items() {
    return this._items;
  }
  set items(items) {
    this.validateItems(items);
    this._items = items;
    this.updateOverlayContext();
  }
  get contextMenuClass() {
    return this._contextMenuClass;
  }
  set contextMenuClass(value) {
    if (value !== this.contextMenuClass) {
      this._contextMenuClass = value;
      this.overlayConfig = {
        panelClass: this.contextMenuClass
      };
    }
  }
  constructor(hostRef, menuService, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.menuService = menuService;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.contextMenuHost = true;
    this._position = NbPosition.BOTTOM;
    this.adjustment = NbAdjustment.CLOCKWISE;
    this.trigger = NbTrigger.CLICK;
    this._contextMenuClass = "";
    this.overlayConfig = {
      panelClass: this.contextMenuClass
    };
    this.overlayContext = {
      items: this.items,
      tag: this.tag,
      position: this.position
    };
    this.destroy$ = new Subject();
    this._items = [];
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(NbContextMenuComponent);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.subscribeOnItemClick();
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).adjustment(this.adjustment).context(this.overlayContext).overlayConfig(this.overlayConfig);
  }
  /*
   * NbMenuComponent will crash if don't pass menu items to it.
   * So, we just validating them and throw custom obvious error.
   * */
  validateItems(items) {
    if (!items || !items.length) {
      throw Error(`List of menu items expected, but given: ${items}`);
    }
  }
  subscribeOnItemClick() {
    this.menuService.onItemClick().pipe(filter(({
      tag
    }) => tag === this.tag && this.trigger !== NbTrigger.NOOP), takeUntil(this.destroy$)).subscribe(() => this.hide());
  }
  updateOverlayContext() {
    this.overlayContext = {
      items: this.items,
      position: this.position,
      tag: this.tag
    };
  }
  static {
    this.ɵfac = function NbContextMenuDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbContextMenuDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbMenuService), ɵɵdirectiveInject(NbDynamicOverlayHandler));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbContextMenuDirective,
      selectors: [["", "nbContextMenu", ""]],
      hostVars: 2,
      hostBindings: function NbContextMenuDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("context-menu-host", ctx.contextMenuHost);
        }
      },
      inputs: {
        position: [0, "nbContextMenuPlacement", "position"],
        adjustment: [0, "nbContextMenuAdjustment", "adjustment"],
        tag: [0, "nbContextMenuTag", "tag"],
        items: [0, "nbContextMenu", "items"],
        trigger: [0, "nbContextMenuTrigger", "trigger"],
        contextMenuClass: [0, "nbContextMenuClass", "contextMenuClass"]
      },
      standalone: false,
      features: [ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuDirective, [{
    type: Directive,
    args: [{
      selector: "[nbContextMenu]",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbMenuService
  }, {
    type: NbDynamicOverlayHandler
  }], {
    contextMenuHost: [{
      type: HostBinding,
      args: ["class.context-menu-host"]
    }],
    position: [{
      type: Input,
      args: ["nbContextMenuPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbContextMenuAdjustment"]
    }],
    tag: [{
      type: Input,
      args: ["nbContextMenuTag"]
    }],
    items: [{
      type: Input,
      args: ["nbContextMenu"]
    }],
    trigger: [{
      type: Input,
      args: ["nbContextMenuTrigger"]
    }],
    contextMenuClass: [{
      type: Input,
      args: ["nbContextMenuClass"]
    }]
  });
})();
var NbContextMenuModule = class _NbContextMenuModule {
  static {
    this.ɵfac = function NbContextMenuModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbContextMenuModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbContextMenuModule,
      declarations: [NbContextMenuDirective, NbContextMenuComponent],
      imports: [CommonModule, NbOverlayModule, NbMenuModule],
      exports: [NbContextMenuDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CommonModule, NbOverlayModule, NbMenuModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbMenuModule],
      exports: [NbContextMenuDirective],
      declarations: [NbContextMenuDirective, NbContextMenuComponent]
    }]
  }], null, null);
})();
var NbProgressBarComponent = class _NbProgressBarComponent {
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.value = 0;
    this.status = "basic";
    this.size = "medium";
    this.displayValue = false;
  }
  static {
    this.ɵfac = function NbProgressBarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbProgressBarComponent)(ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbProgressBarComponent,
      selectors: [["nb-progress-bar"]],
      hostVars: 26,
      hostBindings: function NbProgressBarComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
        }
      },
      inputs: {
        value: "value",
        status: "status",
        size: "size",
        displayValue: "displayValue"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 4,
      vars: 3,
      consts: [[1, "progress-container"], [1, "progress-value"], [4, "ngIf"]],
      template: function NbProgressBarComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵelementStart(0, "div", 0)(1, "div", 1);
          ɵɵtemplate(2, NbProgressBarComponent_span_2_Template, 2, 1, "span", 2);
          ɵɵprojection(3);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵstyleProp("width", ctx.value, "%");
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.displayValue);
        }
      },
      dependencies: [NgIf],
      styles: ["[_nghost-%COMP%]{display:block}.progress-container[_ngcontent-%COMP%]{overflow:hidden}.progress-value[_ngcontent-%COMP%]{height:100%;text-align:center;overflow:hidden}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbProgressBarComponent, [{
    type: Component,
    args: [{
      selector: "nb-progress-bar",
      template: `
    <div class="progress-container">
      <div class="progress-value" [style.width.%]="value">
        <span *ngIf="displayValue">{{ value }}%</span>
        <ng-content></ng-content>
      </div>
    </div>
  `,
      standalone: false,
      styles: [":host{display:block}.progress-container{overflow:hidden}.progress-value{height:100%;text-align:center;overflow:hidden}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    value: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    displayValue: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NbProgressBarModule = class _NbProgressBarModule {
  static {
    this.ɵfac = function NbProgressBarModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbProgressBarModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbProgressBarModule,
      declarations: [NbProgressBarComponent],
      imports: [NbSharedModule],
      exports: [NbProgressBarComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbProgressBarModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [NbProgressBarComponent],
      exports: [NbProgressBarComponent]
    }]
  }], null, null);
})();
var NbAlertComponent = class _NbAlertComponent {
  /**
   * Shows `close` icon
   */
  get closable() {
    return this._closable;
  }
  set closable(value) {
    this._closable = convertToBoolProperty(value);
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.size = "";
    this.status = "basic";
    this.accent = "";
    this.outline = "";
    this._closable = false;
    this.close = new EventEmitter();
  }
  /**
   * Emits the removed chip event
   */
  onClose() {
    this.close.emit();
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get primaryAccent() {
    return this.accent === "primary";
  }
  get successAccent() {
    return this.accent === "success";
  }
  get infoAccent() {
    return this.accent === "info";
  }
  get warningAccent() {
    return this.accent === "warning";
  }
  get dangerAccent() {
    return this.accent === "danger";
  }
  get basicAccent() {
    return this.accent === "basic";
  }
  get controlAccent() {
    return this.accent === "control";
  }
  get primaryOutline() {
    return this.outline === "primary";
  }
  get successOutline() {
    return this.outline === "success";
  }
  get infoOutline() {
    return this.outline === "info";
  }
  get warningOutline() {
    return this.outline === "warning";
  }
  get dangerOutline() {
    return this.outline === "danger";
  }
  get basicOutline() {
    return this.outline === "basic";
  }
  get controlOutline() {
    return this.outline === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  static {
    this.ɵfac = function NbAlertComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbAlertComponent)(ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbAlertComponent,
      selectors: [["nb-alert"]],
      hostVars: 56,
      hostBindings: function NbAlertComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("closable", ctx.closable)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent-primary", ctx.primaryAccent)("accent-success", ctx.successAccent)("accent-info", ctx.infoAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent)("outline-primary", ctx.primaryOutline)("outline-success", ctx.successOutline)("outline-info", ctx.infoOutline)("outline-warning", ctx.warningOutline)("outline-danger", ctx.dangerOutline)("outline-basic", ctx.basicOutline)("outline-control", ctx.controlOutline);
        }
      },
      inputs: {
        size: "size",
        status: "status",
        accent: "accent",
        outline: "outline",
        closable: "closable"
      },
      outputs: {
        close: "close"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 2,
      vars: 1,
      consts: [["type", "button", "class", "close", "aria-label", "Close", 3, "click", 4, "ngIf"], ["type", "button", "aria-label", "Close", 1, "close", 3, "click"], ["aria-hidden", "true"]],
      template: function NbAlertComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, NbAlertComponent_button_0_Template, 3, 0, "button", 0);
          ɵɵprojection(1);
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.closable);
        }
      },
      dependencies: [NgIf],
      styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative}[dir=ltr]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{right:0}[dir=rtl]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{left:0}.close[_ngcontent-%COMP%]{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAlertComponent, [{
    type: Component,
    args: [{
      selector: "nb-alert",
      template: `
    <button *ngIf="closable" type="button" class="close" aria-label="Close" (click)="onClose()">
      <span aria-hidden="true">&times;</span>
    </button>
    <ng-content></ng-content>
  `,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column;position:relative}[dir=ltr] :host .close{right:0}[dir=rtl] :host .close{left:0}.close{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    accent: [{
      type: Input
    }],
    outline: [{
      type: Input
    }],
    closable: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.closable"]
    }],
    close: [{
      type: Output
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    primaryAccent: [{
      type: HostBinding,
      args: ["class.accent-primary"]
    }],
    successAccent: [{
      type: HostBinding,
      args: ["class.accent-success"]
    }],
    infoAccent: [{
      type: HostBinding,
      args: ["class.accent-info"]
    }],
    warningAccent: [{
      type: HostBinding,
      args: ["class.accent-warning"]
    }],
    dangerAccent: [{
      type: HostBinding,
      args: ["class.accent-danger"]
    }],
    basicAccent: [{
      type: HostBinding,
      args: ["class.accent-basic"]
    }],
    controlAccent: [{
      type: HostBinding,
      args: ["class.accent-control"]
    }],
    primaryOutline: [{
      type: HostBinding,
      args: ["class.outline-primary"]
    }],
    successOutline: [{
      type: HostBinding,
      args: ["class.outline-success"]
    }],
    infoOutline: [{
      type: HostBinding,
      args: ["class.outline-info"]
    }],
    warningOutline: [{
      type: HostBinding,
      args: ["class.outline-warning"]
    }],
    dangerOutline: [{
      type: HostBinding,
      args: ["class.outline-danger"]
    }],
    basicOutline: [{
      type: HostBinding,
      args: ["class.outline-basic"]
    }],
    controlOutline: [{
      type: HostBinding,
      args: ["class.outline-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NbAlertModule = class _NbAlertModule {
  static {
    this.ɵfac = function NbAlertModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbAlertModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbAlertModule,
      declarations: [NbAlertComponent],
      imports: [NbSharedModule],
      exports: [NbAlertComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAlertModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [NbAlertComponent],
      exports: [NbAlertComponent]
    }]
  }], null, null);
})();
var NbFormFieldControl = class _NbFormFieldControl {
  static {
    this.ɵfac = function NbFormFieldControl_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbFormFieldControl)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbFormFieldControl,
      factory: _NbFormFieldControl.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldControl, [{
    type: Injectable
  }], null, null);
})();
var NbFormFieldControlConfig = class _NbFormFieldControlConfig {
  constructor() {
    this.supportsPrefix = true;
    this.supportsSuffix = true;
  }
  static {
    this.ɵfac = function NbFormFieldControlConfig_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbFormFieldControlConfig)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbFormFieldControlConfig,
      factory: _NbFormFieldControlConfig.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldControlConfig, [{
    type: Injectable
  }], null, null);
})();
var NbInputDirective = class _NbInputDirective {
  /**
   * If set element will fill container. `false` by default.
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(elementRef, focusMonitor, renderer, zone, statusService) {
    this.elementRef = elementRef;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.destroy$ = new Subject();
    this.fieldSize = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this._fullWidth = false;
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.fieldSize);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(false);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
  }
  ngDoCheck() {
    const isDisabled = this.elementRef.nativeElement.disabled;
    if (isDisabled !== this.disabled$.value) {
      this.disabled$.next(isDisabled);
    }
  }
  ngOnChanges({
    status,
    fieldSize,
    fullWidth
  }) {
    if (status) {
      this.status$.next(this.status);
    }
    if (fieldSize) {
      this.size$.next(this.fieldSize);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngOnInit() {
    this.focusMonitor.monitor(this.elementRef).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.elementRef)), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  get tiny() {
    return this.fieldSize === "tiny";
  }
  get small() {
    return this.fieldSize === "small";
  }
  get medium() {
    return this.fieldSize === "medium";
  }
  get large() {
    return this.fieldSize === "large";
  }
  get giant() {
    return this.fieldSize === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get round() {
    return this.shape === "round";
  }
  static {
    this.ɵfac = function NbInputDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbInputDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbInputDirective,
      selectors: [["input", "nbInput", ""], ["textarea", "nbInput", ""]],
      hostVars: 34,
      hostBindings: function NbInputDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("input-full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
        }
      },
      inputs: {
        fieldSize: "fieldSize",
        status: "status",
        shape: "shape",
        fullWidth: "fullWidth"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbFormFieldControl,
        useExisting: _NbInputDirective
      }]), ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInputDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbInput],textarea[nbInput]",
      providers: [{
        provide: NbFormFieldControl,
        useExisting: NbInputDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    fieldSize: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.input-full-width"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }]
  });
})();
var NbChatFormComponent = class _NbChatFormComponent {
  constructor(cd, domSanitizer) {
    this.cd = cd;
    this.domSanitizer = domSanitizer;
    this.status = "basic";
    this.inputFocus = false;
    this.inputHover = false;
    this.droppedFiles = [];
    this.imgDropTypes = ["image/png", "image/jpeg", "image/gif"];
    this.message = "";
    this.messagePlaceholder = "Type a message";
    this.buttonTitle = "";
    this.buttonIcon = "paper-plane-outline";
    this.showButton = true;
    this.dropFiles = false;
    this.dropFilePlaceholder = "Drop file to send";
    this.send = new EventEmitter();
    this.onInputChange = new EventEmitter();
    this.fileOver = false;
  }
  onDrop(event) {
    if (this.dropFiles) {
      event.preventDefault();
      event.stopPropagation();
      this.fileOver = false;
      if (event.dataTransfer && event.dataTransfer.files) {
        for (const file of event.dataTransfer.files) {
          const res = file;
          if (this.imgDropTypes.includes(file.type)) {
            const fr = new FileReader();
            fr.onload = (e) => {
              res.src = e.target.result;
              res.urlStyle = this.domSanitizer.bypassSecurityTrustStyle(`url(${res.src})`);
              this.cd.detectChanges();
            };
            fr.readAsDataURL(file);
          }
          this.droppedFiles.push(res);
        }
      }
    }
  }
  removeFile(file) {
    const index = this.droppedFiles.indexOf(file);
    if (index >= 0) {
      this.droppedFiles.splice(index, 1);
    }
  }
  onDragOver(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.dropFiles) {
      this.fileOver = true;
    }
  }
  onDragLeave(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.dropFiles) {
      this.fileOver = false;
    }
  }
  sendMessage() {
    if (this.droppedFiles.length || String(this.message).trim().length) {
      this.send.emit({
        message: this.message,
        files: this.droppedFiles
      });
      this.message = "";
      this.droppedFiles = [];
    }
  }
  setStatus(status) {
    if (this.status !== status) {
      this.status = status;
      this.cd.detectChanges();
    }
  }
  getInputStatus() {
    if (this.fileOver) {
      return this.getHighlightStatus();
    }
    if (this.inputFocus || this.inputHover) {
      return this.status;
    }
    return "basic";
  }
  getButtonStatus() {
    return this.getHighlightStatus();
  }
  getHighlightStatus() {
    if (this.status === "basic" || this.status === "control") {
      return "primary";
    }
    return this.status;
  }
  onModelChange(value) {
    this.onInputChange.emit(value);
  }
  static {
    this.ɵfac = function NbChatFormComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatFormComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DomSanitizer));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbChatFormComponent,
      selectors: [["nb-chat-form"]],
      hostVars: 2,
      hostBindings: function NbChatFormComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("drop", function NbChatFormComponent_drop_HostBindingHandler($event) {
            return ctx.onDrop($event);
          })("dragover", function NbChatFormComponent_dragover_HostBindingHandler($event) {
            return ctx.onDragOver($event);
          })("dragleave", function NbChatFormComponent_dragleave_HostBindingHandler($event) {
            return ctx.onDragLeave($event);
          });
        }
        if (rf & 2) {
          ɵɵclassProp("file-over", ctx.fileOver);
        }
      },
      inputs: {
        message: "message",
        messagePlaceholder: "messagePlaceholder",
        buttonTitle: "buttonTitle",
        buttonIcon: "buttonIcon",
        showButton: "showButton",
        dropFiles: "dropFiles",
        dropFilePlaceholder: "dropFilePlaceholder"
      },
      outputs: {
        send: "send",
        onInputChange: "onInputChange"
      },
      standalone: false,
      decls: 4,
      vars: 7,
      consts: [["title", ""], ["class", "dropped-files", 4, "ngIf"], [1, "message-row"], ["nbInput", "", "fullWidth", "", "type", "text", 3, "focus", "blur", "mouseenter", "mouseleave", "ngModelChange", "keyup.enter", "status", "ngModel", "placeholder"], ["nbButton", "", "class", "send-button", 3, "status", "with-icon", "click", 4, "ngIf"], [1, "dropped-files"], [4, "ngFor", "ngForOf"], [3, "background-image", 4, "ngIf"], [4, "ngIf"], [1, "remove", 3, "click"], ["icon", "file-text-outline", "pack", "nebular-essentials"], ["nbButton", "", 1, "send-button", 3, "click", "status"], ["pack", "nebular-essentials", 3, "icon", 4, "ngIf", "ngIfElse"], ["pack", "nebular-essentials", 3, "icon"]],
      template: function NbChatFormComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbChatFormComponent_div_0_Template, 2, 1, "div", 1);
          ɵɵelementStart(1, "div", 2)(2, "input", 3);
          ɵɵlistener("focus", function NbChatFormComponent_Template_input_focus_2_listener() {
            return ctx.inputFocus = true;
          })("blur", function NbChatFormComponent_Template_input_blur_2_listener() {
            return ctx.inputFocus = false;
          })("mouseenter", function NbChatFormComponent_Template_input_mouseenter_2_listener() {
            return ctx.inputHover = true;
          })("mouseleave", function NbChatFormComponent_Template_input_mouseleave_2_listener() {
            return ctx.inputHover = false;
          });
          ɵɵtwoWayListener("ngModelChange", function NbChatFormComponent_Template_input_ngModelChange_2_listener($event) {
            ɵɵtwoWayBindingSet(ctx.message, $event) || (ctx.message = $event);
            return $event;
          });
          ɵɵlistener("ngModelChange", function NbChatFormComponent_Template_input_ngModelChange_2_listener($event) {
            return ctx.onModelChange($event);
          })("keyup.enter", function NbChatFormComponent_Template_input_keyup_enter_2_listener() {
            return ctx.sendMessage();
          });
          ɵɵelementEnd();
          ɵɵtemplate(3, NbChatFormComponent_button_3_Template, 4, 5, "button", 4);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.droppedFiles == null ? null : ctx.droppedFiles.length);
          ɵɵadvance(2);
          ɵɵclassProp("with-button", ctx.showButton);
          ɵɵpropertyInterpolate("placeholder", ctx.fileOver ? ctx.dropFilePlaceholder : ctx.messagePlaceholder);
          ɵɵproperty("status", ctx.getInputStatus());
          ɵɵtwoWayProperty("ngModel", ctx.message);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.showButton);
        }
      },
      dependencies: [NgForOf, NgIf, DefaultValueAccessor, NgControlStatus, NgModel, NbIconComponent, NbInputDirective, NbButtonComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatFormComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-form",
      template: `
    <div class="dropped-files" *ngIf="droppedFiles?.length">
      <ng-container *ngFor="let file of droppedFiles">
        <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle">
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>

        <div *ngIf="!file.urlStyle">
          <nb-icon icon="file-text-outline" pack="nebular-essentials"></nb-icon>
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>
      </ng-container>
    </div>
    <div class="message-row">
      <input
        nbInput
        fullWidth
        [status]="getInputStatus()"
        (focus)="inputFocus = true"
        (blur)="inputFocus = false"
        (mouseenter)="inputHover = true"
        (mouseleave)="inputHover = false"
        [(ngModel)]="message"
        (ngModelChange)="onModelChange($event)"
        [class.with-button]="showButton"
        type="text"
        placeholder="{{ fileOver ? dropFilePlaceholder : messagePlaceholder }}"
        (keyup.enter)="sendMessage()"
      />
      <button
        nbButton
        [status]="getButtonStatus()"
        *ngIf="showButton"
        [class.with-icon]="!buttonTitle"
        (click)="sendMessage()"
        class="send-button"
      >
        <nb-icon *ngIf="!buttonTitle; else title" [icon]="buttonIcon" pack="nebular-essentials"></nb-icon>
        <ng-template #title>{{ buttonTitle }}</ng-template>
      </button>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: DomSanitizer
  }], {
    message: [{
      type: Input
    }],
    messagePlaceholder: [{
      type: Input
    }],
    buttonTitle: [{
      type: Input
    }],
    buttonIcon: [{
      type: Input
    }],
    showButton: [{
      type: Input
    }],
    dropFiles: [{
      type: Input
    }],
    dropFilePlaceholder: [{
      type: Input
    }],
    send: [{
      type: Output
    }],
    onInputChange: [{
      type: Output
    }],
    fileOver: [{
      type: HostBinding,
      args: ["class.file-over"]
    }],
    onDrop: [{
      type: HostListener,
      args: ["drop", ["$event"]]
    }],
    onDragOver: [{
      type: HostListener,
      args: ["dragover", ["$event"]]
    }],
    onDragLeave: [{
      type: HostListener,
      args: ["dragleave", ["$event"]]
    }]
  });
})();
var NbChatCustomMessageService = class _NbChatCustomMessageService {
  constructor() {
    this.customMessages = /* @__PURE__ */ new Map();
  }
  register(type, instance) {
    this.customMessages.set(type, instance);
  }
  unregister(type) {
    return this.customMessages.delete(type);
  }
  getInstance(type) {
    return this.customMessages.get(type);
  }
  static {
    this.ɵfac = function NbChatCustomMessageService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatCustomMessageService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbChatCustomMessageService,
      factory: _NbChatCustomMessageService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatCustomMessageService, [{
    type: Injectable
  }], null, null);
})();
var NbChatMessageTextComponent = class _NbChatMessageTextComponent {
  constructor() {
    this.dateFormat = "shortTime";
  }
  static {
    this.ɵfac = function NbChatMessageTextComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatMessageTextComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbChatMessageTextComponent,
      selectors: [["nb-chat-message-text"]],
      inputs: {
        sender: "sender",
        message: "message",
        date: "date",
        dateFormat: "dateFormat"
      },
      standalone: false,
      decls: 2,
      vars: 2,
      consts: [["class", "sender", 4, "ngIf"], ["class", "text", 4, "ngIf"], [1, "sender"], [1, "text"]],
      template: function NbChatMessageTextComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbChatMessageTextComponent_p_0_Template, 5, 5, "p", 0)(1, NbChatMessageTextComponent_p_1_Template, 2, 1, "p", 1);
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.sender || ctx.date);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.message);
        }
      },
      dependencies: [NgIf, DatePipe],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageTextComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-text",
      template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date  | date: dateFormat }}</time></p>
    <p class="text" *ngIf="message">{{ message }}</p>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    sender: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }]
  });
})();
var NbChatMessageFileComponent = class _NbChatMessageFileComponent {
  /**
   * Message file path
   * @type {Date}
   */
  set files(files) {
    this.readyFiles = (files || []).map((file) => {
      const isImage = this.isImage(file);
      return __spreadProps(__spreadValues({}, file), {
        urlStyle: isImage && this.domSanitizer.bypassSecurityTrustStyle(`url(${file.url})`),
        isImage
      });
    });
    this.cd.detectChanges();
  }
  constructor(cd, domSanitizer) {
    this.cd = cd;
    this.domSanitizer = domSanitizer;
    this.dateFormat = "shortTime";
  }
  isImage(file) {
    const type = file.type;
    if (type) {
      return ["image/png", "image/jpeg", "image/gif"].includes(type);
    }
    return false;
  }
  static {
    this.ɵfac = function NbChatMessageFileComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatMessageFileComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DomSanitizer));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbChatMessageFileComponent,
      selectors: [["nb-chat-message-file"]],
      inputs: {
        message: "message",
        sender: "sender",
        date: "date",
        dateFormat: "dateFormat",
        files: "files"
      },
      standalone: false,
      decls: 4,
      vars: 7,
      consts: [[3, "sender", "date", "dateFormat", "message"], [4, "ngIf"], [1, "message-content-group"], ["target", "_blank", 3, "href", 4, "ngFor", "ngForOf"], ["target", "_blank", 3, "href"], [3, "icon", 4, "ngIf"], [3, "background-image", 4, "ngIf"], [3, "icon"]],
      template: function NbChatMessageFileComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "nb-chat-message-text", 0);
          ɵɵtext(1);
          ɵɵelementEnd();
          ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_Template, 3, 1, "ng-container", 1)(3, NbChatMessageFileComponent_ng_container_3_Template, 4, 3, "ng-container", 1);
        }
        if (rf & 2) {
          ɵɵproperty("sender", ctx.sender)("date", ctx.date)("dateFormat", ctx.dateFormat)("message", ctx.message);
          ɵɵadvance();
          ɵɵtextInterpolate1(" ", ctx.message, " ");
          ɵɵadvance();
          ɵɵproperty("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) > 1);
          ɵɵadvance();
          ɵɵproperty("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) === 1);
        }
      },
      dependencies: [NgForOf, NgIf, NbIconComponent, NbChatMessageTextComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageFileComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-file",
      template: `
    <nb-chat-message-text [sender]="sender" [date]="date" [dateFormat]="dateFormat" [message]="message">
      {{ message }}
    </nb-chat-message-text>

    <ng-container *ngIf="readyFiles?.length > 1">
      <div class="message-content-group">
        <a *ngFor="let file of readyFiles" [href]="file.url" target="_blank">
          <nb-icon [icon]="file.icon" *ngIf="!file.urlStyle && file.icon"></nb-icon>
          <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle"></div>
        </a>
      </div>
    </ng-container>

    <ng-container *ngIf="readyFiles?.length === 1">
      <a [href]="readyFiles[0].url" target="_blank">
        <nb-icon [icon]="readyFiles[0].icon" *ngIf="!readyFiles[0].urlStyle && readyFiles[0].icon"></nb-icon>
        <div *ngIf="readyFiles[0].urlStyle" [style.background-image]="readyFiles[0].urlStyle"></div>
      </a>
    </ng-container>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: DomSanitizer
  }], {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    files: [{
      type: Input
    }]
  });
})();
var NbChatMessageQuoteComponent = class _NbChatMessageQuoteComponent {
  constructor() {
    this.dateFormat = "shortTime";
  }
  static {
    this.ɵfac = function NbChatMessageQuoteComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatMessageQuoteComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbChatMessageQuoteComponent,
      selectors: [["nb-chat-message-quote"]],
      inputs: {
        message: "message",
        sender: "sender",
        date: "date",
        dateFormat: "dateFormat",
        quote: "quote"
      },
      standalone: false,
      decls: 5,
      vars: 4,
      consts: [["class", "sender", 4, "ngIf"], [1, "quote"], [3, "message"], [1, "sender"]],
      template: function NbChatMessageQuoteComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbChatMessageQuoteComponent_p_0_Template, 5, 5, "p", 0);
          ɵɵelementStart(1, "p", 1);
          ɵɵtext(2);
          ɵɵelementEnd();
          ɵɵelementStart(3, "nb-chat-message-text", 2);
          ɵɵtext(4);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.sender || ctx.date);
          ɵɵadvance(2);
          ɵɵtextInterpolate1(" ", ctx.quote, " ");
          ɵɵadvance();
          ɵɵproperty("message", ctx.message);
          ɵɵadvance();
          ɵɵtextInterpolate1(" ", ctx.message, " ");
        }
      },
      dependencies: [NgIf, NbChatMessageTextComponent, DatePipe],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageQuoteComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-quote",
      template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date | date: dateFormat }}</time></p>
    <p class="quote">
      {{ quote }}
    </p>
    <nb-chat-message-text [message]="message">
      {{ message }}
    </nb-chat-message-text>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    quote: [{
      type: Input
    }]
  });
})();
var NbChatOptions = class {
};
var NbChatMessageMapComponent = class _NbChatMessageMapComponent {
  get file() {
    return {
      // eslint-disable-next-line max-len
      url: `https://maps.googleapis.com/maps/api/staticmap?center=${this.latitude},${this.longitude}&zoom=12&size=400x400&key=${this.mapKey}`,
      type: "image/png",
      icon: "location"
    };
  }
  constructor(options) {
    this.dateFormat = "shortTime";
    this.mapKey = options.messageGoogleMapKey;
  }
  static {
    this.ɵfac = function NbChatMessageMapComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatMessageMapComponent)(ɵɵdirectiveInject(NbChatOptions));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbChatMessageMapComponent,
      selectors: [["nb-chat-message-map"]],
      inputs: {
        message: "message",
        sender: "sender",
        date: "date",
        dateFormat: "dateFormat",
        latitude: "latitude",
        longitude: "longitude"
      },
      standalone: false,
      decls: 1,
      vars: 7,
      consts: [[3, "files", "message", "sender", "date", "dateFormat"]],
      template: function NbChatMessageMapComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelement(0, "nb-chat-message-file", 0);
        }
        if (rf & 2) {
          ɵɵproperty("files", ɵɵpureFunction1(5, _c26, ctx.file))("message", ctx.message)("sender", ctx.sender)("date", ctx.date)("dateFormat", ctx.dateFormat);
        }
      },
      dependencies: [NbChatMessageFileComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageMapComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-map",
      template: `
    <nb-chat-message-file [files]="[file]" [message]="message" [sender]="sender" [date]="date"
     [dateFormat]="dateFormat"></nb-chat-message-file>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbChatOptions
  }], {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    latitude: [{
      type: Input
    }],
    longitude: [{
      type: Input
    }]
  });
})();
var NbChatAvatarComponent = class _NbChatAvatarComponent {
  constructor() {
    this.avatarClass = true;
  }
  static {
    this.ɵfac = function NbChatAvatarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatAvatarComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbChatAvatarComponent,
      selectors: [["nb-chat-avatar"]],
      hostVars: 4,
      hostBindings: function NbChatAvatarComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵstyleProp("background-image", ctx.avatarStyle);
          ɵɵclassProp("avatar", ctx.avatarClass);
        }
      },
      inputs: {
        initials: "initials",
        avatarStyle: "avatarStyle"
      },
      standalone: false,
      decls: 1,
      vars: 1,
      consts: [[4, "ngIf"]],
      template: function NbChatAvatarComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbChatAvatarComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", !ctx.avatarStyle);
        }
      },
      dependencies: [NgIf],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatAvatarComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-avatar",
      template: `
    <ng-container *ngIf="!avatarStyle">
      {{ initials }}
    </ng-container>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    initials: [{
      type: Input
    }],
    avatarStyle: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["style.background-image"]
    }],
    avatarClass: [{
      type: HostBinding,
      args: ["class.avatar"]
    }]
  });
})();
var NbChatMessageComponent = class _NbChatMessageComponent {
  get _addReplyClass() {
    return this._areDefaultStylesEnabled() && this.reply;
  }
  get _addNotReplyClass() {
    return this._areDefaultStylesEnabled() && this.notReply;
  }
  get _addNoSpaceClass() {
    return this._areDefaultStylesEnabled() && !this.message;
  }
  get flyInOut() {
    return true;
  }
  get notReply() {
    return !this.reply;
  }
  /**
   * Determines if a message is a reply
   */
  get reply() {
    return this._reply;
  }
  set reply(value) {
    this._reply = convertToBoolProperty(value);
  }
  /**
   * Message send avatar
   * @type {string}
   */
  set avatar(value) {
    this.avatarStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
  }
  constructor(domSanitizer, customMessageService) {
    this.domSanitizer = domSanitizer;
    this.customMessageService = customMessageService;
    this.builtInMessageTypes = ["text", "file", "map", "quote"];
    this._reply = false;
  }
  getInitials() {
    if (this.sender) {
      const names = this.sender.split(" ");
      return names.map((n) => n.charAt(0)).splice(0, 2).join("").toUpperCase();
    }
    return "";
  }
  _isBuiltInMessageType() {
    return this.type == null || this.builtInMessageTypes.includes(this.type);
  }
  _getTemplate() {
    const customMessage = this.getCustomMessage(this.type);
    return customMessage.templateRef;
  }
  _getTemplateContext() {
    return {
      $implicit: this.customMessageData,
      isReply: this.reply
    };
  }
  _areDefaultStylesEnabled() {
    const customMessageDirective = this.getCustomMessage(this.type);
    return !customMessageDirective.noStyles;
  }
  getCustomMessage(type) {
    const customMessageDirective = this.customMessageService.getInstance(type);
    if (!customMessageDirective) {
      throw new Error(`nb-chat: Can't find template for custom type '${type}'. Make sure you provide it in the chat component with *nbCustomMessage='${type}'.`);
    }
    return customMessageDirective;
  }
  static {
    this.ɵfac = function NbChatMessageComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatMessageComponent)(ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(NbChatCustomMessageService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbChatMessageComponent,
      selectors: [["nb-chat-message"]],
      hostVars: 5,
      hostBindings: function NbChatMessageComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵsyntheticHostProperty("@flyInOut", ctx.flyInOut);
          ɵɵclassProp("not-reply", ctx.notReply)("reply", ctx.reply);
        }
      },
      inputs: {
        reply: "reply",
        message: "message",
        sender: "sender",
        date: "date",
        dateFormat: "dateFormat",
        files: "files",
        quote: "quote",
        latitude: "latitude",
        longitude: "longitude",
        avatar: "avatar",
        type: "type",
        customMessageData: "customMessageData"
      },
      standalone: false,
      decls: 5,
      vars: 3,
      consts: [["customTemplate", ""], [3, "initials", "avatarStyle", 4, "ngIf"], [1, "message"], [3, "ngSwitch", 4, "ngIf", "ngIfElse"], [3, "initials", "avatarStyle"], [3, "ngSwitch"], [3, "sender", "date", "dateFormat", "message", "files", 4, "ngSwitchCase"], [3, "sender", "date", "dateFormat", "message", "quote", 4, "ngSwitchCase"], [3, "sender", "date", "message", "latitude", "longitude", 4, "ngSwitchCase"], [3, "sender", "date", "dateFormat", "message", 4, "ngSwitchDefault"], [3, "sender", "date", "dateFormat", "message", "files"], [3, "sender", "date", "dateFormat", "message", "quote"], [3, "sender", "date", "message", "latitude", "longitude"], [3, "sender", "date", "dateFormat", "message"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
      template: function NbChatMessageComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbChatMessageComponent_nb_chat_avatar_0_Template, 1, 2, "nb-chat-avatar", 1);
          ɵɵelementStart(1, "div", 2);
          ɵɵtemplate(2, NbChatMessageComponent_ng_container_2_Template, 5, 4, "ng-container", 3);
          ɵɵelementEnd();
          ɵɵtemplate(3, NbChatMessageComponent_ng_template_3_Template, 3, 16, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        }
        if (rf & 2) {
          const customTemplate_r2 = ɵɵreference(4);
          ɵɵproperty("ngIf", ctx.notReply);
          ɵɵadvance(2);
          ɵɵproperty("ngIf", ctx._isBuiltInMessageType())("ngIfElse", customTemplate_r2);
        }
      },
      dependencies: [NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgSwitchDefault, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent],
      encapsulation: 2,
      data: {
        animation: [trigger("flyInOut", [state("in", style({
          transform: "translateX(0)"
        })), transition("void => *", [style({
          transform: "translateX(-100%)"
        }), animate(80)]), transition("* => void", [animate(80, style({
          transform: "translateX(100%)"
        }))])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message",
      template: `
    <nb-chat-avatar *ngIf="notReply" [initials]="getInitials()" [avatarStyle]="avatarStyle"> </nb-chat-avatar>

    <div class="message">
      <ng-container [ngSwitch]="type" *ngIf="_isBuiltInMessageType(); else customTemplate">
        <nb-chat-message-file
          *ngSwitchCase="'file'"
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
          [files]="files"
        >
        </nb-chat-message-file>

        <nb-chat-message-quote
          *ngSwitchCase="'quote'"
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
          [quote]="quote"
        >
        </nb-chat-message-quote>

        <nb-chat-message-map
          *ngSwitchCase="'map'"
          [sender]="sender"
          [date]="date"
          [message]="message"
          [latitude]="latitude"
          [longitude]="longitude"
        >
        </nb-chat-message-map>

        <nb-chat-message-text
          *ngSwitchDefault
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
        >
        </nb-chat-message-text>
      </ng-container>
    </div>

    <ng-template #customTemplate>
      <nb-chat-message-text [sender]="sender" [date]="date" [dateFormat]="dateFormat" [message]="message">
      </nb-chat-message-text>
      <div
        [class.nb-custom-message]="_areDefaultStylesEnabled()"
        [class.nb-custom-message-no-space]="_addNoSpaceClass"
        [class.nb-custom-message-reply]="_addReplyClass"
        [class.nb-custom-message-not-reply]="_addNotReplyClass"
        [class.nb-custom-message-full-width]="!_areDefaultStylesEnabled()"
      >
        <ng-container [ngTemplateOutlet]="_getTemplate()" [ngTemplateOutletContext]="_getTemplateContext()">
        </ng-container>
      </div>
    </ng-template>
  `,
      animations: [trigger("flyInOut", [state("in", style({
        transform: "translateX(0)"
      })), transition("void => *", [style({
        transform: "translateX(-100%)"
      }), animate(80)]), transition("* => void", [animate(80, style({
        transform: "translateX(100%)"
      }))])])],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: DomSanitizer
  }, {
    type: NbChatCustomMessageService
  }], {
    flyInOut: [{
      type: HostBinding,
      args: ["@flyInOut"]
    }],
    notReply: [{
      type: HostBinding,
      args: ["class.not-reply"]
    }],
    reply: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.reply"]
    }],
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    files: [{
      type: Input
    }],
    quote: [{
      type: Input
    }],
    latitude: [{
      type: Input
    }],
    longitude: [{
      type: Input
    }],
    avatar: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    customMessageData: [{
      type: Input
    }]
  });
})();
var NbChatTitleDirective = class _NbChatTitleDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
    this.context = {};
  }
  static {
    this.ɵfac = function NbChatTitleDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatTitleDirective)(ɵɵdirectiveInject(TemplateRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbChatTitleDirective,
      selectors: [["", "nbChatTitle", ""]],
      inputs: {
        context: "context"
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatTitleDirective, [{
    type: Directive,
    args: [{
      selector: `[nbChatTitle]`,
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], {
    context: [{
      type: Input
    }]
  });
})();
var NbChatComponent = class _NbChatComponent {
  /**
   * Scroll chat to the bottom of the list when a new message arrives
   */
  get scrollBottom() {
    return this._scrollBottom;
  }
  set scrollBottom(value) {
    this._scrollBottom = convertToBoolProperty(value);
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.status = "basic";
    this.noMessagesPlaceholder = "No messages yet.";
    this._scrollBottom = true;
  }
  ngOnChanges(changes) {
    if ("status" in changes) {
      this.updateFormStatus();
    }
  }
  ngAfterContentInit() {
    this.updateFormStatus();
  }
  ngAfterViewInit() {
    this.messages.changes.subscribe((messages) => {
      this.messages = messages;
      this.updateView();
    });
    this.updateView();
  }
  updateView() {
    if (this.scrollBottom) {
      this.scrollListBottom();
    }
  }
  scrollListBottom() {
    this.scrollable.nativeElement.scrollTop = this.scrollable.nativeElement.scrollHeight;
  }
  updateFormStatus() {
    if (this.chatForm) {
      this.chatForm.setStatus(this.status);
    }
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  static {
    this.ɵfac = function NbChatComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatComponent)(ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbChatComponent,
      selectors: [["nb-chat"]],
      contentQueries: function NbChatComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbChatFormComponent, 5);
          ɵɵcontentQuery(dirIndex, NbChatTitleDirective, 5);
          ɵɵcontentQuery(dirIndex, NbChatMessageComponent, 4);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chatForm = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titleTemplate = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.messages = _t);
        }
      },
      viewQuery: function NbChatComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c27, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.scrollable = _t.first);
        }
      },
      hostVars: 26,
      hostBindings: function NbChatComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
        }
      },
      inputs: {
        title: "title",
        size: "size",
        status: "status",
        noMessagesPlaceholder: "noMessagesPlaceholder",
        scrollBottom: "scrollBottom"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([NbChatCustomMessageService]), ɵɵNgOnChangesFeature],
      ngContentSelectors: _c29,
      decls: 11,
      vars: 3,
      consts: [["textTitleTemplate", ""], ["scrollable", ""], [1, "header"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf", "ngIfElse"], [1, "scrollable"], [1, "messages"], ["class", "no-messages", 4, "ngIf"], [1, "form"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "no-messages"]],
      template: function NbChatComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c28);
          ɵɵelementStart(0, "div", 2);
          ɵɵtemplate(1, NbChatComponent_ng_container_1_Template, 1, 4, "ng-container", 3)(2, NbChatComponent_ng_template_2_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
          ɵɵelementEnd();
          ɵɵelementStart(4, "div", 4, 1)(6, "div", 5);
          ɵɵprojection(7);
          ɵɵtemplate(8, NbChatComponent_p_8_Template, 2, 1, "p", 6);
          ɵɵelementEnd()();
          ɵɵelementStart(9, "div", 7);
          ɵɵprojection(10, 1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          const textTitleTemplate_r2 = ɵɵreference(3);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.titleTemplate)("ngIfElse", textTitleTemplate_r2);
          ɵɵadvance(7);
          ɵɵproperty("ngIf", !(ctx.messages == null ? null : ctx.messages.length));
        }
      },
      dependencies: [NgIf, NgTemplateOutlet],
      styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative;height:100%}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat",
      template: `
    <div class="header">
      <ng-container
        *ngIf="titleTemplate; else textTitleTemplate"
        [ngTemplateOutlet]="titleTemplate.templateRef"
        [ngTemplateOutletContext]="{ $implicit: titleTemplate.context }"
      >
      </ng-container>
      <ng-template #textTitleTemplate>
        {{ title }}
      </ng-template>
    </div>

    <div class="scrollable" #scrollable>
      <div class="messages">
        <ng-content select="nb-chat-message"></ng-content>
        <p class="no-messages" *ngIf="!messages?.length">{{ noMessagesPlaceholder }}</p>
      </div>
    </div>
    <div class="form">
      <ng-content select="nb-chat-form"></ng-content>
    </div>
  `,
      providers: [NbChatCustomMessageService],
      standalone: false,
      styles: [":host{display:flex;flex-direction:column;position:relative;height:100%}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    title: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    noMessagesPlaceholder: [{
      type: Input
    }],
    scrollBottom: [{
      type: Input
    }],
    scrollable: [{
      type: ViewChild,
      args: ["scrollable"]
    }],
    messages: [{
      type: ContentChildren,
      args: [NbChatMessageComponent]
    }],
    chatForm: [{
      type: ContentChild,
      args: [NbChatFormComponent]
    }],
    titleTemplate: [{
      type: ContentChild,
      args: [NbChatTitleDirective]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NB_INPUT_COMPONENTS = [NbInputDirective];
var NbInputModule = class _NbInputModule {
  static {
    this.ɵfac = function NbInputModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbInputModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbInputModule,
      declarations: [NbInputDirective],
      imports: [NbSharedModule],
      exports: [NbInputDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInputModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: NB_INPUT_COMPONENTS,
      exports: NB_INPUT_COMPONENTS
    }]
  }], null, null);
})();
function throwCustomMessageTypeIsRequired() {
  throw new Error("[nbCustomMessage]: custom message type is required.");
}
var NbChatCustomMessageDirective = class _NbChatCustomMessageDirective {
  /**
   * Defines a message type which should rendered with the custom message template.
   * @type {string}
   */
  get nbCustomMessage() {
    return this._type;
  }
  set nbCustomMessage(value) {
    this._type = value;
  }
  get type() {
    return this._type;
  }
  /**
   * Disables generic message styles, such as round corners, text color, background, etc.,
   * so a custom message could be styled from the ground up.
   *
   * @type {boolean}
   */
  set nbCustomMessageNoStyles(value) {
    this._noStyles = convertToBoolProperty(value);
  }
  get nbCustomMessageNoStyles() {
    return this._noStyles;
  }
  get noStyles() {
    return this.nbCustomMessageNoStyles;
  }
  constructor(templateRef, customMessageService) {
    this.templateRef = templateRef;
    this.customMessageService = customMessageService;
    this._noStyles = false;
  }
  ngOnInit() {
    if (!this._type) {
      throwCustomMessageTypeIsRequired();
    }
    this.customMessageService.register(this.type, this);
  }
  ngOnDestroy() {
    this.customMessageService.unregister(this.type);
  }
  static {
    this.ɵfac = function NbChatCustomMessageDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatCustomMessageDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(NbChatCustomMessageService));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbChatCustomMessageDirective,
      selectors: [["", "nbCustomMessage", ""]],
      inputs: {
        nbCustomMessage: "nbCustomMessage",
        nbCustomMessageNoStyles: "nbCustomMessageNoStyles"
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatCustomMessageDirective, [{
    type: Directive,
    args: [{
      selector: `[nbCustomMessage]`,
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: NbChatCustomMessageService
  }], {
    nbCustomMessage: [{
      type: Input
    }],
    nbCustomMessageNoStyles: [{
      type: Input
    }]
  });
})();
var NB_CHAT_COMPONENTS = [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent];
var NB_CHAT_DIRECTIVES = [NbChatCustomMessageDirective, NbChatTitleDirective];
var NbChatModule = class _NbChatModule {
  static forRoot(options) {
    return {
      ngModule: _NbChatModule,
      providers: [{
        provide: NbChatOptions,
        useValue: options || {}
      }]
    };
  }
  static forChild(options) {
    return {
      ngModule: _NbChatModule,
      providers: [{
        provide: NbChatOptions,
        useValue: options || {}
      }]
    };
  }
  static {
    this.ɵfac = function NbChatModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbChatModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbChatModule,
      declarations: [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent, NbChatCustomMessageDirective, NbChatTitleDirective],
      imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule],
      exports: [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent, NbChatCustomMessageDirective, NbChatTitleDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule],
      declarations: [...NB_CHAT_COMPONENTS, ...NB_CHAT_DIRECTIVES],
      exports: [...NB_CHAT_COMPONENTS, ...NB_CHAT_DIRECTIVES]
    }]
  }], null, null);
})();
var NbSpinnerComponent = class _NbSpinnerComponent {
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.message = "Loading...";
    this.size = "medium";
    this.status = "basic";
  }
  static {
    this.ɵfac = function NbSpinnerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSpinnerComponent)(ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbSpinnerComponent,
      selectors: [["nb-spinner"]],
      hostVars: 26,
      hostBindings: function NbSpinnerComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
        }
      },
      inputs: {
        message: "message",
        size: "size",
        status: "status"
      },
      standalone: false,
      decls: 2,
      vars: 1,
      consts: [[1, "spin-circle"], ["class", "message", 4, "ngIf"], [1, "message"]],
      template: function NbSpinnerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelement(0, "span", 0);
          ɵɵtemplate(1, NbSpinnerComponent_span_1_Template, 2, 1, "span", 1);
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.message);
        }
      },
      dependencies: [NgIf],
      styles: ["[_nghost-%COMP%]{opacity:1;position:absolute;border-radius:inherit;inset:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}[_nghost-%COMP%]   .spin-circle[_ngcontent-%COMP%]{animation:spin .8s infinite linear;border-radius:50%;border-style:solid;border-width:.125em;width:1em;height:1em}[_nghost-%COMP%]   .message[_ngcontent-%COMP%]{margin-left:.5rem}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerComponent, [{
    type: Component,
    args: [{
      selector: "nb-spinner",
      template: `
    <span class="spin-circle"></span>
    <span class="message" *ngIf="message">{{ message }}</span>
  `,
      standalone: false,
      styles: [":host{opacity:1;position:absolute;border-radius:inherit;inset:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}:host .spin-circle{animation:spin .8s infinite linear;border-radius:50%;border-style:solid;border-width:.125em;width:1em;height:1em}:host .message{margin-left:.5rem}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    message: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NbSpinnerDirective = class _NbSpinnerDirective {
  /**
   * Directive value - show or hide spinner
   * @param {boolean} val
   */
  set nbSpinner(val) {
    if (this.componentFactory) {
      if (val) {
        this.show();
      } else {
        this.hide();
      }
    } else {
      this.shouldShow = val;
    }
  }
  constructor(directiveView, componentFactoryResolver, renderer, directiveElement) {
    this.directiveView = directiveView;
    this.componentFactoryResolver = componentFactoryResolver;
    this.renderer = renderer;
    this.directiveElement = directiveElement;
    this.shouldShow = false;
    this.spinnerStatus = "basic";
    this.spinnerSize = "medium";
    this.isSpinnerExist = false;
  }
  ngOnInit() {
    this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(NbSpinnerComponent);
    if (this.shouldShow) {
      this.show();
    }
  }
  hide() {
    if (this.isSpinnerExist) {
      this.directiveView.remove();
      this.isSpinnerExist = false;
    }
  }
  show() {
    if (!this.isSpinnerExist) {
      this.spinner = this.directiveView.createComponent(this.componentFactory);
      this.setInstanceInputs(this.spinner.instance);
      this.spinner.changeDetectorRef.detectChanges();
      this.renderer.appendChild(this.directiveElement.nativeElement, this.spinner.location.nativeElement);
      this.isSpinnerExist = true;
    }
  }
  setInstanceInputs(instance) {
    instance.message = this.spinnerMessage;
    typeof this.spinnerStatus !== "undefined" && (instance.status = this.spinnerStatus);
    typeof this.spinnerSize !== "undefined" && (instance.size = this.spinnerSize);
  }
  static {
    this.ɵfac = function NbSpinnerDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSpinnerDirective)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbSpinnerDirective,
      selectors: [["", "nbSpinner", ""]],
      hostVars: 2,
      hostBindings: function NbSpinnerDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("nb-spinner-container", ctx.isSpinnerExist);
        }
      },
      inputs: {
        spinnerMessage: [0, "nbSpinnerMessage", "spinnerMessage"],
        spinnerStatus: [0, "nbSpinnerStatus", "spinnerStatus"],
        spinnerSize: [0, "nbSpinnerSize", "spinnerSize"],
        nbSpinner: "nbSpinner"
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSpinner]",
      standalone: false
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    spinnerMessage: [{
      type: Input,
      args: ["nbSpinnerMessage"]
    }],
    spinnerStatus: [{
      type: Input,
      args: ["nbSpinnerStatus"]
    }],
    spinnerSize: [{
      type: Input,
      args: ["nbSpinnerSize"]
    }],
    nbSpinner: [{
      type: Input,
      args: ["nbSpinner"]
    }],
    isSpinnerExist: [{
      type: HostBinding,
      args: ["class.nb-spinner-container"]
    }]
  });
})();
var NbSpinnerModule = class _NbSpinnerModule {
  static {
    this.ɵfac = function NbSpinnerModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSpinnerModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbSpinnerModule,
      declarations: [NbSpinnerComponent, NbSpinnerDirective],
      imports: [NbSharedModule],
      exports: [NbSpinnerComponent, NbSpinnerDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      exports: [NbSpinnerComponent, NbSpinnerDirective],
      declarations: [NbSpinnerComponent, NbSpinnerDirective]
    }]
  }], null, null);
})();
var NB_STEPPER = new InjectionToken("Nebular Stepper Component");
var NbStepComponent = class _NbStepComponent {
  /**
   * Whether step will be displayed in wizard
   *
   * @type {boolean}
   */
  get hidden() {
    return this._hidden;
  }
  set hidden(value) {
    this._hidden = convertToBoolProperty(value);
  }
  /**
   * Check that label is a TemplateRef.
   *
   * @return boolean
   * */
  get isLabelTemplate() {
    return this.label instanceof TemplateRef;
  }
  /**
   * Whether step is marked as completed.
   *
   * @type {boolean}
   */
  get completed() {
    return this._completed || this.isCompleted;
  }
  set completed(value) {
    this._completed = convertToBoolProperty(value);
  }
  get isCompleted() {
    return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
  }
  constructor(stepper) {
    this._hidden = false;
    this._completed = false;
    this.interacted = false;
    this.stepper = stepper;
  }
  /**
   * Mark step as selected
   * */
  select() {
    this.stepper.selected = this;
  }
  /**
   * Reset step and stepControl state
   * */
  reset() {
    this.interacted = false;
    if (this.stepControl) {
      this.stepControl.reset();
    }
  }
  static {
    this.ɵfac = function NbStepComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbStepComponent)(ɵɵdirectiveInject(NB_STEPPER));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbStepComponent,
      selectors: [["nb-step"]],
      viewQuery: function NbStepComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(TemplateRef, 7);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
        }
      },
      inputs: {
        stepControl: "stepControl",
        label: "label",
        hidden: "hidden",
        completed: "completed"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 1,
      vars: 0,
      template: function NbStepComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, NbStepComponent_ng_template_0_Template, 1, 0, "ng-template");
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepComponent, [{
    type: Component,
    args: [{
      selector: "nb-step",
      template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `,
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_STEPPER]
    }]
  }], {
    content: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }],
    stepControl: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    completed: [{
      type: Input
    }]
  });
})();
var NbStepperComponent = class _NbStepperComponent {
  constructor() {
    this._selectedIndex = 0;
    this._disableStepNavigation = false;
    this.orientation = "horizontal";
    this._linear = true;
    this.stepChange = new EventEmitter();
  }
  /**
   * Selected step index
   */
  get selectedIndex() {
    return this._selectedIndex;
  }
  set selectedIndex(index) {
    if (!this.steps) {
      this._selectedIndex = index;
      return;
    }
    this.markCurrentStepInteracted();
    if (this.canBeSelected(index)) {
      const previouslySelectedIndex = this._selectedIndex;
      const previouslySelectedStep = this.selected;
      this._selectedIndex = index;
      this.stepChange.emit({
        index: this.selectedIndex,
        step: this.selected,
        previouslySelectedIndex,
        previouslySelectedStep
      });
    }
  }
  /**
   * Disables navigation by clicking on steps. False by default
   * @param {boolean} value
   */
  set disableStepNavigation(value) {
    this._disableStepNavigation = convertToBoolProperty(value);
  }
  get disableStepNavigation() {
    return this._disableStepNavigation;
  }
  /**
   * Selected step component
   */
  get selected() {
    return this.steps ? this.steps.toArray()[this.selectedIndex] : void 0;
  }
  set selected(step) {
    if (!this.steps) {
      return;
    }
    this.selectedIndex = this.steps.toArray().indexOf(step);
  }
  /**
   * Allow moving forward only if the current step is complete
   * @default true
   */
  set linear(value) {
    this._linear = convertToBoolProperty(value);
  }
  get linear() {
    return this._linear;
  }
  get vertical() {
    return this.orientation === "vertical";
  }
  get horizontal() {
    return this.orientation === "horizontal";
  }
  /**
   * Navigate to next step
   * */
  next() {
    this.selectedIndex = Math.min(this.selectedIndex + 1, this.steps.length - 1);
  }
  /**
   * Navigate to previous step
   * */
  previous() {
    this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
  }
  /**
   * Select step if navigation is not disabled
   * @param { NbStepComponent } step
   */
  changeStep(step) {
    if (!this.disableStepNavigation) {
      step.select();
    }
  }
  /**
   * Reset stepper and stepControls to initial state
   * */
  reset() {
    const previouslySelectedIndex = this.selectedIndex;
    const previouslySelectedStep = this.selected;
    this._selectedIndex = 0;
    this.steps.forEach((step) => step.reset());
    this.stepChange.emit({
      index: this.selectedIndex,
      step: this.selected,
      previouslySelectedIndex,
      previouslySelectedStep
    });
  }
  isStepSelected(step) {
    return this.selected === step;
  }
  /*
   * @docs-private
   **/
  getStepTemplate(step) {
    if (step.isLabelTemplate) {
      return step.label;
    }
    return null;
  }
  isStepValid(index) {
    return this.steps.toArray()[index].completed;
  }
  canBeSelected(indexToCheck) {
    const noSteps = !this.steps || this.steps.length === 0;
    if (noSteps || indexToCheck < 0 || indexToCheck >= this.steps.length || indexToCheck === this.selectedIndex) {
      return false;
    }
    if (indexToCheck <= this.selectedIndex || !this.linear) {
      return true;
    }
    let isAllStepsValid = true;
    for (let i = this.selectedIndex; i < indexToCheck; i++) {
      if (!this.isStepValid(i)) {
        isAllStepsValid = false;
        break;
      }
    }
    return isAllStepsValid;
  }
  markCurrentStepInteracted() {
    if (this.selected) {
      this.selected.interacted = true;
    }
  }
  static {
    this.ɵfac = function NbStepperComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbStepperComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbStepperComponent,
      selectors: [["nb-stepper"]],
      contentQueries: function NbStepperComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbStepComponent, 4);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.steps = _t);
        }
      },
      hostVars: 4,
      hostBindings: function NbStepperComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("vertical", ctx.vertical)("horizontal", ctx.horizontal);
        }
      },
      inputs: {
        selectedIndex: "selectedIndex",
        disableStepNavigation: "disableStepNavigation",
        selected: "selected",
        orientation: "orientation",
        linear: "linear"
      },
      outputs: {
        stepChange: "stepChange"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NB_STEPPER,
        useExisting: _NbStepperComponent
      }])],
      ngContentSelectors: _c32,
      decls: 5,
      vars: 2,
      consts: [[1, "header"], [4, "ngFor", "ngForOf"], [1, "step-content"], [3, "ngTemplateOutlet"], ["class", "connector", 3, "connector-past", 4, "ngIf"], ["class", "step", 3, "selected", "completed", "noninteractive", "click", 4, "ngIf"], [1, "connector"], [1, "step", 3, "click"], [1, "label-index"], [4, "ngIf"], ["icon", "checkmark-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "label"], ["icon", "checkmark-outline", "pack", "nebular-essentials"], [4, "ngTemplateOutlet"]],
      template: function NbStepperComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c31);
          ɵɵtemplate(0, NbStepperComponent_ng_template_0_Template, 1, 0, "ng-template");
          ɵɵelementStart(1, "div", 0);
          ɵɵtemplate(2, NbStepperComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
          ɵɵelementEnd();
          ɵɵelementStart(3, "div", 2);
          ɵɵelementContainer(4, 3);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance(2);
          ɵɵproperty("ngForOf", ctx.steps);
          ɵɵadvance(2);
          ɵɵproperty("ngTemplateOutlet", ctx.selected == null ? null : ctx.selected.content);
        }
      },
      dependencies: [NgForOf, NgIf, NgTemplateOutlet, NbIconComponent],
      styles: [".horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{flex-direction:column}.horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{height:2px}.horizontal[_nghost-%COMP%]   .label-index[_ngcontent-%COMP%]{margin-bottom:10px}.vertical[_nghost-%COMP%]{display:flex;height:100%}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]{flex-direction:column}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{margin:0 10px}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{width:2px}.header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{flex:auto}.header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{display:flex;align-items:center;cursor:pointer}.header[_ngcontent-%COMP%]   .step.noninteractive[_ngcontent-%COMP%]{cursor:default}.header[_ngcontent-%COMP%]   .label-index[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center}.header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{width:max-content}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperComponent, [{
    type: Component,
    args: [{
      selector: "nb-stepper",
      providers: [{
        provide: NB_STEPPER,
        useExisting: NbStepperComponent
      }],
      standalone: false,
      template: '<ng-template><ng-content select="nb-step"></ng-content></ng-template>\n<div class="header">\n  <ng-container *ngFor="let step of steps; let index = index; let first = first">\n\n    <div *ngIf="!first && !step.hidden"\n         [class.connector-past]="index <= selectedIndex"\n         class="connector"></div>\n\n    <div *ngIf="!step.hidden" class="step"\n         [class.selected]="isStepSelected(step)"\n         [class.completed]="!isStepSelected(step) && step.completed"\n         [class.noninteractive]="disableStepNavigation"\n         (click)="changeStep(step)">\n      <div class="label-index">\n        <span *ngIf="!step.completed || isStepSelected(step)">{{ index + 1 }}</span>\n        <nb-icon *ngIf="!isStepSelected(step) && step.completed" icon="checkmark-outline" pack="nebular-essentials">\n        </nb-icon>\n      </div>\n      <div class="label">\n        <ng-container *ngIf="step.isLabelTemplate">\n          <ng-container *ngTemplateOutlet="getStepTemplate(step)"></ng-container>\n        </ng-container>\n        <span *ngIf="!step.isLabelTemplate">{{ step.label }}</span>\n      </div>\n    </div>\n  </ng-container>\n</div>\n<div class="step-content">\n  <ng-container [ngTemplateOutlet]="selected?.content"></ng-container>\n</div>\n',
      styles: [":host(.horizontal) .header .step{flex-direction:column}:host(.horizontal) .header .connector{height:2px}:host(.horizontal) .label-index{margin-bottom:10px}:host(.vertical){display:flex;height:100%}:host(.vertical) .header{flex-direction:column}:host(.vertical) .header .label{margin:0 10px}:host(.vertical) .header .connector{width:2px}.header{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header .connector{flex:auto}.header .step{display:flex;align-items:center;cursor:pointer}.header .step.noninteractive{cursor:default}.header .label-index{display:flex;justify-content:center;align-items:center}.header .label{width:max-content}\n"]
    }]
  }], null, {
    selectedIndex: [{
      type: Input
    }],
    disableStepNavigation: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    linear: [{
      type: Input
    }],
    stepChange: [{
      type: Output
    }],
    vertical: [{
      type: HostBinding,
      args: ["class.vertical"]
    }],
    horizontal: [{
      type: HostBinding,
      args: ["class.horizontal"]
    }],
    steps: [{
      type: ContentChildren,
      args: [NbStepComponent]
    }]
  });
})();
var NbStepperNextDirective = class _NbStepperNextDirective {
  constructor(stepper) {
    this.stepper = stepper;
    this.type = "submit";
  }
  onClick() {
    this.stepper.next();
  }
  static {
    this.ɵfac = function NbStepperNextDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbStepperNextDirective)(ɵɵdirectiveInject(NbStepperComponent));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbStepperNextDirective,
      selectors: [["button", "nbStepperNext", ""]],
      hostVars: 1,
      hostBindings: function NbStepperNextDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbStepperNextDirective_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
        if (rf & 2) {
          ɵɵattribute("type", ctx.type);
        }
      },
      inputs: {
        type: "type"
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperNextDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbStepperNext]",
      standalone: false
    }]
  }], () => [{
    type: NbStepperComponent
  }], {
    type: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.type"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var NbStepperPreviousDirective = class _NbStepperPreviousDirective {
  constructor(stepper) {
    this.stepper = stepper;
    this.type = "button";
  }
  onClick() {
    this.stepper.previous();
  }
  static {
    this.ɵfac = function NbStepperPreviousDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbStepperPreviousDirective)(ɵɵdirectiveInject(NbStepperComponent));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbStepperPreviousDirective,
      selectors: [["button", "nbStepperPrevious", ""]],
      hostVars: 1,
      hostBindings: function NbStepperPreviousDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbStepperPreviousDirective_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
        if (rf & 2) {
          ɵɵattribute("type", ctx.type);
        }
      },
      inputs: {
        type: "type"
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperPreviousDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbStepperPrevious]",
      standalone: false
    }]
  }], () => [{
    type: NbStepperComponent
  }], {
    type: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.type"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var NbStepperModule = class _NbStepperModule {
  static {
    this.ɵfac = function NbStepperModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbStepperModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbStepperModule,
      declarations: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective],
      imports: [NbSharedModule, NbIconModule],
      exports: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective],
      exports: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective]
    }]
  }], null, null);
})();
var NbAccordionComponent = class _NbAccordionComponent {
  constructor() {
    this.openCloseItems = new Subject();
    this.multiValue = false;
  }
  /**
   *  Allow multiple items to be expanded at the same time.
   * @type {boolean}
   */
  get multi() {
    return this.multiValue;
  }
  set multi(val) {
    this.multiValue = convertToBoolProperty(val);
  }
  /**
   * Opens all enabled accordion items.
   */
  openAll() {
    if (this.multi) {
      this.openCloseItems.next(false);
    }
  }
  /**
   * Closes all enabled accordion items.
   */
  closeAll() {
    this.openCloseItems.next(true);
  }
  static {
    this.ɵfac = function NbAccordionComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbAccordionComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbAccordionComponent,
      selectors: [["nb-accordion"]],
      inputs: {
        multi: "multi"
      },
      standalone: false,
      ngContentSelectors: _c34,
      decls: 1,
      vars: 0,
      template: function NbAccordionComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c33);
          ɵɵprojection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion",
      template: `
    <ng-content select="nb-accordion-item"></ng-content>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    multi: [{
      type: Input,
      args: ["multi"]
    }]
  });
})();
var NbAccordionItemComponent = class _NbAccordionItemComponent {
  /**
   * Item is collapse (`true` by default)
   * @type {boolean}
   */
  get collapsed() {
    return this.collapsedValue;
  }
  set collapsed(val) {
    this.collapsedValue = convertToBoolProperty(val);
    this.collapsedChange.emit(this.collapsedValue);
    this.invalidate();
  }
  /**
   * Item is expanded (`false` by default)
   * @type {boolean}
   */
  get expanded() {
    return !this.collapsed;
  }
  set expanded(val) {
    this.collapsedValue = !convertToBoolProperty(val);
  }
  /**
   * Item is disabled and cannot be opened.
   * @type {boolean}
   */
  get disabled() {
    return this.disabledValue;
  }
  set disabled(val) {
    this.disabledValue = convertToBoolProperty(val);
    this.invalidate();
  }
  constructor(accordion, cd) {
    this.accordion = accordion;
    this.cd = cd;
    this.collapsedChange = new EventEmitter();
    this.accordionItemInvalidate = new Subject();
    this.collapsedValue = true;
    this.disabledValue = false;
    this.destroy$ = new Subject();
  }
  /**
   * Open/close the item
   */
  toggle() {
    if (!this.disabled) {
      const willSet = !this.collapsed;
      if (!this.accordion.multi) {
        this.accordion.openCloseItems.next(true);
      }
      this.collapsed = willSet;
    }
  }
  /**
   * Open the item.
   */
  open() {
    !this.disabled && (this.collapsed = false);
  }
  /**
   * Collapse the item.
   */
  close() {
    !this.disabled && (this.collapsed = true);
  }
  ngOnInit() {
    this.accordion.openCloseItems.pipe(takeUntil(this.destroy$)).subscribe((collapsed) => {
      !this.disabled && (this.collapsed = collapsed);
    });
  }
  ngOnChanges(changes) {
    this.accordionItemInvalidate.next(true);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.accordionItemInvalidate.complete();
  }
  invalidate() {
    this.accordionItemInvalidate.next(true);
    this.cd.markForCheck();
  }
  static {
    this.ɵfac = function NbAccordionItemComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbAccordionItemComponent)(ɵɵdirectiveInject(NbAccordionComponent, 1), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbAccordionItemComponent,
      selectors: [["nb-accordion-item"]],
      hostVars: 6,
      hostBindings: function NbAccordionItemComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("collapsed", ctx.collapsed)("expanded", ctx.expanded)("disabled", ctx.disabled);
        }
      },
      inputs: {
        collapsed: "collapsed",
        expanded: "expanded",
        disabled: "disabled"
      },
      outputs: {
        collapsedChange: "collapsedChange"
      },
      standalone: false,
      features: [ɵɵNgOnChangesFeature],
      ngContentSelectors: _c36,
      decls: 2,
      vars: 0,
      template: function NbAccordionItemComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c35);
          ɵɵprojection(0);
          ɵɵprojection(1, 1);
        }
      },
      styles: [_c8],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item",
      template: `
    <ng-content select="nb-accordion-item-header"></ng-content>
    <ng-content select="nb-accordion-item-body"></ng-content>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;flex-direction:column}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbAccordionComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    collapsed: [{
      type: Input,
      args: ["collapsed"]
    }, {
      type: HostBinding,
      args: ["class.collapsed"]
    }],
    expanded: [{
      type: Input,
      args: ["expanded"]
    }, {
      type: HostBinding,
      args: ["class.expanded"]
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    collapsedChange: [{
      type: Output
    }]
  });
})();
var accordionItemBodyTrigger = trigger("accordionItemBody", [state("collapsed", style({
  overflow: "hidden",
  visibility: "hidden",
  height: 0
})), state("expanded", style({
  overflow: "hidden",
  visibility: "visible"
})), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))]);
var NbAccordionItemBodyComponent = class _NbAccordionItemBodyComponent {
  constructor(accordionItem, cd) {
    this.accordionItem = accordionItem;
    this.cd = cd;
    this.destroy$ = new Subject();
  }
  get state() {
    return this.accordionItem.collapsed ? "collapsed" : "expanded";
  }
  ngOnInit() {
    this.accordionItem.accordionItemInvalidate.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  static {
    this.ɵfac = function NbAccordionItemBodyComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbAccordionItemBodyComponent)(ɵɵdirectiveInject(NbAccordionItemComponent, 1), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbAccordionItemBodyComponent,
      selectors: [["nb-accordion-item-body"]],
      standalone: false,
      ngContentSelectors: _c03,
      decls: 3,
      vars: 3,
      consts: [[1, "item-body"]],
      template: function NbAccordionItemBodyComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵelementStart(0, "div")(1, "div", 0);
          ɵɵprojection(2);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵproperty("@accordionItemBody", ɵɵpureFunction1(1, _c37, ctx.state));
        }
      },
      encapsulation: 2,
      data: {
        animation: [accordionItemBodyTrigger]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemBodyComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item-body",
      template: `
    <div [@accordionItemBody]="{ value: state }">
      <div class="item-body">
        <ng-content></ng-content>
      </div>
    </div>
  `,
      animations: [accordionItemBodyTrigger],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: NbAccordionItemComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var NbAccordionItemHeaderComponent = class _NbAccordionItemHeaderComponent {
  get isCollapsed() {
    return this.accordionItem.collapsed;
  }
  get expanded() {
    return !this.accordionItem.collapsed;
  }
  // issue #794
  get tabbable() {
    return this.accordionItem.disabled ? "-1" : "0";
  }
  get disabled() {
    return this.accordionItem.disabled;
  }
  toggle() {
    this.accordionItem.toggle();
  }
  get state() {
    if (this.isCollapsed) {
      return "collapsed";
    }
    return "expanded";
  }
  constructor(accordionItem, cd) {
    this.accordionItem = accordionItem;
    this.cd = cd;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.accordionItem.accordionItemInvalidate.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  static {
    this.ɵfac = function NbAccordionItemHeaderComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbAccordionItemHeaderComponent)(ɵɵdirectiveInject(NbAccordionItemComponent, 1), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbAccordionItemHeaderComponent,
      selectors: [["nb-accordion-item-header"]],
      hostVars: 7,
      hostBindings: function NbAccordionItemHeaderComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbAccordionItemHeaderComponent_click_HostBindingHandler() {
            return ctx.toggle();
          })("keydown.space", function NbAccordionItemHeaderComponent_keydown_space_HostBindingHandler() {
            return ctx.toggle();
          })("keydown.enter", function NbAccordionItemHeaderComponent_keydown_enter_HostBindingHandler() {
            return ctx.toggle();
          });
        }
        if (rf & 2) {
          ɵɵattribute("aria-expanded", ctx.expanded)("tabindex", ctx.tabbable)("aria-disabled", ctx.disabled);
          ɵɵclassProp("accordion-item-header-collapsed", ctx.isCollapsed)("accordion-item-header-expanded", ctx.expanded);
        }
      },
      standalone: false,
      ngContentSelectors: _c39,
      decls: 4,
      vars: 1,
      consts: [["icon", "chevron-down-outline", "pack", "nebular-essentials", "class", "expansion-indicator", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", 1, "expansion-indicator"]],
      template: function NbAccordionItemHeaderComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c38);
          ɵɵprojection(0);
          ɵɵprojection(1, 1);
          ɵɵprojection(2, 2);
          ɵɵtemplate(3, NbAccordionItemHeaderComponent_nb_icon_3_Template, 1, 1, "nb-icon", 0);
        }
        if (rf & 2) {
          ɵɵadvance(3);
          ɵɵproperty("ngIf", !ctx.disabled);
        }
      },
      dependencies: [NgIf, NbIconComponent],
      styles: ["[_nghost-%COMP%]{display:flex;align-items:center;cursor:pointer}[_nghost-%COMP%]:focus{outline:0}\n\n\n\n\n\n"],
      data: {
        animation: [trigger("expansionIndicator", [state("expanded", style({
          transform: "rotate(180deg)"
        })), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item-header",
      template: `
    <ng-content select="nb-accordion-item-title"></ng-content>
    <ng-content select="nb-accordion-item-description"></ng-content>
    <ng-content></ng-content>
    <nb-icon icon="chevron-down-outline"
             pack="nebular-essentials"
             [@expansionIndicator]="state"
             *ngIf="!disabled"
             class="expansion-indicator">
    </nb-icon>
  `,
      animations: [trigger("expansionIndicator", [state("expanded", style({
        transform: "rotate(180deg)"
      })), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))])],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:flex;align-items:center;cursor:pointer}:host:focus{outline:0}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbAccordionItemComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    isCollapsed: [{
      type: HostBinding,
      args: ["class.accordion-item-header-collapsed"]
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.accordion-item-header-expanded"]
    }, {
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    tabbable: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    toggle: [{
      type: HostListener,
      args: ["click"]
    }, {
      type: HostListener,
      args: ["keydown.space"]
    }, {
      type: HostListener,
      args: ["keydown.enter"]
    }]
  });
})();
var NB_ACCORDION_COMPONENTS = [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent];
var NbAccordionModule = class _NbAccordionModule {
  static {
    this.ɵfac = function NbAccordionModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbAccordionModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbAccordionModule,
      declarations: [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent],
      imports: [CommonModule, NbIconModule],
      exports: [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CommonModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      exports: [...NB_ACCORDION_COMPONENTS],
      declarations: [...NB_ACCORDION_COMPONENTS],
      providers: []
    }]
  }], null, null);
})();
var NB_BUTTON_GROUP = new InjectionToken("NB_BUTTON_GROUP");
var NbButtonToggleDirective = class _NbButtonToggleDirective extends NbButton {
  get pressedChange$() {
    return this._pressedChange$.asObservable();
  }
  /**
   * Controls button pressed state
   **/
  get pressed() {
    return this._pressed;
  }
  set pressed(value) {
    if (this.pressed !== convertToBoolProperty(value)) {
      this._pressed = !this.pressed;
      this.pressedChange.emit(this.pressed);
      this._pressedChange$.next({
        source: this,
        pressed: this.pressed
      });
    }
  }
  get basic() {
    return !this.pressed;
  }
  get primary() {
    return this.pressed && (this.status === "basic" || this.status === "primary");
  }
  get success() {
    return this.pressed && this.status === "success";
  }
  get info() {
    return this.pressed && this.status === "info";
  }
  get warning() {
    return this.pressed && this.status === "warning";
  }
  get danger() {
    return this.pressed && this.status === "danger";
  }
  get control() {
    return this.pressed && this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  onClick() {
    if (this.buttonGroup?.multiple || !this.pressed) {
      this.pressed = !this.pressed;
    }
  }
  constructor(renderer, hostElement, cd, zone, statusService, buttonGroup) {
    super(renderer, hostElement, cd, zone, statusService);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
    this.buttonGroup = buttonGroup;
    this._pressedChange$ = new Subject();
    this.appearance = "filled";
    this._pressed = false;
    this.pressedChange = new EventEmitter();
  }
  /**
   * @docs-private
   */
  _updatePressed(value) {
    this.pressed = value;
    this.cd.markForCheck();
  }
  static {
    this.ɵfac = function NbButtonToggleDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbButtonToggleDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService), ɵɵdirectiveInject(NB_BUTTON_GROUP, 8));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbButtonToggleDirective,
      selectors: [["button", "nbButtonToggle", ""]],
      hostVars: 17,
      hostBindings: function NbButtonToggleDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbButtonToggleDirective_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
        if (rf & 2) {
          ɵɵattribute("aria-pressed", ctx.pressed);
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("status-basic", ctx.basic)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-control", ctx.control);
        }
      },
      inputs: {
        appearance: "appearance",
        value: "value",
        pressed: "pressed"
      },
      outputs: {
        pressedChange: "pressedChange"
      },
      exportAs: ["nbButtonToggle"],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbButton,
        useExisting: _NbButtonToggleDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonToggleDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbButtonToggle]",
      providers: [{
        provide: NbButton,
        useExisting: NbButtonToggleDirective
      }],
      exportAs: "nbButtonToggle",
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_BUTTON_GROUP]
    }]
  }], {
    appearance: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    pressed: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-pressed"]
    }],
    pressedChange: [{
      type: Output
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var NbButtonGroupComponent = class _NbButtonGroupComponent {
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (this.disabled !== convertToBoolProperty(value)) {
      this._disabled = !this.disabled;
    }
  }
  /**
   * Allows to keep multiple button toggles pressed. Off by default.
   */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  /**
   * Sets `filled` appearance
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Sets `outline` appearance
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Sets `ghost` appearance
   */
  get ghost() {
    return this.appearance === "ghost";
  }
  set ghost(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "ghost";
    }
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(cd, statusService) {
    this.cd = cd;
    this.statusService = statusService;
    this.lastEmittedValue = [];
    this.destroy$ = new Subject();
    this.buttonsChange$ = new Subject();
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "filled";
    this._disabled = false;
    this._multiple = false;
    this.valueChange = new EventEmitter();
    this.role = "group";
  }
  ngOnChanges({
    size,
    status,
    shape,
    multiple,
    filled,
    outline,
    ghost,
    disabled
  }) {
    if (size || status || shape || multiple || filled || outline || ghost || disabled) {
      this.syncButtonsProperties(this.buttons?.toArray() || []);
    }
  }
  ngAfterContentInit() {
    this.buttonsChange$.pipe(takeUntil(this.destroy$)).subscribe((buttons) => {
      this.listenButtonPressedState(buttons);
      this.syncButtonsProperties(buttons);
    });
    this.buttons.changes.pipe(
      // `buttons.changes` emit during change detection run after projected content already was initialized.
      // So at this time, it's too late to update projected buttons properties as updating bindings after
      // initialization doesn't make sense. Changes won't be picked up and should cause an "expression changed" error.
      // Instead, we wrap the new buttons list into a promise to defer update to the following microtask and also to
      // trigger change detection one more time.
      switchMap((buttons) => from(Promise.resolve(buttons.toArray()))),
      takeUntil(this.destroy$)
    ).subscribe(this.buttonsChange$);
    this.buttonsChange$.next(this.buttons.toArray());
  }
  listenButtonPressedState(buttons) {
    const toggleButtons = buttons.filter((button) => {
      return button instanceof NbButtonToggleDirective;
    });
    if (!toggleButtons.length) {
      return;
    }
    const buttonsPressedChange$ = toggleButtons.map((button) => button.pressedChange$);
    merge(...buttonsPressedChange$).pipe(filter(({
      pressed
    }) => !this.multiple && pressed), takeUntil(merge(this.buttonsChange$, this.destroy$))).subscribe(({
      source
    }) => {
      toggleButtons.filter((button) => button !== source).forEach((button) => button._updatePressed(false));
    });
    merge(...buttonsPressedChange$).pipe(
      // Use startWith to emit if some buttons are initially pressed.
      startWith(""),
      // Use debounce to emit change once when pressed state change in multiple button toggles.
      debounceTime(0),
      takeUntil(merge(this.buttonsChange$, this.destroy$))
    ).subscribe(() => this.emitCurrentValue(toggleButtons));
  }
  syncButtonsProperties(buttons) {
    buttons.forEach((button) => {
      button.updateProperties({
        appearance: this.appearance,
        size: this.size,
        status: this.status,
        shape: this.shape,
        disabled: this.disabled
      });
    });
  }
  emitCurrentValue(toggleButtons) {
    const pressedToggleValues = toggleButtons.filter((b) => b.pressed && typeof b.value !== "undefined").map((b) => b.value);
    if (pressedToggleValues.length === 0 && this.lastEmittedValue.length === 0) {
      return;
    }
    this.valueChange.emit(pressedToggleValues);
    this.lastEmittedValue = pressedToggleValues;
  }
  static {
    this.ɵfac = function NbButtonGroupComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbButtonGroupComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbButtonGroupComponent,
      selectors: [["nb-button-group"]],
      contentQueries: function NbButtonGroupComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbButton, 4);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.buttons = _t);
        }
      },
      hostVars: 3,
      hostBindings: function NbButtonGroupComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵattribute("role", ctx.role);
          ɵɵclassMap(ctx.additionalClasses);
        }
      },
      inputs: {
        size: "size",
        status: "status",
        shape: "shape",
        appearance: "appearance",
        disabled: "disabled",
        multiple: "multiple",
        filled: "filled",
        outline: "outline",
        ghost: "ghost"
      },
      outputs: {
        valueChange: "valueChange"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NB_BUTTON_GROUP,
        useExisting: _NbButtonGroupComponent
      }]), ɵɵNgOnChangesFeature],
      ngContentSelectors: _c03,
      decls: 1,
      vars: 0,
      template: function NbButtonGroupComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵprojection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-button-group",
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NB_BUTTON_GROUP,
        useExisting: NbButtonGroupComponent
      }],
      standalone: false
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NbStatusService
  }], {
    buttons: [{
      type: ContentChildren,
      args: [NbButton]
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    filled: [{
      type: Input
    }],
    outline: [{
      type: Input
    }],
    ghost: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NbButtonGroupModule = class _NbButtonGroupModule {
  static {
    this.ɵfac = function NbButtonGroupModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbButtonGroupModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbButtonGroupModule,
      declarations: [NbButtonGroupComponent, NbButtonToggleDirective],
      exports: [NbButtonGroupComponent, NbButtonToggleDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonGroupModule, [{
    type: NgModule,
    args: [{
      declarations: [NbButtonGroupComponent, NbButtonToggleDirective],
      exports: [NbButtonGroupComponent, NbButtonToggleDirective]
    }]
  }], null, null);
})();
var NbListPageTrackerDirective = class _NbListPageTrackerDirective {
  constructor() {
    this.destroy$ = new Subject();
    this.startPage = 1;
    this.pageChange = new EventEmitter();
    this.observer = new IntersectionObserver((entries) => this.checkForPageChange(entries), {
      threshold: 0.5
    });
  }
  ngAfterViewInit() {
    if (this.listItems && this.listItems.length) {
      this.observeItems();
    }
    this.listItems.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.observeItems());
  }
  ngOnDestroy() {
    this.observer.disconnect && this.observer.disconnect();
  }
  observeItems() {
    this.listItems.forEach((i) => this.observer.observe(i.nativeElement));
  }
  checkForPageChange(entries) {
    const mostVisiblePage = this.findMostVisiblePage(entries);
    if (mostVisiblePage && this.currentPage !== mostVisiblePage) {
      this.currentPage = mostVisiblePage;
      this.pageChange.emit(this.currentPage);
    }
  }
  findMostVisiblePage(entries) {
    const intersectionRatioByPage = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      if (entry.intersectionRatio < 0.5) {
        continue;
      }
      const elementIndex = this.elementIndex(entry.target);
      if (elementIndex === -1) {
        continue;
      }
      const page = this.startPage + Math.floor(elementIndex / this.pageSize);
      let ratio = entry.intersectionRatio;
      if (intersectionRatioByPage.has(page)) {
        ratio += intersectionRatioByPage.get(page);
      }
      intersectionRatioByPage.set(page, ratio);
    }
    let maxRatio = 0;
    let mostVisiblePage;
    intersectionRatioByPage.forEach((ratio, page) => {
      if (ratio > maxRatio) {
        maxRatio = ratio;
        mostVisiblePage = page;
      }
    });
    return mostVisiblePage;
  }
  elementIndex(element) {
    return element.parentElement && element.parentElement.children ? Array.from(element.parentElement.children).indexOf(element) : -1;
  }
  static {
    this.ɵfac = function NbListPageTrackerDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbListPageTrackerDirective)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbListPageTrackerDirective,
      selectors: [["", "nbListPageTracker", ""]],
      contentQueries: function NbListPageTrackerDirective_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbListItemComponent, 4, ElementRef);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listItems = _t);
        }
      },
      inputs: {
        pageSize: "pageSize",
        startPage: "startPage"
      },
      outputs: {
        pageChange: "pageChange"
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListPageTrackerDirective, [{
    type: Directive,
    args: [{
      selector: "[nbListPageTracker]",
      standalone: false
    }]
  }], () => [], {
    pageSize: [{
      type: Input
    }],
    startPage: [{
      type: Input
    }],
    pageChange: [{
      type: Output
    }],
    listItems: [{
      type: ContentChildren,
      args: [NbListItemComponent, {
        read: ElementRef
      }]
    }]
  });
})();
var NbScrollableContainerDimensions = class {
};
var NbInfiniteListDirective = class _NbInfiniteListDirective {
  get elementScroll() {
    return !this.windowScroll;
  }
  /**
   * Prevent subsequent bottom/topThreshold emissions for specified duration after emitting once.
   * In milliseconds.
   */
  set throttleTime(value) {
    this.throttleTime$.next(value);
  }
  get throttleTime() {
    return this.throttleTime$.value;
  }
  /**
   * By default component observes list scroll position.
   * If set to `true`, component will observe position of page scroll instead.
   */
  set listenWindowScroll(value) {
    this.windowScroll = convertToBoolProperty(value);
  }
  onElementScroll() {
    if (this.elementScroll) {
      this.elementScroll$.next();
    }
  }
  constructor(elementRef, scrollService, dimensionsService) {
    this.elementRef = elementRef;
    this.scrollService = scrollService;
    this.dimensionsService = dimensionsService;
    this.destroy$ = new Subject();
    this.windowScroll = false;
    this.elementScroll$ = new Subject();
    this.windowScroll$ = this.scrollService.onScroll().pipe(filter(() => this.windowScroll));
    this.bottomThreshold$ = new Subject();
    this.topThreshold$ = new Subject();
    this.throttleTime$ = new BehaviorSubject(0);
    this.bottomThreshold = new EventEmitter(true);
    this.topThreshold = new EventEmitter(true);
  }
  ngAfterViewInit() {
    merge(this.windowScroll$, this.elementScroll$).pipe(switchMap(() => this.getContainerDimensions()), takeUntil(this.destroy$)).subscribe((dimensions) => this.checkPosition(dimensions));
    this.throttleTime$.pipe(switchMap(() => this.topThreshold$.pipe(throttle(() => interval(this.throttleTime)))), takeUntil(this.destroy$)).subscribe(() => {
      this.topThreshold.emit();
    });
    this.throttleTime$.pipe(switchMap(() => this.bottomThreshold$.pipe(throttle(() => interval(this.throttleTime)))), takeUntil(this.destroy$)).subscribe(() => {
      this.bottomThreshold.emit();
    });
    this.listItems.changes.pipe(
      // For some reason, changes are emitted before list item removed from dom,
      // so dimensions will be incorrect.
      // Check every 50ms for a second if dom and query are in sync.
      // Once they synchronized, we can get proper dimensions.
      switchMap(() => interval(50).pipe(filter(() => this.inSyncWithDom()), take(1), takeUntil(timer(1e3)))),
      switchMap(() => this.getContainerDimensions()),
      takeUntil(this.destroy$)
    ).subscribe((dimensions) => this.checkPosition(dimensions));
    this.getContainerDimensions().subscribe((dimensions) => this.checkPosition(dimensions));
  }
  ngOnDestroy() {
    this.topThreshold$.complete();
    this.bottomThreshold$.complete();
    this.elementScroll$.complete();
    this.destroy$.next();
    this.destroy$.complete();
  }
  checkPosition({
    scrollHeight,
    scrollTop,
    clientHeight
  }) {
    const initialCheck = this.lastScrollPosition == null;
    const manualCheck = this.lastScrollPosition === scrollTop;
    const scrollUp = scrollTop < this.lastScrollPosition;
    const scrollDown = scrollTop > this.lastScrollPosition;
    const distanceToBottom = scrollHeight - scrollTop - clientHeight;
    if ((initialCheck || manualCheck || scrollDown) && distanceToBottom <= this.threshold) {
      this.bottomThreshold$.next();
    }
    if ((initialCheck || scrollUp) && scrollTop <= this.threshold) {
      this.topThreshold$.next();
    }
    this.lastScrollPosition = scrollTop;
  }
  getContainerDimensions() {
    if (this.elementScroll) {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = this.elementRef.nativeElement;
      return of({
        scrollTop,
        scrollHeight,
        clientHeight
      });
    }
    return forkJoin([this.scrollService.getPosition(), this.dimensionsService.getDimensions()]).pipe(map(([scrollPosition, dimensions]) => ({
      scrollTop: scrollPosition.y,
      scrollHeight: dimensions.scrollHeight,
      clientHeight: dimensions.clientHeight
    })));
  }
  inSyncWithDom() {
    return this.elementRef.nativeElement.children.length === this.listItems.length;
  }
  static {
    this.ɵfac = function NbInfiniteListDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbInfiniteListDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbLayoutScrollService), ɵɵdirectiveInject(NbLayoutRulerService));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbInfiniteListDirective,
      selectors: [["", "nbInfiniteList", ""]],
      contentQueries: function NbInfiniteListDirective_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbListItemComponent, 4);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listItems = _t);
        }
      },
      hostBindings: function NbInfiniteListDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("scroll", function NbInfiniteListDirective_scroll_HostBindingHandler() {
            return ctx.onElementScroll();
          });
        }
      },
      inputs: {
        threshold: "threshold",
        throttleTime: "throttleTime",
        listenWindowScroll: "listenWindowScroll"
      },
      outputs: {
        bottomThreshold: "bottomThreshold",
        topThreshold: "topThreshold"
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInfiniteListDirective, [{
    type: Directive,
    args: [{
      selector: "[nbInfiniteList]",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbLayoutScrollService
  }, {
    type: NbLayoutRulerService
  }], {
    threshold: [{
      type: Input
    }],
    throttleTime: [{
      type: Input
    }],
    listenWindowScroll: [{
      type: Input
    }],
    bottomThreshold: [{
      type: Output
    }],
    topThreshold: [{
      type: Output
    }],
    onElementScroll: [{
      type: HostListener,
      args: ["scroll"]
    }],
    listItems: [{
      type: ContentChildren,
      args: [NbListItemComponent]
    }]
  });
})();
var components = [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective];
var NbListModule = class _NbListModule {
  static {
    this.ɵfac = function NbListModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbListModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbListModule,
      declarations: [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective],
      exports: [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListModule, [{
    type: NgModule,
    args: [{
      declarations: components,
      exports: components
    }]
  }], null, null);
})();
var NbDirectionality = class _NbDirectionality extends Directionality {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbDirectionality_BaseFactory;
      return function NbDirectionality_Factory(__ngFactoryType__) {
        return (ɵNbDirectionality_BaseFactory || (ɵNbDirectionality_BaseFactory = ɵɵgetInheritedFactory(_NbDirectionality)))(__ngFactoryType__ || _NbDirectionality);
      };
    })();
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbDirectionality,
      factory: _NbDirectionality.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDirectionality, [{
    type: Injectable
  }], null, null);
})();
var NbBidiModule = class _NbBidiModule extends BidiModule {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbBidiModule_BaseFactory;
      return function NbBidiModule_Factory(__ngFactoryType__) {
        return (ɵNbBidiModule_BaseFactory || (ɵNbBidiModule_BaseFactory = ɵɵgetInheritedFactory(_NbBidiModule)))(__ngFactoryType__ || _NbBidiModule);
      };
    })();
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbBidiModule
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [{
        provide: NbDirectionality,
        useExisting: Directionality
      }]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBidiModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: NbDirectionality,
        useExisting: Directionality
      }]
    }]
  }], null, null);
})();
var NbCellDefDirective = class _NbCellDefDirective extends CdkCellDef {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbCellDefDirective_BaseFactory;
      return function NbCellDefDirective_Factory(__ngFactoryType__) {
        return (ɵNbCellDefDirective_BaseFactory || (ɵNbCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbCellDefDirective)))(__ngFactoryType__ || _NbCellDefDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbCellDefDirective,
      selectors: [["", "nbCellDef", ""]],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: CdkCellDef,
        useExisting: _NbCellDefDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbCellDef]",
      providers: [{
        provide: CdkCellDef,
        useExisting: NbCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbHeaderCellDefDirective = class _NbHeaderCellDefDirective extends CdkHeaderCellDef {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbHeaderCellDefDirective_BaseFactory;
      return function NbHeaderCellDefDirective_Factory(__ngFactoryType__) {
        return (ɵNbHeaderCellDefDirective_BaseFactory || (ɵNbHeaderCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderCellDefDirective)))(__ngFactoryType__ || _NbHeaderCellDefDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbHeaderCellDefDirective,
      selectors: [["", "nbHeaderCellDef", ""]],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: CdkHeaderCellDef,
        useExisting: _NbHeaderCellDefDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderCellDef]",
      providers: [{
        provide: CdkHeaderCellDef,
        useExisting: NbHeaderCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbFooterCellDefDirective = class _NbFooterCellDefDirective extends CdkFooterCellDef {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbFooterCellDefDirective_BaseFactory;
      return function NbFooterCellDefDirective_Factory(__ngFactoryType__) {
        return (ɵNbFooterCellDefDirective_BaseFactory || (ɵNbFooterCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFooterCellDefDirective)))(__ngFactoryType__ || _NbFooterCellDefDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbFooterCellDefDirective,
      selectors: [["", "nbFooterCellDef", ""]],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: CdkFooterCellDef,
        useExisting: _NbFooterCellDefDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterCellDef]",
      providers: [{
        provide: CdkFooterCellDef,
        useExisting: NbFooterCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NB_SORT_HEADER_COLUMN_DEF = new InjectionToken("NB_SORT_HEADER_COLUMN_DEF");
var NbColumnDefDirective = class _NbColumnDefDirective extends CdkColumnDef {
  constructor() {
    super(...arguments);
    this._hasStickyCellChanged = false;
    this._stickyCell = false;
  }
  /** Unique name for this column. */
  get name() {
    return this._name;
  }
  set name(value) {
    this._setNameInput(value);
  }
  /** Whether this column should be sticky positioned at the start of the row */
  get sticky() {
    return this._stickyCell;
  }
  set sticky(value) {
    if (value !== this._stickyCell) {
      this._stickyCell = value;
      this._hasStickyCellChanged = true;
    }
  }
  /** Whether this column should be sticky positioned on the end of the row */
  get stickyEnd() {
    return this._stickyEnd;
  }
  set stickyEnd(value) {
    const prevValue = this._stickyEnd;
    this._stickyEnd = coerceBooleanProperty(value);
    this._hasStickyCellChanged = prevValue !== this._stickyEnd;
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyCellChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyCellChanged = false;
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbColumnDefDirective_BaseFactory;
      return function NbColumnDefDirective_Factory(__ngFactoryType__) {
        return (ɵNbColumnDefDirective_BaseFactory || (ɵNbColumnDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbColumnDefDirective)))(__ngFactoryType__ || _NbColumnDefDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbColumnDefDirective,
      selectors: [["", "nbColumnDef", ""]],
      inputs: {
        name: [0, "nbColumnDef", "name"],
        sticky: "sticky",
        stickyEnd: "stickyEnd"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: CdkColumnDef,
        useExisting: _NbColumnDefDirective
      }, {
        provide: NB_SORT_HEADER_COLUMN_DEF,
        useExisting: _NbColumnDefDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbColumnDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbColumnDef]",
      providers: [{
        provide: CdkColumnDef,
        useExisting: NbColumnDefDirective
      }, {
        provide: NB_SORT_HEADER_COLUMN_DEF,
        useExisting: NbColumnDefDirective
      }],
      standalone: false
    }]
  }], null, {
    name: [{
      type: Input,
      args: ["nbColumnDef"]
    }],
    sticky: [{
      type: Input
    }],
    stickyEnd: [{
      type: Input
    }]
  });
})();
var NbHeaderCellDirective = class _NbHeaderCellDirective extends CdkHeaderCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
  static {
    this.ɵfac = function NbHeaderCellDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbHeaderCellDirective)(ɵɵdirectiveInject(NbColumnDefDirective), ɵɵdirectiveInject(ElementRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbHeaderCellDirective,
      selectors: [["nb-header-cell"], ["th", "nbHeaderCell", ""]],
      hostAttrs: ["role", "columnheader", 1, "nb-header-cell"],
      standalone: false,
      features: [ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-header-cell, th[nbHeaderCell]",
      host: {
        class: "nb-header-cell",
        role: "columnheader"
      },
      standalone: false
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var NbFooterCellDirective = class _NbFooterCellDirective extends CdkFooterCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
  static {
    this.ɵfac = function NbFooterCellDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbFooterCellDirective)(ɵɵdirectiveInject(NbColumnDefDirective), ɵɵdirectiveInject(ElementRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbFooterCellDirective,
      selectors: [["nb-footer-cell"], ["td", "nbFooterCell", ""]],
      hostAttrs: ["role", "gridcell", 1, "nb-footer-cell"],
      standalone: false,
      features: [ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-footer-cell, td[nbFooterCell]",
      host: {
        class: "nb-footer-cell",
        role: "gridcell"
      },
      standalone: false
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var NbCellDirective = class _NbCellDirective extends CdkCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
  static {
    this.ɵfac = function NbCellDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbCellDirective)(ɵɵdirectiveInject(NbColumnDefDirective), ɵɵdirectiveInject(ElementRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbCellDirective,
      selectors: [["nb-cell"], ["td", "nbCell", ""]],
      hostAttrs: ["role", "gridcell", 1, "nb-cell"],
      standalone: false,
      features: [ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-cell, td[nbCell]",
      host: {
        class: "nb-cell",
        role: "gridcell"
      },
      standalone: false
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var NbDataSource = class extends DataSource {
};
var NbDataRowOutletDirective = class _NbDataRowOutletDirective extends DataRowOutlet {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbDataRowOutletDirective_BaseFactory;
      return function NbDataRowOutletDirective_Factory(__ngFactoryType__) {
        return (ɵNbDataRowOutletDirective_BaseFactory || (ɵNbDataRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbDataRowOutletDirective)))(__ngFactoryType__ || _NbDataRowOutletDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbDataRowOutletDirective,
      selectors: [["", "nbRowOutlet", ""]],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: DataRowOutlet,
        useExisting: _NbDataRowOutletDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDataRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRowOutlet]",
      providers: [{
        provide: DataRowOutlet,
        useExisting: NbDataRowOutletDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbHeaderRowOutletDirective = class _NbHeaderRowOutletDirective extends HeaderRowOutlet {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbHeaderRowOutletDirective_BaseFactory;
      return function NbHeaderRowOutletDirective_Factory(__ngFactoryType__) {
        return (ɵNbHeaderRowOutletDirective_BaseFactory || (ɵNbHeaderRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderRowOutletDirective)))(__ngFactoryType__ || _NbHeaderRowOutletDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbHeaderRowOutletDirective,
      selectors: [["", "nbHeaderRowOutlet", ""]],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: HeaderRowOutlet,
        useExisting: _NbHeaderRowOutletDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderRowOutlet]",
      providers: [{
        provide: HeaderRowOutlet,
        useExisting: NbHeaderRowOutletDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbFooterRowOutletDirective = class _NbFooterRowOutletDirective extends FooterRowOutlet {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbFooterRowOutletDirective_BaseFactory;
      return function NbFooterRowOutletDirective_Factory(__ngFactoryType__) {
        return (ɵNbFooterRowOutletDirective_BaseFactory || (ɵNbFooterRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFooterRowOutletDirective)))(__ngFactoryType__ || _NbFooterRowOutletDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbFooterRowOutletDirective,
      selectors: [["", "nbFooterRowOutlet", ""]],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: FooterRowOutlet,
        useExisting: _NbFooterRowOutletDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterRowOutlet]",
      providers: [{
        provide: FooterRowOutlet,
        useExisting: NbFooterRowOutletDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbNoDataRowOutletDirective = class _NbNoDataRowOutletDirective extends NoDataRowOutlet {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbNoDataRowOutletDirective_BaseFactory;
      return function NbNoDataRowOutletDirective_Factory(__ngFactoryType__) {
        return (ɵNbNoDataRowOutletDirective_BaseFactory || (ɵNbNoDataRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbNoDataRowOutletDirective)))(__ngFactoryType__ || _NbNoDataRowOutletDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbNoDataRowOutletDirective,
      selectors: [["", "nbNoDataRowOutlet", ""]],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NoDataRowOutlet,
        useExisting: _NbNoDataRowOutletDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbNoDataRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbNoDataRowOutlet]",
      providers: [{
        provide: NoDataRowOutlet,
        useExisting: NbNoDataRowOutletDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbCellOutletDirective = class _NbCellOutletDirective extends CdkCellOutlet {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbCellOutletDirective_BaseFactory;
      return function NbCellOutletDirective_Factory(__ngFactoryType__) {
        return (ɵNbCellOutletDirective_BaseFactory || (ɵNbCellOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbCellOutletDirective)))(__ngFactoryType__ || _NbCellOutletDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbCellOutletDirective,
      selectors: [["", "nbCellOutlet", ""]],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: CdkCellOutlet,
        useExisting: _NbCellOutletDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbCellOutlet]",
      providers: [{
        provide: CdkCellOutlet,
        useExisting: NbCellOutletDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbHeaderRowDefDirective = class _NbHeaderRowDefDirective extends CdkHeaderRowDef {
  constructor() {
    super(...arguments);
    this._hasStickyRowChanged = false;
    this._stickyRow = false;
  }
  get sticky() {
    return this._stickyRow;
  }
  set sticky(value) {
    if (value !== this._stickyRow) {
      this._stickyRow = value;
      this._hasStickyRowChanged = true;
    }
  }
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyRowChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyRowChanged = false;
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbHeaderRowDefDirective_BaseFactory;
      return function NbHeaderRowDefDirective_Factory(__ngFactoryType__) {
        return (ɵNbHeaderRowDefDirective_BaseFactory || (ɵNbHeaderRowDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderRowDefDirective)))(__ngFactoryType__ || _NbHeaderRowDefDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbHeaderRowDefDirective,
      selectors: [["", "nbHeaderRowDef", ""]],
      inputs: {
        columns: [0, "nbHeaderRowDef", "columns"],
        sticky: [0, "nbHeaderRowDefSticky", "sticky"]
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: CdkHeaderRowDef,
        useExisting: _NbHeaderRowDefDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderRowDef]",
      providers: [{
        provide: CdkHeaderRowDef,
        useExisting: NbHeaderRowDefDirective
      }],
      standalone: false
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbHeaderRowDef"]
    }],
    sticky: [{
      type: Input,
      args: ["nbHeaderRowDefSticky"]
    }]
  });
})();
var NbFooterRowDefDirective = class _NbFooterRowDefDirective extends CdkFooterRowDef {
  constructor() {
    super(...arguments);
    this._hasStickyRowChanged = false;
    this._stickyRow = false;
  }
  get sticky() {
    return this._stickyRow;
  }
  set sticky(value) {
    if (value !== this._stickyRow) {
      this._stickyRow = value;
      this._hasStickyRowChanged = true;
    }
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyRowChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyRowChanged = false;
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbFooterRowDefDirective_BaseFactory;
      return function NbFooterRowDefDirective_Factory(__ngFactoryType__) {
        return (ɵNbFooterRowDefDirective_BaseFactory || (ɵNbFooterRowDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFooterRowDefDirective)))(__ngFactoryType__ || _NbFooterRowDefDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbFooterRowDefDirective,
      selectors: [["", "nbFooterRowDef", ""]],
      inputs: {
        columns: [0, "nbFooterRowDef", "columns"],
        sticky: [0, "nbFooterRowDefSticky", "sticky"]
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: CdkFooterRowDef,
        useExisting: _NbFooterRowDefDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterRowDef]",
      providers: [{
        provide: CdkFooterRowDef,
        useExisting: NbFooterRowDefDirective
      }],
      standalone: false
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbFooterRowDef"]
    }],
    sticky: [{
      type: Input,
      args: ["nbFooterRowDefSticky"]
    }]
  });
})();
var NbRowDefDirective = class _NbRowDefDirective extends CdkRowDef {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbRowDefDirective_BaseFactory;
      return function NbRowDefDirective_Factory(__ngFactoryType__) {
        return (ɵNbRowDefDirective_BaseFactory || (ɵNbRowDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbRowDefDirective)))(__ngFactoryType__ || _NbRowDefDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbRowDefDirective,
      selectors: [["", "nbRowDef", ""]],
      inputs: {
        columns: [0, "nbRowDefColumns", "columns"],
        when: [0, "nbRowDefWhen", "when"]
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: CdkRowDef,
        useExisting: _NbRowDefDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRowDef]",
      providers: [{
        provide: CdkRowDef,
        useExisting: NbRowDefDirective
      }],
      standalone: false
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbRowDefColumns"]
    }],
    when: [{
      type: Input,
      args: ["nbRowDefWhen"]
    }]
  });
})();
var NbHeaderRowComponent = class _NbHeaderRowComponent extends CdkHeaderRow {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbHeaderRowComponent_BaseFactory;
      return function NbHeaderRowComponent_Factory(__ngFactoryType__) {
        return (ɵNbHeaderRowComponent_BaseFactory || (ɵNbHeaderRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderRowComponent)))(__ngFactoryType__ || _NbHeaderRowComponent);
      };
    })();
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbHeaderRowComponent,
      selectors: [["nb-header-row"], ["tr", "nbHeaderRow", ""]],
      hostAttrs: ["role", "row", 1, "nb-header-row"],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: CdkHeaderRow,
        useExisting: _NbHeaderRowComponent
      }]), ɵɵInheritDefinitionFeature],
      decls: 1,
      vars: 0,
      consts: [["nbCellOutlet", ""]],
      template: function NbHeaderRowComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementContainer(0, 0);
        }
      },
      dependencies: [NbCellOutletDirective],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-header-row, tr[nbHeaderRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      host: {
        class: "nb-header-row",
        role: "row"
      },
      providers: [{
        provide: CdkHeaderRow,
        useExisting: NbHeaderRowComponent
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbFooterRowComponent = class _NbFooterRowComponent extends CdkFooterRow {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbFooterRowComponent_BaseFactory;
      return function NbFooterRowComponent_Factory(__ngFactoryType__) {
        return (ɵNbFooterRowComponent_BaseFactory || (ɵNbFooterRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbFooterRowComponent)))(__ngFactoryType__ || _NbFooterRowComponent);
      };
    })();
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbFooterRowComponent,
      selectors: [["nb-footer-row"], ["tr", "nbFooterRow", ""]],
      hostAttrs: ["role", "row", 1, "nb-footer-row"],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: CdkFooterRow,
        useExisting: _NbFooterRowComponent
      }]), ɵɵInheritDefinitionFeature],
      decls: 1,
      vars: 0,
      consts: [["nbCellOutlet", ""]],
      template: function NbFooterRowComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementContainer(0, 0);
        }
      },
      dependencies: [NbCellOutletDirective],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-footer-row, tr[nbFooterRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      host: {
        class: "nb-footer-row",
        role: "row"
      },
      providers: [{
        provide: CdkFooterRow,
        useExisting: NbFooterRowComponent
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbRowComponent = class _NbRowComponent extends CdkRow {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbRowComponent_BaseFactory;
      return function NbRowComponent_Factory(__ngFactoryType__) {
        return (ɵNbRowComponent_BaseFactory || (ɵNbRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbRowComponent)))(__ngFactoryType__ || _NbRowComponent);
      };
    })();
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbRowComponent,
      selectors: [["nb-row"], ["tr", "nbRow", ""]],
      hostAttrs: ["role", "row", 1, "nb-row"],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: CdkRow,
        useExisting: _NbRowComponent
      }]), ɵɵInheritDefinitionFeature],
      decls: 1,
      vars: 0,
      consts: [["nbCellOutlet", ""]],
      template: function NbRowComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementContainer(0, 0);
        }
      },
      dependencies: [NbCellOutletDirective],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-row, tr[nbRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      host: {
        class: "nb-row",
        role: "row"
      },
      providers: [{
        provide: CdkRow,
        useExisting: NbRowComponent
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbCdkRowDef = CdkRowDef;
var NbCdkRow = CdkRow;
var NbCdkCellDef = CdkCellDef;
var NbCdkHeaderRowDef = CdkHeaderRowDef;
var NbCdkHeaderRow = CdkHeaderRow;
var NbCdkHeaderCellDef = CdkHeaderCellDef;
var NbCdkFooterRowDef = CdkFooterRowDef;
var NbCdkFooterRow = CdkFooterRow;
var NbCdkFooterCellDef = CdkFooterCellDef;
var NbCdkColumnDef = CdkColumnDef;
var NbCdkCell = CdkCell;
var NbCdkHeaderCell = CdkHeaderCell;
var NbCdkFooterCell = CdkFooterCell;
var NB_STICKY_POSITIONING_LISTENER = STICKY_POSITIONING_LISTENER;
var NB_TABLE_TEMPLATE = `
  <ng-container nbHeaderRowOutlet></ng-container>
  <ng-container nbRowOutlet></ng-container>
  <ng-container nbNoDataRowOutlet></ng-container>
  <ng-container nbFooterRowOutlet></ng-container>
`;
var NB_VIEW_REPEATER_STRATEGY = _VIEW_REPEATER_STRATEGY;
var NB_COALESCED_STYLE_SCHEDULER = _COALESCED_STYLE_SCHEDULER;
var NB_TABLE_PROVIDERS = [{
  provide: NB_VIEW_REPEATER_STRATEGY,
  useClass: _DisposeViewRepeaterStrategy
}, {
  provide: NB_COALESCED_STYLE_SCHEDULER,
  useClass: _CoalescedStyleScheduler
}];
var NbTable = class _NbTable extends CdkTable {
  constructor(differs, changeDetectorRef, elementRef, role, dir, document2, platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener) {
    super(differs, changeDetectorRef, elementRef, role, dir, document2, platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener);
    this._viewRepeater = _viewRepeater;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._stickyPositioningListener = _stickyPositioningListener;
  }
  static {
    this.ɵfac = function NbTable_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTable)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵinjectAttribute("role"), ɵɵdirectiveInject(NbDirectionality), ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPlatform), ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY), ɵɵdirectiveInject(_COALESCED_STYLE_SCHEDULER), ɵɵdirectiveInject(NbViewportRulerAdapter), ɵɵdirectiveInject(NB_STICKY_POSITIONING_LISTENER, 12));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTable,
      selectors: [["nb-table-not-implemented"]],
      standalone: false,
      features: [ɵɵProvidersFeature(NB_TABLE_PROVIDERS), ɵɵInheritDefinitionFeature],
      decls: 0,
      vars: 0,
      template: function NbTable_Template(rf, ctx) {
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTable, [{
    type: Component,
    args: [{
      selector: "nb-table-not-implemented",
      template: ``,
      providers: NB_TABLE_PROVIDERS,
      standalone: false
    }]
  }], () => [{
    type: IterableDiffers
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["role"]
    }]
  }, {
    type: NbDirectionality
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: _CoalescedStyleScheduler,
    decorators: [{
      type: Inject,
      args: [_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [NB_STICKY_POSITIONING_LISTENER]
    }]
  }], null);
})();
var COMPONENTS$2 = [
  NbTable,
  // Template defs
  NbHeaderCellDefDirective,
  NbHeaderRowDefDirective,
  NbColumnDefDirective,
  NbCellDefDirective,
  NbRowDefDirective,
  NbFooterCellDefDirective,
  NbFooterRowDefDirective,
  // Outlets
  NbDataRowOutletDirective,
  NbHeaderRowOutletDirective,
  NbFooterRowOutletDirective,
  NbNoDataRowOutletDirective,
  NbCellOutletDirective,
  // Cell directives
  NbHeaderCellDirective,
  NbCellDirective,
  NbFooterCellDirective,
  // Row directives
  NbHeaderRowComponent,
  NbRowComponent,
  NbFooterRowComponent
];
var NbTableModule = class _NbTableModule extends CdkTableModule {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbTableModule_BaseFactory;
      return function NbTableModule_Factory(__ngFactoryType__) {
        return (ɵNbTableModule_BaseFactory || (ɵNbTableModule_BaseFactory = ɵɵgetInheritedFactory(_NbTableModule)))(__ngFactoryType__ || _NbTableModule);
      };
    })();
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbTableModule,
      declarations: [
        NbTable,
        // Template defs
        NbHeaderCellDefDirective,
        NbHeaderRowDefDirective,
        NbColumnDefDirective,
        NbCellDefDirective,
        NbRowDefDirective,
        NbFooterCellDefDirective,
        NbFooterRowDefDirective,
        // Outlets
        NbDataRowOutletDirective,
        NbHeaderRowOutletDirective,
        NbFooterRowOutletDirective,
        NbNoDataRowOutletDirective,
        NbCellOutletDirective,
        // Cell directives
        NbHeaderCellDirective,
        NbCellDirective,
        NbFooterCellDirective,
        // Row directives
        NbHeaderRowComponent,
        NbRowComponent,
        NbFooterRowComponent
      ],
      imports: [NbBidiModule],
      exports: [
        NbTable,
        // Template defs
        NbHeaderCellDefDirective,
        NbHeaderRowDefDirective,
        NbColumnDefDirective,
        NbCellDefDirective,
        NbRowDefDirective,
        NbFooterCellDefDirective,
        NbFooterRowDefDirective,
        // Outlets
        NbDataRowOutletDirective,
        NbHeaderRowOutletDirective,
        NbFooterRowOutletDirective,
        NbNoDataRowOutletDirective,
        NbCellOutletDirective,
        // Cell directives
        NbHeaderCellDirective,
        NbCellDirective,
        NbFooterCellDirective,
        // Row directives
        NbHeaderRowComponent,
        NbRowComponent,
        NbFooterRowComponent
      ]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbBidiModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTableModule, [{
    type: NgModule,
    args: [{
      imports: [NbBidiModule],
      declarations: [...COMPONENTS$2],
      exports: [...COMPONENTS$2]
    }]
  }], null, null);
})();
var NB_DIALOG_CONFIG = new InjectionToken("Default dialog options");
var NbDialogConfig = class {
  constructor(config) {
    this.hasBackdrop = true;
    this.backdropClass = "overlay-backdrop";
    this.dialogClass = "";
    this.closeOnBackdropClick = true;
    this.closeOnEsc = true;
    this.hasScroll = false;
    this.autoFocus = true;
    Object.assign(this, config);
  }
};
var NbDialogRef = class {
  constructor(overlayRef) {
    this.overlayRef = overlayRef;
    this.onClose$ = new Subject();
    this.onClose = this.onClose$.asObservable();
    this.onBackdropClick = this.overlayRef.backdropClick();
  }
  /**
   * Hides dialog.
   * */
  close(res) {
    this.overlayRef.detach();
    this.overlayRef.dispose();
    this.onClose$.next(res);
    this.onClose$.complete();
  }
};
var NbDialogContainerComponent = class _NbDialogContainerComponent {
  constructor(config, elementRef, focusTrapFactory) {
    this.config = config;
    this.elementRef = elementRef;
    this.focusTrapFactory = focusTrapFactory;
  }
  ngOnInit() {
    if (this.config.autoFocus) {
      this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
      this.focusTrap.blurPreviouslyFocusedElement();
      this.focusTrap.focusInitialElement();
    }
  }
  ngOnDestroy() {
    if (this.config.autoFocus && this.focusTrap) {
      this.focusTrap.restoreFocus();
    }
  }
  attachComponentPortal(portal) {
    return this.portalOutlet.attachComponentPortal(portal);
  }
  attachTemplatePortal(portal) {
    return this.portalOutlet.attachTemplatePortal(portal);
  }
  static {
    this.ɵfac = function NbDialogContainerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbDialogContainerComponent)(ɵɵdirectiveInject(NbDialogConfig), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbFocusTrapFactoryService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbDialogContainerComponent,
      selectors: [["nb-dialog-container"]],
      viewQuery: function NbDialogContainerComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbPortalOutletDirective, 7);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
        }
      },
      standalone: false,
      decls: 1,
      vars: 0,
      consts: [["nbPortalOutlet", ""]],
      template: function NbDialogContainerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbDialogContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
        }
      },
      dependencies: [NbPortalOutletDirective],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-dialog-container",
      template: "<ng-template nbPortalOutlet></ng-template>",
      standalone: false
    }]
  }], () => [{
    type: NbDialogConfig
  }, {
    type: ElementRef
  }, {
    type: NbFocusTrapFactoryService
  }], {
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective, {
        static: true
      }]
    }]
  });
})();
var NbDialogService = class _NbDialogService {
  constructor(document2, globalConfig, positionBuilder, overlay, injector, cfr) {
    this.document = document2;
    this.globalConfig = globalConfig;
    this.positionBuilder = positionBuilder;
    this.overlay = overlay;
    this.injector = injector;
    this.cfr = cfr;
  }
  /**
   * Opens new instance of the dialog, may receive optional config.
   * */
  open(content, userConfig = {}) {
    const config = new NbDialogConfig(__spreadValues(__spreadValues({}, this.globalConfig), userConfig));
    const overlayRef = this.createOverlay(config);
    const dialogRef = new NbDialogRef(overlayRef);
    const container = this.createContainer(config, overlayRef);
    this.createContent(config, content, container, dialogRef);
    this.registerCloseListeners(config, overlayRef, dialogRef);
    return dialogRef;
  }
  createOverlay(config) {
    const positionStrategy = this.createPositionStrategy();
    const scrollStrategy = this.createScrollStrategy(config.hasScroll);
    return this.overlay.create({
      positionStrategy,
      scrollStrategy,
      hasBackdrop: config.hasBackdrop,
      backdropClass: config.backdropClass,
      panelClass: config.dialogClass
    });
  }
  createPositionStrategy() {
    return this.positionBuilder.global().centerVertically().centerHorizontally();
  }
  createScrollStrategy(hasScroll) {
    if (hasScroll) {
      return this.overlay.scrollStrategies.noop();
    } else {
      return this.overlay.scrollStrategies.block();
    }
  }
  createContainer(config, overlayRef) {
    const injector = new NbPortalInjector(this.createInjector(config), new WeakMap([[NbDialogConfig, config]]));
    const containerPortal = new NbComponentPortal(NbDialogContainerComponent, null, injector, this.cfr);
    const containerRef = overlayRef.attach(containerPortal);
    return containerRef.instance;
  }
  createContent(config, content, container, dialogRef) {
    if (content instanceof TemplateRef) {
      const portal = this.createTemplatePortal(config, content, dialogRef);
      container.attachTemplatePortal(portal);
    } else {
      const portal = this.createComponentPortal(config, content, dialogRef);
      dialogRef.componentRef = container.attachComponentPortal(portal);
      if (config.context) {
        Object.assign(dialogRef.componentRef.instance, __spreadValues({}, config.context));
      }
    }
  }
  createTemplatePortal(config, content, dialogRef) {
    return new NbTemplatePortal(content, null, {
      $implicit: config.context,
      dialogRef
    });
  }
  /**
   * We're creating portal with custom injector provided through config or using global injector.
   * This approach provides us capability inject `NbDialogRef` in dialog component.
   * */
  createComponentPortal(config, content, dialogRef) {
    const injector = this.createInjector(config);
    const portalInjector = new NbPortalInjector(injector, new WeakMap([[NbDialogRef, dialogRef]]));
    return new NbComponentPortal(content, config.viewContainerRef, portalInjector);
  }
  createInjector(config) {
    return config.viewContainerRef && config.viewContainerRef.injector || this.injector;
  }
  registerCloseListeners(config, overlayRef, dialogRef) {
    if (config.closeOnBackdropClick) {
      overlayRef.backdropClick().subscribe(() => dialogRef.close());
    }
    if (config.closeOnEsc) {
      fromEvent(this.document, "keyup").pipe(filter((event) => event.keyCode === 27), takeUntil(dialogRef.onClose)).subscribe(() => dialogRef.close());
    }
  }
  static {
    this.ɵfac = function NbDialogService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbDialogService)(ɵɵinject(NB_DOCUMENT), ɵɵinject(NB_DIALOG_CONFIG), ɵɵinject(NbPositionBuilderService), ɵɵinject(NbOverlayService), ɵɵinject(Injector), ɵɵinject(ComponentFactoryResolver$1));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbDialogService,
      factory: _NbDialogService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DIALOG_CONFIG]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: Injector
  }, {
    type: ComponentFactoryResolver$1
  }], null);
})();
var NbDialogModule = class _NbDialogModule {
  static forRoot(dialogConfig = {}) {
    return {
      ngModule: _NbDialogModule,
      providers: [NbDialogService, {
        provide: NB_DIALOG_CONFIG,
        useValue: dialogConfig
      }]
    };
  }
  static forChild(dialogConfig = {}) {
    return {
      ngModule: _NbDialogModule,
      providers: [NbDialogService, {
        provide: NB_DIALOG_CONFIG,
        useValue: dialogConfig
      }]
    };
  }
  static {
    this.ɵfac = function NbDialogModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbDialogModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbDialogModule,
      declarations: [NbDialogContainerComponent],
      imports: [NbSharedModule, NbOverlayModule]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbOverlayModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule],
      declarations: [NbDialogContainerComponent]
    }]
  }], null, null);
})();
var NbToastComponent = class _NbToastComponent {
  get success() {
    return this.toast.config.status === "success";
  }
  get info() {
    return this.toast.config.status === "info";
  }
  get warning() {
    return this.toast.config.status === "warning";
  }
  get primary() {
    return this.toast.config.status === "primary";
  }
  get danger() {
    return this.toast.config.status === "danger";
  }
  get basic() {
    return this.toast.config.status === "basic";
  }
  get control() {
    return this.toast.config.status === "control";
  }
  get destroyByClick() {
    return this.toast.config.destroyByClick;
  }
  get hasIcon() {
    const {
      icon
    } = this.toast.config;
    if (typeof icon === "string") {
      return true;
    }
    return !!(icon && icon.icon);
  }
  get customIcon() {
    return !!this.icon;
  }
  get icon() {
    return this.toast.config.icon;
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.toast.config.status)) {
      return [this.statusService.getStatusClass(this.toast.config.status)];
    }
    return [];
  }
  onClick() {
    this.toastClick.emit();
  }
  constructor(renderer, elementRef, statusService) {
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.statusService = statusService;
    this.destroy = new EventEmitter();
    this.toastClick = new EventEmitter();
  }
  ngOnInit() {
    if (this.toast.config.toastClass) {
      this.renderer.addClass(this.elementRef.nativeElement, this.toast.config.toastClass);
    }
  }
  ngOnDestroy() {
    this.destroy.emit();
  }
  static {
    this.ɵfac = function NbToastComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbToastComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbToastComponent,
      selectors: [["nb-toast"]],
      hostVars: 22,
      hostBindings: function NbToastComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbToastComponent_click_HostBindingHandler() {
            return ctx.onClick();
          });
        }
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-primary", ctx.primary)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("destroy-by-click", ctx.destroyByClick)("has-icon", ctx.hasIcon)("custom-icon", ctx.customIcon);
        }
      },
      inputs: {
        toast: "toast"
      },
      outputs: {
        destroy: "destroy",
        toastClick: "toastClick"
      },
      standalone: false,
      decls: 6,
      vars: 3,
      consts: [["class", "icon-container", 4, "ngIf"], [1, "content-container"], [1, "title", "subtitle"], [1, "message"], [1, "icon-container"], [3, "config"]],
      template: function NbToastComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbToastComponent_div_0_Template, 2, 1, "div", 0);
          ɵɵelementStart(1, "div", 1)(2, "span", 2);
          ɵɵtext(3);
          ɵɵelementEnd();
          ɵɵelementStart(4, "div", 3);
          ɵɵtext(5);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.hasIcon && ctx.icon);
          ɵɵadvance(3);
          ɵɵtextInterpolate(ctx.toast.title);
          ɵɵadvance(2);
          ɵɵtextInterpolate(ctx.toast.message);
        }
      },
      dependencies: [NgIf, NbIconComponent],
      styles: ["[_nghost-%COMP%]{display:flex;align-items:center;width:25rem;margin:.5rem}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{margin-right:.25rem}.default[_nghost-%COMP%]   .content-container[_ngcontent-%COMP%], [_nghost-%COMP%]:not(.has-icon)   .content-container[_ngcontent-%COMP%]{display:flex;flex-direction:row}.destroy-by-click[_nghost-%COMP%]{cursor:pointer}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{font-size:2.5rem}[_nghost-%COMP%]   svg[_ngcontent-%COMP%]{width:2.5rem;height:2.5rem}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastComponent, [{
    type: Component,
    args: [{
      selector: "nb-toast",
      standalone: false,
      template: '<div class="icon-container" *ngIf="hasIcon && icon">\n  <nb-icon [config]="icon"></nb-icon>\n</div>\n<div class="content-container">\n  <span class="title subtitle">{{ toast.title }}</span>\n  <div class="message">{{ toast.message }}</div>\n</div>\n',
      styles: [":host{display:flex;align-items:center;width:25rem;margin:.5rem}:host .title{margin-right:.25rem}:host.default .content-container,:host:not(.has-icon) .content-container{display:flex;flex-direction:row}:host.destroy-by-click{cursor:pointer}:host nb-icon{font-size:2.5rem}:host svg{width:2.5rem;height:2.5rem}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NbStatusService
  }], {
    toast: [{
      type: Input
    }],
    destroy: [{
      type: Output
    }],
    toastClick: [{
      type: Output
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    destroyByClick: [{
      type: HostBinding,
      args: ["class.destroy-by-click"]
    }],
    hasIcon: [{
      type: HostBinding,
      args: ["class.has-icon"]
    }],
    customIcon: [{
      type: HostBinding,
      args: ["class.custom-icon"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var voidState = style({
  transform: "translateX({{ direction }}110%)",
  height: 0,
  marginLeft: "0",
  marginRight: "0",
  marginTop: "0",
  marginBottom: "0"
});
var defaultOptions = {
  params: {
    direction: ""
  }
};
var NbToastrContainerComponent = class _NbToastrContainerComponent {
  constructor(layoutDirection, positionHelper) {
    this.layoutDirection = layoutDirection;
    this.positionHelper = positionHelper;
    this.destroy$ = new Subject();
    this.content = [];
  }
  ngOnInit() {
    this.layoutDirection.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe(() => this.onDirectionChange());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  onDirectionChange() {
    const direction = this.positionHelper.isRightPosition(this.position) ? "" : "-";
    this.fadeIn = {
      value: "",
      params: {
        direction
      }
    };
  }
  static {
    this.ɵfac = function NbToastrContainerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbToastrContainerComponent)(ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbPositionHelper));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbToastrContainerComponent,
      selectors: [["nb-toastr-container"]],
      viewQuery: function NbToastrContainerComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbToastComponent, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toasts = _t);
        }
      },
      inputs: {
        content: "content",
        context: "context",
        position: "position"
      },
      standalone: false,
      decls: 1,
      vars: 1,
      consts: [[3, "toast", 4, "ngFor", "ngForOf"], [3, "toast"]],
      template: function NbToastrContainerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbToastrContainerComponent_nb_toast_0_Template, 1, 2, "nb-toast", 0);
        }
        if (rf & 2) {
          ɵɵproperty("ngForOf", ctx.content);
        }
      },
      dependencies: [NgForOf, NbToastComponent],
      encapsulation: 2,
      data: {
        animation: [trigger("fadeIn", [transition(":enter", [voidState, animate(100)], defaultOptions), transition(":leave", [animate(100, voidState)], defaultOptions)])]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-toastr-container",
      template: `
    <nb-toast [@fadeIn]="fadeIn" *ngFor="let toast of content" [toast]="toast"></nb-toast>`,
      animations: [trigger("fadeIn", [transition(":enter", [voidState, animate(100)], defaultOptions), transition(":leave", [animate(100, voidState)], defaultOptions)])],
      standalone: false
    }]
  }], () => [{
    type: NbLayoutDirectionService
  }, {
    type: NbPositionHelper
  }], {
    content: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    toasts: [{
      type: ViewChildren,
      args: [NbToastComponent]
    }]
  });
})();
var NB_TOASTR_CONFIG = new InjectionToken("Default toastr options");
var NbToastrConfig = class {
  constructor(config) {
    this.position = NbGlobalLogicalPosition.TOP_END;
    this.status = "basic";
    this.duration = 3e3;
    this.destroyByClick = true;
    this.preventDuplicates = false;
    this.duplicatesBehaviour = "previous";
    this.limit = null;
    this.toastClass = "";
    this.hasIcon = true;
    this.icon = "email";
    this.icons = {
      danger: "flash-outline",
      success: "checkmark-outline",
      info: "question-mark-outline",
      warning: "alert-triangle-outline",
      primary: "email-outline",
      control: "email-outline",
      basic: "email-outline"
    };
    this.patchIcon(config);
    Object.assign(this, config);
  }
  patchIcon(config) {
    if (!("icon" in config)) {
      config.icon = {
        icon: this.icons[config.status] || this.icons.basic,
        pack: "nebular-essentials"
      };
    }
  }
};
var NbToastRef = class {
  constructor(toastContainer, toast) {
    this.toastContainer = toastContainer;
    this.toast = toast;
  }
  close() {
    this.toastContainer.destroy(this.toast);
  }
  onClose() {
    return this.toastInstance.destroy.asObservable();
  }
  onClick() {
    return this.toastInstance.toastClick.asObservable();
  }
};
var NbToastContainer = class {
  get nativeElement() {
    return this.containerRef.location.nativeElement;
  }
  constructor(position, containerRef, positionHelper) {
    this.position = position;
    this.containerRef = containerRef;
    this.positionHelper = positionHelper;
    this.toasts = [];
    this.toastDuplicateCompareFunc = (t1, t2) => {
      return t1.message === t2.message && t1.title === t2.title && t1.config.status === t2.config.status;
    };
  }
  attach(toast) {
    if (toast.config.preventDuplicates && this.isDuplicate(toast)) {
      return void 0;
    }
    this.removeToastIfLimitReached(toast);
    const toastComponent = this.attachToast(toast);
    if (toast.config.destroyByClick) {
      this.subscribeOnClick(toastComponent, toast);
    }
    if (toast.config.duration) {
      this.setDestroyTimeout(toast);
    }
    this.prevToast = toast;
    const toastRef = new NbToastRef(this, toast);
    toastRef.toastInstance = toastComponent;
    return toastRef;
  }
  destroy(toast) {
    if (this.prevToast === toast) {
      this.prevToast = null;
    }
    this.toasts = this.toasts.filter((t) => t !== toast);
    this.updateContainer();
  }
  isDuplicate(toast) {
    return toast.config.duplicatesBehaviour === "previous" ? this.isDuplicatePrevious(toast) : this.isDuplicateAmongAll(toast);
  }
  isDuplicatePrevious(toast) {
    return this.prevToast && this.toastDuplicateCompareFunc(this.prevToast, toast);
  }
  isDuplicateAmongAll(toast) {
    return this.toasts.some((t) => this.toastDuplicateCompareFunc(t, toast));
  }
  removeToastIfLimitReached(toast) {
    if (!toast.config.limit || this.toasts.length < toast.config.limit) {
      return;
    }
    if (this.positionHelper.isTopPosition(toast.config.position)) {
      this.toasts.pop();
    } else {
      this.toasts.shift();
    }
  }
  attachToast(toast) {
    if (this.positionHelper.isTopPosition(toast.config.position)) {
      return this.attachToTop(toast);
    } else {
      return this.attachToBottom(toast);
    }
  }
  attachToTop(toast) {
    this.toasts.unshift(toast);
    this.updateContainer();
    return this.containerRef.instance.toasts.first;
  }
  attachToBottom(toast) {
    this.toasts.push(toast);
    this.updateContainer();
    return this.containerRef.instance.toasts.last;
  }
  setDestroyTimeout(toast) {
    setTimeout(() => this.destroy(toast), toast.config.duration);
  }
  subscribeOnClick(toastComponent, toast) {
    toastComponent.toastClick.pipe(filter(() => toast.config.destroyByClick), takeUntil(toastComponent.destroy)).subscribe(() => this.destroy(toast));
  }
  updateContainer() {
    patch(this.containerRef, {
      content: this.toasts,
      position: this.position
    });
  }
};
var NbToastrContainerRegistry = class _NbToastrContainerRegistry {
  constructor(overlay, positionBuilder, positionHelper, cfr, document2) {
    this.overlay = overlay;
    this.positionBuilder = positionBuilder;
    this.positionHelper = positionHelper;
    this.cfr = cfr;
    this.document = document2;
    this.overlays = /* @__PURE__ */ new Map();
  }
  get(position) {
    const logicalPosition = this.positionHelper.toLogicalPosition(position);
    const overlayWithContainer = this.overlays.get(logicalPosition);
    if (!overlayWithContainer || !this.existsInDom(overlayWithContainer.toastrContainer)) {
      if (overlayWithContainer) {
        overlayWithContainer.overlayRef.dispose();
      }
      this.instantiateContainer(logicalPosition);
    }
    return this.overlays.get(logicalPosition).toastrContainer;
  }
  instantiateContainer(position) {
    const toastrOverlayWithContainer = this.createContainer(position);
    this.overlays.set(position, toastrOverlayWithContainer);
  }
  createContainer(position) {
    const positionStrategy = this.positionBuilder.global().position(position);
    const ref = this.overlay.create({
      positionStrategy
    });
    this.addClassToOverlayHost(ref);
    const containerRef = ref.attach(new NbComponentPortal(NbToastrContainerComponent, null, null, this.cfr));
    return {
      overlayRef: ref,
      toastrContainer: new NbToastContainer(position, containerRef, this.positionHelper)
    };
  }
  addClassToOverlayHost(overlayRef) {
    overlayRef.hostElement.classList.add("toastr-overlay-container");
  }
  existsInDom(toastContainer) {
    return this.document.body.contains(toastContainer.nativeElement);
  }
  static {
    this.ɵfac = function NbToastrContainerRegistry_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbToastrContainerRegistry)(ɵɵinject(NbOverlayService), ɵɵinject(NbPositionBuilderService), ɵɵinject(NbPositionHelper), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NB_DOCUMENT));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbToastrContainerRegistry,
      factory: _NbToastrContainerRegistry.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrContainerRegistry, [{
    type: Injectable
  }], () => [{
    type: NbOverlayService
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbPositionHelper
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbToastrService = class _NbToastrService {
  constructor(globalConfig, containerRegistry) {
    this.globalConfig = globalConfig;
    this.containerRegistry = containerRegistry;
  }
  /**
   * Shows toast with message, title and user config.
   * */
  show(message, title, userConfig) {
    const config = new NbToastrConfig(__spreadValues(__spreadValues({}, this.globalConfig), userConfig));
    const container = this.containerRegistry.get(config.position);
    const toast = {
      message,
      title,
      config
    };
    return container.attach(toast);
  }
  /**
   * Shows success toast with message, title and user config.
   * */
  success(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "success"
    }));
  }
  /**
   * Shows info toast with message, title and user config.
   * */
  info(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "info"
    }));
  }
  /**
   * Shows warning toast with message, title and user config.
   * */
  warning(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "warning"
    }));
  }
  /**
   * Shows primary toast with message, title and user config.
   * */
  primary(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "primary"
    }));
  }
  /**
   * Shows danger toast with message, title and user config.
   * */
  danger(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "danger"
    }));
  }
  /**
   * Shows default toast with message, title and user config.
   * */
  default(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "basic"
    }));
  }
  /**
   * Shows control toast with message, title and user config.
   * */
  control(message, title, config) {
    return this.default(message, title, __spreadProps(__spreadValues({}, config), {
      status: "control"
    }));
  }
  static {
    this.ɵfac = function NbToastrService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbToastrService)(ɵɵinject(NB_TOASTR_CONFIG), ɵɵinject(NbToastrContainerRegistry));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbToastrService,
      factory: _NbToastrService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrService, [{
    type: Injectable
  }], () => [{
    type: NbToastrConfig,
    decorators: [{
      type: Inject,
      args: [NB_TOASTR_CONFIG]
    }]
  }, {
    type: NbToastrContainerRegistry
  }], null);
})();
var NbToastrModule = class _NbToastrModule {
  static forRoot(toastrConfig = {}) {
    return {
      ngModule: _NbToastrModule,
      providers: [NbToastrService, NbToastrContainerRegistry, {
        provide: NB_TOASTR_CONFIG,
        useValue: toastrConfig
      }]
    };
  }
  static {
    this.ɵfac = function NbToastrModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbToastrModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbToastrModule,
      declarations: [NbToastrContainerComponent, NbToastComponent],
      imports: [NbSharedModule, NbOverlayModule, NbIconModule]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbOverlayModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule],
      declarations: [NbToastrContainerComponent, NbToastComponent]
    }]
  }], null, null);
})();
var NbToast = class {
};
var NbTooltipComponent = class _NbTooltipComponent {
  get binding() {
    return `${this.position} ${this.statusClass}`;
  }
  get show() {
    return true;
  }
  get statusClass() {
    if (this.context.status) {
      return this.statusService.getStatusClass(this.context.status);
    }
    return "";
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.position = NbPosition.TOP;
    this.context = {};
  }
  /**
   * The method is empty since we don't need to do anything additionally
   * render is handled by change detection
   */
  renderContent() {
  }
  static {
    this.ɵfac = function NbTooltipComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTooltipComponent)(ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTooltipComponent,
      selectors: [["nb-tooltip"]],
      hostVars: 3,
      hostBindings: function NbTooltipComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵsyntheticHostProperty("@showTooltip", ctx.show);
          ɵɵclassMap(ctx.binding);
        }
      },
      inputs: {
        content: "content",
        position: "position",
        context: "context"
      },
      standalone: false,
      decls: 4,
      vars: 2,
      consts: [[1, "arrow"], [1, "content"], [3, "config", 4, "ngIf"], [4, "ngIf"], [3, "config"]],
      template: function NbTooltipComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelement(0, "span", 0);
          ɵɵelementStart(1, "div", 1);
          ɵɵtemplate(2, NbTooltipComponent_nb_icon_2_Template, 1, 1, "nb-icon", 2)(3, NbTooltipComponent_span_3_Template, 2, 1, "span", 3);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance(2);
          ɵɵproperty("ngIf", ctx.context == null ? null : ctx.context.icon);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.content);
        }
      },
      dependencies: [NgIf, NbIconComponent],
      styles: ["[_nghost-%COMP%]{z-index:10000}[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;align-items:center}.right[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{flex-direction:row-reverse}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}.right[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{border-left:6px solid transparent;border-right:6px solid transparent}.bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px;left:calc(50% - 6px)}.bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}[dir=rtl]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}.start-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;bottom:6px;transform:rotate(90deg)}.start-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;top:6px;transform:rotate(90deg)}.top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}.top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-5px;transform:rotate(180deg)}[dir=ltr]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-5px;transform:rotate(180deg)}[dir=ltr]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}[dir=rtl]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}.end-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8.4px;bottom:6px;transform:rotate(270deg)}.end-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8.4px;top:6px;transform:rotate(270deg)}\n\n\n\n\n\n"],
      data: {
        animation: [trigger("showTooltip", [state("in", style({
          opacity: 1
        })), transition("void => *", [style({
          opacity: 0
        }), animate(100)]), transition("* => void", [animate(100, style({
          opacity: 0
        }))])])]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipComponent, [{
    type: Component,
    args: [{
      selector: "nb-tooltip",
      template: `
    <span class="arrow"></span>
    <div class="content">
      <nb-icon *ngIf="context?.icon" [config]="context.icon"></nb-icon>
      <span *ngIf="content">{{ content }}</span>
    </div>
  `,
      animations: [trigger("showTooltip", [state("in", style({
        opacity: 1
      })), transition("void => *", [style({
        opacity: 0
      }), animate(100)]), transition("* => void", [animate(100, style({
        opacity: 0
      }))])])],
      standalone: false,
      styles: [":host{z-index:10000}:host .content{display:flex;align-items:center}:host.right .content{flex-direction:row-reverse}:host .arrow{position:absolute;width:0;height:0}:host nb-icon+span{margin-left:.5rem}:host.right nb-icon+span{margin-right:.5rem}:host .arrow{border-left:6px solid transparent;border-right:6px solid transparent}:host(.bottom) .arrow{top:-6px;left:calc(50% - 6px)}:host(.bottom-start) .arrow{top:-6px}[dir=ltr] :host(.bottom-start) .arrow{right:6px}[dir=rtl] :host(.bottom-start) .arrow{left:6px}:host(.bottom-end) .arrow{top:-6px}[dir=ltr] :host(.bottom-end) .arrow{left:6px}[dir=rtl] :host(.bottom-end) .arrow{right:6px}:host(.left) .arrow,:host(.start) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.left) .arrow,[dir=ltr] :host(.start) .arrow{right:-8px;transform:rotate(90deg)}[dir=rtl] :host(.left) .arrow,[dir=rtl] :host(.start) .arrow{left:-8px;transform:rotate(270deg)}:host(.start-top) .arrow{right:-8px;bottom:6px;transform:rotate(90deg)}:host(.start-bottom) .arrow{right:-8px;top:6px;transform:rotate(90deg)}:host(.top) .arrow{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}:host(.top-start) .arrow{bottom:-5px;transform:rotate(180deg)}[dir=ltr] :host(.top-start) .arrow{right:6px}[dir=rtl] :host(.top-start) .arrow{left:6px}:host(.top-end) .arrow{bottom:-5px;transform:rotate(180deg)}[dir=ltr] :host(.top-end) .arrow{left:6px}[dir=rtl] :host(.top-end) .arrow{right:6px}:host(.right) .arrow,:host(.end) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.right) .arrow,[dir=ltr] :host(.end) .arrow{left:-8px;transform:rotate(270deg)}[dir=rtl] :host(.right) .arrow,[dir=rtl] :host(.end) .arrow{right:-8px;transform:rotate(90deg)}:host(.end-top) .arrow{left:-8.4px;bottom:6px;transform:rotate(270deg)}:host(.end-bottom) .arrow{left:-8.4px;top:6px;transform:rotate(270deg)}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    content: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    binding: [{
      type: HostBinding,
      args: ["class"]
    }],
    show: [{
      type: HostBinding,
      args: ["@showTooltip"]
    }],
    context: [{
      type: Input
    }]
  });
})();
var NbTooltipDirective = class _NbTooltipDirective {
  /**
   * Container position will change automatically based on this strategy if container can't fit view port.
   * Set this property to `noop` value if you want to disable automatic adjustment.
   * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
   */
  get adjustment() {
    return this._adjustment;
  }
  set adjustment(value) {
    this._adjustment = value;
  }
  get tooltipClass() {
    return this._tooltipClass;
  }
  set tooltipClass(value) {
    if (value !== this.tooltipClass) {
      this._tooltipClass = value;
      this.overlayConfig = {
        panelClass: this.tooltipClass
      };
    }
  }
  /**
   * Accepts icon name or icon config object
   * @param {string | NbIconConfig} icon name or config object
   */
  set icon(icon) {
    this.context = Object.assign(this.context, {
      icon
    });
  }
  /**
   *
   * @param {string} status
   */
  set status(status) {
    this.context = Object.assign(this.context, {
      status
    });
  }
  get isShown() {
    return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
  }
  constructor(hostRef, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.destroy$ = new Subject();
    this.tooltipComponent = NbTooltipComponent;
    this.context = {};
    this.position = NbPosition.TOP;
    this._adjustment = NbAdjustment.CLOCKWISE;
    this._tooltipClass = "";
    this.trigger = NbTrigger.HINT;
    this.offset = 8;
    this.disabled = false;
    this.nbTooltipShowStateChange = new EventEmitter();
    this.overlayConfig = {
      panelClass: this.tooltipClass
    };
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(this.tooltipComponent).offset(this.offset);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.dynamicOverlay.isShown.pipe(skip(1), takeUntil(this.destroy$)).subscribe((isShown) => this.nbTooltipShowStateChange.emit({
      isShown
    }));
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).disabled(this.disabled).adjustment(this.adjustment).content(this.content).context(this.context).overlayConfig(this.overlayConfig);
  }
  static {
    this.ɵfac = function NbTooltipDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTooltipDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbDynamicOverlayHandler));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTooltipDirective,
      selectors: [["", "nbTooltip", ""]],
      inputs: {
        content: [0, "nbTooltip", "content"],
        position: [0, "nbTooltipPlacement", "position"],
        adjustment: [0, "nbTooltipAdjustment", "adjustment"],
        tooltipClass: [0, "nbTooltipClass", "tooltipClass"],
        icon: [0, "nbTooltipIcon", "icon"],
        status: [0, "nbTooltipStatus", "status"],
        trigger: [0, "nbTooltipTrigger", "trigger"],
        offset: [0, "nbTooltipOffset", "offset"],
        disabled: [0, "nbTooltipDisabled", "disabled"]
      },
      outputs: {
        nbTooltipShowStateChange: "nbTooltipShowStateChange"
      },
      exportAs: ["nbTooltip"],
      standalone: false,
      features: [ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTooltip]",
      exportAs: "nbTooltip",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbDynamicOverlayHandler
  }], {
    content: [{
      type: Input,
      args: ["nbTooltip"]
    }],
    position: [{
      type: Input,
      args: ["nbTooltipPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbTooltipAdjustment"]
    }],
    tooltipClass: [{
      type: Input,
      args: ["nbTooltipClass"]
    }],
    icon: [{
      type: Input,
      args: ["nbTooltipIcon"]
    }],
    status: [{
      type: Input,
      args: ["nbTooltipStatus"]
    }],
    trigger: [{
      type: Input,
      args: ["nbTooltipTrigger"]
    }],
    offset: [{
      type: Input,
      args: ["nbTooltipOffset"]
    }],
    disabled: [{
      type: Input,
      args: ["nbTooltipDisabled"]
    }],
    nbTooltipShowStateChange: [{
      type: Output
    }]
  });
})();
var NbTooltipModule = class _NbTooltipModule {
  static {
    this.ɵfac = function NbTooltipModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTooltipModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbTooltipModule,
      declarations: [NbTooltipComponent, NbTooltipDirective],
      imports: [NbSharedModule, NbOverlayModule, NbIconModule],
      exports: [NbTooltipDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbOverlayModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule],
      declarations: [NbTooltipComponent, NbTooltipDirective],
      exports: [NbTooltipDirective]
    }]
  }], null, null);
})();
var NB_SELECT_INJECTION_TOKEN = new InjectionToken("NB_SELECT_INJECTION_TOKEN");
var lastOptionId = 0;
var NbOptionComponent = class _NbOptionComponent {
  get disabled() {
    return this._disabled || this.disabledByGroup;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  get click() {
    return this.click$.asObservable();
  }
  constructor(parent, elementRef, cd, zone, renderer) {
    this.elementRef = elementRef;
    this.cd = cd;
    this.zone = zone;
    this.renderer = renderer;
    this.disabledByGroup = false;
    this._disabled = false;
    this.selectionChange = new EventEmitter();
    this.click$ = new Subject();
    this.selected = false;
    this.alive = true;
    this.id = `nb-option-${lastOptionId++}`;
    this._active = false;
    this.parent = parent;
  }
  ngOnDestroy() {
    this.alive = false;
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  /**
   * Determines should we render checkbox.
   * */
  get withCheckbox() {
    return this.multiple && this.value != null;
  }
  get content() {
    return this.elementRef.nativeElement.textContent;
  }
  get hidden() {
    return this.elementRef.nativeElement.hidden;
  }
  // TODO: replace with isShowCheckbox property to control this behaviour outside, issues/1965
  get multiple() {
    return this.parent ? this.parent.multiple : false;
  }
  get selectedClass() {
    return this.selected;
  }
  get disabledAttribute() {
    return this.disabled ? "" : null;
  }
  get tabindex() {
    return "-1";
  }
  get activeClass() {
    return this._active;
  }
  onClick(event) {
    this.click$.next(this);
    event.preventDefault();
  }
  select() {
    this.setSelection(true);
  }
  deselect() {
    this.setSelection(false);
  }
  /**
   * Sets disabled by group state and marks component for check.
   */
  setDisabledByGroupState(disabled) {
    if (this.disabledByGroup !== disabled && this.alive) {
      this.disabledByGroup = disabled;
      this.cd.markForCheck();
    }
  }
  setSelection(selected) {
    if (this.alive && this.selected !== selected) {
      this.selected = selected;
      this.selectionChange.emit(this);
      this.cd.markForCheck();
    }
  }
  focus() {
    this.elementRef.nativeElement.focus();
  }
  getLabel() {
    return this.content;
  }
  setActiveStyles() {
    this._active = true;
    this.cd.markForCheck();
  }
  setInactiveStyles() {
    this._active = false;
    this.cd.markForCheck();
  }
  static {
    this.ɵfac = function NbOptionComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbOptionComponent)(ɵɵdirectiveInject(NB_SELECT_INJECTION_TOKEN, 8), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbOptionComponent,
      selectors: [["nb-option"]],
      hostVars: 9,
      hostBindings: function NbOptionComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbOptionComponent_click_HostBindingHandler($event) {
            return ctx.onClick($event);
          })("keydown.space", function NbOptionComponent_keydown_space_HostBindingHandler($event) {
            return ctx.onClick($event);
          })("keydown.enter", function NbOptionComponent_keydown_enter_HostBindingHandler($event) {
            return ctx.onClick($event);
          });
        }
        if (rf & 2) {
          ɵɵhostProperty("tabIndex", ctx.tabindex);
          ɵɵattribute("id", ctx.id)("disabled", ctx.disabledAttribute);
          ɵɵclassProp("multiple", ctx.multiple)("selected", ctx.selectedClass)("active", ctx.activeClass);
        }
      },
      inputs: {
        value: "value",
        disabled: "disabled"
      },
      outputs: {
        selectionChange: "selectionChange"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 2,
      vars: 1,
      consts: [["aria-hidden", "true", 3, "checked", "disabled", 4, "ngIf"], ["aria-hidden", "true", 3, "checked", "disabled"]],
      template: function NbOptionComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, NbOptionComponent_nb_checkbox_0_Template, 1, 2, "nb-checkbox", 0);
          ɵɵprojection(1);
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.withCheckbox);
        }
      },
      dependencies: [NgIf, NbCheckboxComponent],
      styles: ["[_nghost-%COMP%]{display:flex}[hidden][_nghost-%COMP%]{display:none}[_nghost-%COMP%]:hover{cursor:pointer}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{display:flex;pointer-events:none}[dir=ltr]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-right:.5rem}[dir=rtl]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-left:.5rem}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]     .label{padding:0}[disabled][_nghost-%COMP%]{pointer-events:none}.nb-transition[_nghost-%COMP%]{transition-duration:.15s;transition-property:background-color,color;transition-timing-function:ease-in}\n\n\n\n\n\n\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionComponent, [{
    type: Component,
    args: [{
      selector: "nb-option",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <nb-checkbox *ngIf="withCheckbox" [checked]="selected" [disabled]="disabled" aria-hidden="true"> </nb-checkbox>
    <ng-content></ng-content>
  `,
      standalone: false,
      styles: [":host{display:flex}:host[hidden]{display:none}:host:hover{cursor:pointer}:host nb-checkbox{display:flex;pointer-events:none}[dir=ltr] :host nb-checkbox{margin-right:.5rem}[dir=rtl] :host nb-checkbox{margin-left:.5rem}:host nb-checkbox ::ng-deep .label{padding:0}:host([disabled]){pointer-events:none}:host(.nb-transition){transition-duration:.15s;transition-property:background-color,color;transition-timing-function:ease-in}\n/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_SELECT_INJECTION_TOKEN]
    }]
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }], {
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    selectionChange: [{
      type: Output
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    multiple: [{
      type: HostBinding,
      args: ["class.multiple"]
    }],
    selectedClass: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    disabledAttribute: [{
      type: HostBinding,
      args: ["attr.disabled"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["tabIndex"]
    }],
    activeClass: [{
      type: HostBinding,
      args: ["class.active"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.space", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }]
  });
})();
var NbOptionListComponent = class _NbOptionListComponent {
  constructor() {
    this.size = "medium";
  }
  get positionTop() {
    return this.position === NbPosition.TOP;
  }
  get positionBottom() {
    return this.position === NbPosition.BOTTOM;
  }
  get sizeTiny() {
    return this.size === "tiny";
  }
  get sizeSmall() {
    return this.size === "small";
  }
  get sizeMedium() {
    return this.size === "medium";
  }
  get sizeLarge() {
    return this.size === "large";
  }
  get sizeGiant() {
    return this.size === "giant";
  }
  static {
    this.ɵfac = function NbOptionListComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbOptionListComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbOptionListComponent,
      selectors: [["nb-option-list"]],
      hostVars: 14,
      hostBindings: function NbOptionListComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("position-top", ctx.positionTop)("position-bottom", ctx.positionBottom)("size-tiny", ctx.sizeTiny)("size-small", ctx.sizeSmall)("size-medium", ctx.sizeMedium)("size-large", ctx.sizeLarge)("size-giant", ctx.sizeGiant);
        }
      },
      inputs: {
        size: "size",
        position: "position"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 2,
      vars: 0,
      consts: [[1, "option-list"]],
      template: function NbOptionListComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵelementStart(0, "ul", 0);
          ɵɵprojection(1);
          ɵɵelementEnd();
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionListComponent, [{
    type: Component,
    args: [{
      selector: "nb-option-list",
      template: `
    <ul class="option-list">
      <ng-content></ng-content>
    </ul>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], null, {
    size: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    positionTop: [{
      type: HostBinding,
      args: ["class.position-top"]
    }],
    positionBottom: [{
      type: HostBinding,
      args: ["class.position-bottom"]
    }],
    sizeTiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    sizeSmall: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    sizeMedium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    sizeLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    sizeGiant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var NbSelectLabelComponent = class _NbSelectLabelComponent {
  static {
    this.ɵfac = function NbSelectLabelComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSelectLabelComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbSelectLabelComponent,
      selectors: [["nb-select-label"]],
      standalone: false,
      ngContentSelectors: _c03,
      decls: 1,
      vars: 0,
      template: function NbSelectLabelComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵprojection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectLabelComponent, [{
    type: Component,
    args: [{
      selector: "nb-select-label",
      template: "<ng-content></ng-content>",
      standalone: false
    }]
  }], null, null);
})();
function nbSelectFormFieldControlConfigFactory() {
  const config = new NbFormFieldControlConfig();
  config.supportsSuffix = false;
  return config;
}
var NbSelectComponent = class _NbSelectComponent {
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  /**
   * Adds `outline` styles
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Adds `filled` styles
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Adds `hero` styles
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  /**
   * Disables the select
   */
  get disabled() {
    return !!this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * A function to compare option value with selected value.
   * By default, values are compared with strict equality (`===`).
   */
  get compareWith() {
    return this._compareWith;
  }
  set compareWith(fn) {
    if (typeof fn !== "function") {
      return;
    }
    this._compareWith = fn;
    if (this.selectionModel.length && this.canSelectValue()) {
      this.setSelection(this.selected);
    }
  }
  /**
   * Accepts selected item or array of selected items.
   * */
  set selected(value) {
    this.writeValue(value);
  }
  get selected() {
    return this.multiple ? this.selectionModel.map((o) => o.value) : this.selectionModel[0].value;
  }
  /**
   * Gives capability just write `multiple` over the element.
   * */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Determines is select opened.
   * */
  get isOpen() {
    return this.ref && this.ref.hasAttached();
  }
  constructor(document2, overlay, hostRef, positionBuilder, triggerStrategyBuilder, cd, focusKeyManagerFactoryService, focusMonitor, renderer, zone, statusService) {
    this.document = document2;
    this.overlay = overlay;
    this.hostRef = hostRef;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.cd = cd;
    this.focusKeyManagerFactoryService = focusKeyManagerFactoryService;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "outline";
    this._fullWidth = false;
    this.placeholder = "";
    this._compareWith = (v1, v2) => v1 === v2;
    this._multiple = false;
    this.optionsOverlayOffset = 8;
    this.scrollStrategy = "block";
    this.selectedChange = new EventEmitter();
    this.selectionModel = [];
    this.overlayPosition = "";
    this.alive = true;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.size);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(this.disabled);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
  }
  /**
   * Determines is select hidden.
   * */
  get isHidden() {
    return !this.isOpen;
  }
  /**
   * Returns width of the select button.
   * */
  get hostWidth() {
    return this.button.nativeElement.getBoundingClientRect().width;
  }
  get selectButtonClasses() {
    const classes = [];
    if (!this.selectionModel.length) {
      classes.push("placeholder");
    }
    if (!this.selectionModel.length && !this.placeholder) {
      classes.push("empty");
    }
    if (this.isOpen) {
      classes.push(this.overlayPosition);
    }
    return classes;
  }
  /**
   * Content rendered in the label.
   * */
  get selectionView() {
    if (this.selectionModel.length > 1) {
      return this.selectionModel.map((option) => option.content).join(", ");
    }
    return this.selectionModel[0].content;
  }
  ngOnChanges({
    disabled,
    status,
    size,
    fullWidth
  }) {
    if (disabled) {
      this.disabled$.next(disabled.currentValue);
    }
    if (status) {
      this.status$.next(status.currentValue);
    }
    if (size) {
      this.size$.next(size.currentValue);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngAfterContentInit() {
    this.options.changes.pipe(
      startWith(this.options),
      filter(() => this.queue != null && this.canSelectValue()),
      // Call 'writeValue' when current change detection run is finished.
      // When writing is finished, change detection starts again, since
      // microtasks queue is empty.
      // Prevents ExpressionChangedAfterItHasBeenCheckedError.
      switchMap((options) => from(Promise.resolve(options))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.writeValue(this.queue));
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnButtonFocus();
    this.subscribeOnTriggers();
    this.subscribeOnOptionClick();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.alive = false;
    this.destroy$.next();
    this.destroy$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  show() {
    if (this.shouldShow()) {
      this.attachToOverlay();
      this.positionStrategy.positionChange.pipe(take(1), takeUntil(this.destroy$)).subscribe(() => {
        this.setActiveOption();
      });
      this.cd.markForCheck();
    }
  }
  hide() {
    if (this.isOpen) {
      this.ref.detach();
      this.cd.markForCheck();
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd.markForCheck();
  }
  writeValue(value) {
    if (!this.alive) {
      return;
    }
    if (this.canSelectValue()) {
      this.setSelection(value);
      if (this.selectionModel.length) {
        this.queue = null;
      }
    } else {
      this.queue = value;
    }
  }
  /**
   * Selects option or clear all selected options if value is null.
   * */
  handleOptionClick(option) {
    this.queue = null;
    if (option.value == null) {
      this.reset();
    } else {
      this.selectOption(option);
    }
    this.cd.markForCheck();
  }
  /**
   * Deselect all selected options.
   * */
  reset() {
    this.selectionModel.forEach((option) => option.deselect());
    this.selectionModel = [];
    this.hide();
    this.button.nativeElement.focus();
    this.emitSelected(this.multiple ? [] : null);
  }
  /**
   * Determines how to select option as multiple or single.
   * */
  selectOption(option) {
    if (this.multiple) {
      this.handleMultipleSelect(option);
    } else {
      this.handleSingleSelect(option);
    }
  }
  /**
   * Select single option.
   * */
  handleSingleSelect(option) {
    const selected = this.selectionModel.pop();
    if (selected && !this._compareWith(selected.value, option.value)) {
      selected.deselect();
    }
    this.selectionModel = [option];
    option.select();
    this.hide();
    this.button.nativeElement.focus();
    this.emitSelected(option.value);
  }
  /**
   * Select for multiple options.
   * */
  handleMultipleSelect(option) {
    if (option.selected) {
      this.selectionModel = this.selectionModel.filter((s) => !this._compareWith(s.value, option.value));
      option.deselect();
    } else {
      this.selectionModel.push(option);
      option.select();
    }
    this.emitSelected(this.selectionModel.map((opt) => opt.value));
  }
  attachToOverlay() {
    if (!this.ref) {
      this.createOverlay();
      this.subscribeOnPositionChange();
      this.createKeyManager();
      this.subscribeOnOverlayKeys();
    }
    this.ref.attach(this.portal);
  }
  setActiveOption() {
    if (this.selectionModel.length) {
      this.keyManager.setActiveItem(this.selectionModel[0]);
    } else {
      this.keyManager.setFirstItemActive();
    }
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.positionStrategy = this.createPositionStrategy();
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy,
      panelClass: this.optionsPanelClass
    });
  }
  createKeyManager() {
    this.keyManager = this.focusKeyManagerFactoryService.create(this.options).withTypeAhead(200);
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.button).position(NbPosition.BOTTOM).offset(this.optionsOverlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.CLICK).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(($event) => {
      this.hide();
      if (!this.isClickedWithinComponent($event)) {
        this.onTouched();
      }
    });
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => {
      this.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  subscribeOnOptionClick() {
    this.options.changes.pipe(startWith(this.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleOptionClick(clickedOption));
  }
  subscribeOnOverlayKeys() {
    this.ref.keydownEvents().pipe(filter(() => this.isOpen), takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE) {
        this.button.nativeElement.focus();
        this.hide();
      } else {
        this.keyManager.onKeydown(event);
      }
    });
    this.keyManager.tabOut.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.hide();
      this.onTouched();
    });
  }
  subscribeOnButtonFocus() {
    this.focusMonitor.monitor(this.button).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.button)), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  getContainer() {
    return this.ref && this.ref.hasAttached() && {
      location: {
        nativeElement: this.ref.overlayElement
      }
    };
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.onChange(selected);
    this.selectedChange.emit(selected);
  }
  /**
   * Set selected value in model.
   * */
  setSelection(value) {
    const isResetValue = value == null;
    let safeValue = value;
    if (this.multiple) {
      safeValue = value ?? [];
    }
    const isArray = Array.isArray(safeValue);
    if (this.multiple && !isArray && !isResetValue) {
      throw new Error("Can't assign single value if select is marked as multiple");
    }
    if (!this.multiple && isArray) {
      throw new Error("Can't assign array if select is not marked as multiple");
    }
    const previouslySelectedOptions = this.selectionModel;
    this.selectionModel = [];
    if (this.multiple) {
      safeValue.forEach((option) => this.selectValue(option));
    } else {
      this.selectValue(safeValue);
    }
    previouslySelectedOptions.filter((option) => !this.selectionModel.includes(option)).forEach((option) => option.deselect());
    this.cd.markForCheck();
  }
  /**
   * Selects value.
   * */
  selectValue(value) {
    if (value == null) {
      return;
    }
    const corresponding = this.options.find((option) => this._compareWith(option.value, value));
    if (corresponding) {
      corresponding.select();
      this.selectionModel.push(corresponding);
    }
  }
  shouldShow() {
    return this.isHidden && this.options?.length > 0;
  }
  /**
   * Sets touched if focus moved outside of button and overlay,
   * ignoring the case when focus moved to options overlay.
   */
  trySetTouched() {
    if (this.isHidden) {
      this.onTouched();
    }
  }
  isClickedWithinComponent($event) {
    return this.hostRef.nativeElement === $event.target || this.hostRef.nativeElement.contains($event.target);
  }
  canSelectValue() {
    return !!(this.options && this.options.length);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  static {
    this.ɵfac = function NbSelectComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSelectComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbFocusKeyManagerFactoryService), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbSelectComponent,
      selectors: [["nb-select"]],
      contentQueries: function NbSelectComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbSelectLabelComponent, 5);
          ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.customLabel = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
        }
      },
      viewQuery: function NbSelectComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbPortalDirective, 5);
          ɵɵviewQuery(_c40, 5, ElementRef);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.button = _t.first);
        }
      },
      hostVars: 42,
      hostBindings: function NbSelectComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("appearance-outline", ctx.outline)("appearance-filled", ctx.filled)("appearance-hero", ctx.hero)("full-width", ctx.fullWidth)("open", ctx.isOpen)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound);
        }
      },
      inputs: {
        size: "size",
        status: "status",
        shape: "shape",
        appearance: "appearance",
        optionsListClass: "optionsListClass",
        optionsPanelClass: "optionsPanelClass",
        optionsWidth: "optionsWidth",
        outline: "outline",
        filled: "filled",
        hero: "hero",
        disabled: "disabled",
        fullWidth: "fullWidth",
        placeholder: "placeholder",
        compareWith: "compareWith",
        selected: "selected",
        multiple: "multiple",
        optionsOverlayOffset: "optionsOverlayOffset",
        scrollStrategy: "scrollStrategy"
      },
      outputs: {
        selectedChange: "selectedChange"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _NbSelectComponent),
        multi: true
      }, {
        provide: NB_SELECT_INJECTION_TOKEN,
        useExisting: _NbSelectComponent
      }, {
        provide: NbFormFieldControl,
        useExisting: _NbSelectComponent
      }, {
        provide: NbFormFieldControlConfig,
        useFactory: nbSelectFormFieldControlConfigFactory
      }]), ɵɵNgOnChangesFeature],
      ngContentSelectors: _c42,
      decls: 8,
      vars: 4,
      consts: [["selectButton", ""], ["placeholderTemplate", ""], ["defaultSelectionTemplate", ""], ["type", "button", 1, "select-button", 3, "blur", "keydown.arrowDown", "keydown.arrowUp", "disabled", "ngClass"], [3, "click"], [4, "ngIf", "ngIfElse"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"], [3, "size", "position", "width", "ngClass", 4, "nbPortal"], [3, "size", "position", "ngClass"]],
      template: function NbSelectComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵprojectionDef(_c41);
          ɵɵelementStart(0, "button", 3, 0);
          ɵɵlistener("blur", function NbSelectComponent_Template_button_blur_0_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.trySetTouched());
          })("keydown.arrowDown", function NbSelectComponent_Template_button_keydown_arrowDown_0_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.show());
          })("keydown.arrowUp", function NbSelectComponent_Template_button_keydown_arrowUp_0_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.show());
          });
          ɵɵelementStart(2, "span", 4);
          ɵɵlistener("click", function NbSelectComponent_Template_span_click_2_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.disabled && $event.stopPropagation());
          });
          ɵɵtemplate(3, NbSelectComponent_ng_container_3_Template, 4, 2, "ng-container", 5)(4, NbSelectComponent_ng_template_4_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
          ɵɵelementEnd();
          ɵɵelementStart(6, "nb-icon", 6);
          ɵɵlistener("click", function NbSelectComponent_Template_nb_icon_click_6_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.disabled && $event.stopPropagation());
          });
          ɵɵelementEnd()();
          ɵɵtemplate(7, NbSelectComponent_nb_option_list_7_Template, 2, 5, "nb-option-list", 7);
        }
        if (rf & 2) {
          const placeholderTemplate_r4 = ɵɵreference(5);
          ɵɵproperty("disabled", ctx.disabled)("ngClass", ctx.selectButtonClasses);
          ɵɵadvance(3);
          ɵɵproperty("ngIf", ctx.selectionModel.length)("ngIfElse", placeholderTemplate_r4);
        }
      },
      dependencies: [NgClass, NgIf, NbPortalDirective, NbIconComponent, NbOptionListComponent],
      styles: ["[_nghost-%COMP%]{display:inline-block;max-width:100%}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:left}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.2em}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:right}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.2em}.full-width[_nghost-%COMP%]{width:100%}.nb-transition[_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button[_ngcontent-%COMP%]{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon[_ngcontent-%COMP%]{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.5rem}[dir=rtl][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.5rem}.open[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{transform:translateY(-50%) rotate(180deg)}\n\n\n\n\n\n\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectComponent, [{
    type: Component,
    args: [{
      selector: "nb-select",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbSelectComponent),
        multi: true
      }, {
        provide: NB_SELECT_INJECTION_TOKEN,
        useExisting: NbSelectComponent
      }, {
        provide: NbFormFieldControl,
        useExisting: NbSelectComponent
      }, {
        provide: NbFormFieldControlConfig,
        useFactory: nbSelectFormFieldControlConfigFactory
      }],
      standalone: false,
      template: '<button\n  [disabled]="disabled"\n  [ngClass]="selectButtonClasses"\n  (blur)="trySetTouched()"\n  (keydown.arrowDown)="show()"\n  (keydown.arrowUp)="show()"\n  class="select-button"\n  type="button"\n  #selectButton\n>\n  <span (click)="disabled && $event.stopPropagation()">\n    <ng-container *ngIf="selectionModel.length; else placeholderTemplate">\n      <ng-container *ngIf="customLabel; else defaultSelectionTemplate">\n        <ng-content select="nb-select-label"></ng-content>\n      </ng-container>\n\n      <ng-template #defaultSelectionTemplate>{{ selectionView }}</ng-template>\n    </ng-container>\n\n    <ng-template #placeholderTemplate>{{ placeholder }}</ng-template>\n  </span>\n\n  <nb-icon\n    icon="chevron-down-outline"\n    pack="nebular-essentials"\n    (click)="disabled && $event.stopPropagation()"\n    aria-hidden="true"\n  >\n  </nb-icon>\n</button>\n\n<nb-option-list\n  *nbPortal\n  [size]="size"\n  [position]="overlayPosition"\n  [style.width.px]="optionsWidth"\n  [ngClass]="optionsListClass"\n>\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: [":host{display:inline-block;max-width:100%}[dir=ltr] :host .select-button{text-align:left}[dir=ltr] :host .select-button nb-icon{right:.2em}[dir=rtl] :host .select-button{text-align:right}[dir=rtl] :host .select-button nb-icon{left:.2em}:host(.full-width){width:100%}:host(.nb-transition) .select-button{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr] nb-icon{right:.5rem}[dir=rtl] nb-icon{left:.5rem}:host(.open) nb-icon{transform:translateY(-50%) rotate(180deg)}\n/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbOverlayService
  }, {
    type: ElementRef
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbFocusKeyManagerFactoryService
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    disabled: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    placeholder: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    optionsOverlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    selectedChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    customLabel: [{
      type: ContentChild,
      args: [NbSelectLabelComponent]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    button: [{
      type: ViewChild,
      args: ["selectButton", {
        read: ElementRef
      }]
    }],
    isOpen: [{
      type: HostBinding,
      args: ["class.open"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }]
  });
})();
var NbOptionGroupComponent = class _NbOptionGroupComponent {
  constructor() {
    this.destroy$ = new Subject();
    this._disabled = false;
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
    if (this.options) {
      this.updateOptionsDisabledState();
    }
  }
  get disabledAttribute() {
    return this.disabled ? "" : null;
  }
  ngAfterContentInit() {
    if (this.options.length) {
      this.asyncUpdateOptionsDisabledState();
    }
    this.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.asyncUpdateOptionsDisabledState());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Sets disabled state for each option to current group disabled state.
   */
  updateOptionsDisabledState() {
    this.options.forEach((option) => option.setDisabledByGroupState(this.disabled));
  }
  /**
   * Updates options disabled state after promise resolution.
   * This way change detection will be triggered after options state updated.
   * Use this method when updating options during change detection run (e.g. QueryList.changes, lifecycle hooks).
   */
  asyncUpdateOptionsDisabledState() {
    from(Promise.resolve()).pipe(takeUntil(this.destroy$)).subscribe(() => this.updateOptionsDisabledState());
  }
  static {
    this.ɵfac = function NbOptionGroupComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbOptionGroupComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbOptionGroupComponent,
      selectors: [["nb-option-group"]],
      contentQueries: function NbOptionGroupComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
        }
      },
      hostVars: 1,
      hostBindings: function NbOptionGroupComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵattribute("disabled", ctx.disabledAttribute);
        }
      },
      inputs: {
        title: "title",
        disabled: "disabled"
      },
      standalone: false,
      ngContentSelectors: _c44,
      decls: 3,
      vars: 1,
      consts: [[1, "option-group-title"]],
      template: function NbOptionGroupComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c43);
          ɵɵelementStart(0, "span", 0);
          ɵɵtext(1);
          ɵɵelementEnd();
          ɵɵprojection(2);
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵtextInterpolate(ctx.title);
        }
      },
      styles: ["[_nghost-%COMP%]{display:block}.option-group-title[_ngcontent-%COMP%]{display:block}\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-option-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <span class="option-group-title">{{ title }}</span>
    <ng-content select="nb-option, ng-container"></ng-content>
  `,
      standalone: false,
      styles: [":host{display:block}.option-group-title{display:block}\n/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], null, {
    title: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    disabledAttribute: [{
      type: HostBinding,
      args: ["attr.disabled"]
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }]
  });
})();
var NB_OPTION_LIST_COMPONENTS = [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent];
var NbOptionModule = class _NbOptionModule {
  static {
    this.ɵfac = function NbOptionModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbOptionModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbOptionModule,
      declarations: [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent],
      imports: [CommonModule, NbCheckboxModule],
      exports: [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CommonModule, NbCheckboxModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionModule, [{
    type: NgModule,
    args: [{
      declarations: [...NB_OPTION_LIST_COMPONENTS],
      imports: [CommonModule, NbCheckboxModule],
      exports: [...NB_OPTION_LIST_COMPONENTS]
    }]
  }], null, null);
})();
var NB_SELECT_COMPONENTS$1 = [NbSelectComponent, NbSelectLabelComponent];
var NbSelectModule = class _NbSelectModule {
  static {
    this.ɵfac = function NbSelectModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSelectModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbSelectModule,
      declarations: [NbSelectComponent, NbSelectLabelComponent],
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule],
      exports: [NbSelectComponent, NbSelectLabelComponent, NbOptionModule]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbOptionModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule],
      exports: [...NB_SELECT_COMPONENTS$1, NbOptionModule],
      declarations: [...NB_SELECT_COMPONENTS$1]
    }]
  }], null, null);
})();
var NbPrefixDirective = class _NbPrefixDirective {
  static {
    this.ɵfac = function NbPrefixDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbPrefixDirective)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbPrefixDirective,
      selectors: [["", "nbPrefix", ""]],
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPrefixDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPrefix]",
      standalone: false
    }]
  }], null, null);
})();
var NbSuffixDirective = class _NbSuffixDirective {
  static {
    this.ɵfac = function NbSuffixDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSuffixDirective)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbSuffixDirective,
      selectors: [["", "nbSuffix", ""]],
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSuffixDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSuffix]",
      standalone: false
    }]
  }], null, null);
})();
function throwFormControlElementNotFound() {
  throw new Error(`NbFormFieldComponent must contain [nbInput]`);
}
var NbFormFieldComponent = class _NbFormFieldComponent {
  constructor(cd, zone, elementRef, renderer) {
    this.cd = cd;
    this.zone = zone;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.destroy$ = new Subject();
    this.formControlState$ = new ReplaySubject(1);
    this.prefixClasses$ = this.formControlState$.pipe(map((s) => this.getAddonClasses("prefix", s)));
    this.suffixClasses$ = this.formControlState$.pipe(map((s) => this.getAddonClasses("suffix", s)));
  }
  ngAfterContentChecked() {
    if (!this.formControl) {
      throwFormControlElementNotFound();
    }
  }
  ngAfterContentInit() {
    this.subscribeToFormControlStateChange();
    this.subscribeToAddonChange();
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  shouldShowPrefix() {
    return this.getFormControlConfig().supportsPrefix && !!this.prefix.length;
  }
  shouldShowSuffix() {
    return this.getFormControlConfig().supportsSuffix && !!this.suffix.length;
  }
  subscribeToFormControlStateChange() {
    const {
      disabled$,
      focused$,
      size$,
      status$,
      fullWidth$
    } = this.formControl;
    combineLatest([disabled$, focused$, size$, status$, fullWidth$]).pipe(map(([disabled, focused, size, status, fullWidth]) => ({
      disabled,
      focused,
      size,
      status,
      fullWidth
    })), distinctUntilChanged((oldState, state2) => this.isStatesEqual(oldState, state2)), tap(({
      size,
      fullWidth
    }) => {
      const formFieldClasses = [`nb-form-field-size-${size}`];
      if (!fullWidth) {
        formFieldClasses.push("nb-form-field-limited-width");
      }
      this.formFieldClasses = formFieldClasses.join(" ");
    }), takeUntil(this.destroy$)).subscribe(this.formControlState$);
  }
  subscribeToAddonChange() {
    merge(this.prefix.changes, this.suffix.changes).pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  getAddonClasses(addon, state2) {
    const classes = ["nb-form-field-addon", `nb-form-field-${addon}-${state2.size}`];
    if (state2.disabled) {
      classes.push(`nb-form-field-addon-disabled`);
    } else if (state2.focused) {
      classes.push(`nb-form-field-addon-${state2.status}-highlight`);
    } else {
      classes.push(`nb-form-field-addon-${state2.status}`);
    }
    return classes;
  }
  getFormControlConfig() {
    return this.formControlConfig || new NbFormFieldControlConfig();
  }
  isStatesEqual(oldState, state2) {
    return oldState.status === state2.status && oldState.disabled === state2.disabled && oldState.focused === state2.focused && oldState.fullWidth === state2.fullWidth && oldState.size === state2.size;
  }
  static {
    this.ɵfac = function NbFormFieldComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbFormFieldComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbFormFieldComponent,
      selectors: [["nb-form-field"]],
      contentQueries: function NbFormFieldComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbFormFieldControl, 5);
          ɵɵcontentQuery(dirIndex, NbFormFieldControlConfig, 5);
          ɵɵcontentQuery(dirIndex, NbPrefixDirective, 5);
          ɵɵcontentQuery(dirIndex, NbSuffixDirective, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.formControl = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.formControlConfig = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefix = _t);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffix = _t);
        }
      },
      hostVars: 2,
      hostBindings: function NbFormFieldComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.formFieldClasses);
        }
      },
      standalone: false,
      ngContentSelectors: _c46,
      decls: 4,
      vars: 6,
      consts: [[3, "ngClass", 4, "ngIf"], [1, "nb-form-control-container"], [3, "ngClass"]],
      template: function NbFormFieldComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c45);
          ɵɵtemplate(0, NbFormFieldComponent_div_0_Template, 3, 3, "div", 0);
          ɵɵelementStart(1, "div", 1);
          ɵɵprojection(2);
          ɵɵelementEnd();
          ɵɵtemplate(3, NbFormFieldComponent_div_3_Template, 3, 3, "div", 0);
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.shouldShowPrefix());
          ɵɵadvance();
          ɵɵclassProp("nb-form-field-control-with-prefix", ctx.shouldShowPrefix())("nb-form-field-control-with-suffix", ctx.shouldShowSuffix());
          ɵɵadvance(2);
          ɵɵproperty("ngIf", ctx.shouldShowSuffix());
        }
      },
      dependencies: [NgClass, NgIf, AsyncPipe],
      styles: ["[_nghost-%COMP%]{display:flex;align-items:center}[hidden][_nghost-%COMP%]{display:none}.nb-form-control-container[_ngcontent-%COMP%]{width:100%}\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldComponent, [{
    type: Component,
    args: [{
      selector: "nb-form-field",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div *ngIf="shouldShowPrefix()" [ngClass]="prefixClasses$ | async">\n  <ng-content select="[nbPrefix]"></ng-content>\n</div>\n\n<div class="nb-form-control-container"\n     [class.nb-form-field-control-with-prefix]="shouldShowPrefix()"\n     [class.nb-form-field-control-with-suffix]="shouldShowSuffix()">\n  <ng-content></ng-content>\n</div>\n\n<div *ngIf="shouldShowSuffix()" [ngClass]="suffixClasses$ | async">\n  <ng-content select="[nbSuffix]"></ng-content>\n</div>\n',
      styles: [":host{display:flex;align-items:center}:host[hidden]{display:none}.nb-form-control-container{width:100%}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    prefix: [{
      type: ContentChildren,
      args: [NbPrefixDirective, {
        descendants: true
      }]
    }],
    suffix: [{
      type: ContentChildren,
      args: [NbSuffixDirective, {
        descendants: true
      }]
    }],
    formControl: [{
      type: ContentChild,
      args: [NbFormFieldControl, {
        static: false
      }]
    }],
    formControlConfig: [{
      type: ContentChild,
      args: [NbFormFieldControlConfig, {
        static: false
      }]
    }],
    formFieldClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NbSelectWithAutocompleteComponent = class _NbSelectWithAutocompleteComponent {
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  /**
   * Adds `outline` styles
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Adds `filled` styles
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Adds `hero` styles
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  /**
   * Disables the select
   */
  get disabled() {
    return !!this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * A function to compare option value with selected value.
   * By default, values are compared with strict equality (`===`).
   */
  get compareWith() {
    return this._compareWith;
  }
  set compareWith(fn) {
    if (typeof fn !== "function") {
      return;
    }
    this._compareWith = fn;
    if (this.selectionModel.length && this.canSelectValue()) {
      this.setSelection(this.selected);
    }
  }
  /**
   * Accepts selected item or array of selected items.
   * */
  set selected(value) {
    this.writeValue(value);
  }
  get selected() {
    return this.multiple ? this.selectionModel.map((o) => o.value) : this.selectionModel[0].value;
  }
  /**
   * Gives capability just write `multiple` over the element.
   * */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
    this.updatePositionStrategy();
    this.updateCurrentKeyManager();
  }
  /**
   * Experimental input.
   * Could be changed without any prior notice.
   * Use at your own risk.
   *
   * It replaces the button with input when the select is opened.
   * That replacement provides a very basic API to implement options filtering functionality.
   * Filtering itself isn't implemented inside select.
   * So it should be implemented by the user.
   */
  set withOptionsAutocomplete(value) {
    this._withOptionsAutocomplete = convertToBoolProperty(value);
    this.updatePositionStrategy();
    this.updateCurrentKeyManager();
    if (!value) {
      this.resetAutocompleteInput();
    }
  }
  get withOptionsAutocomplete() {
    return this._withOptionsAutocomplete;
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Determines is select opened.
   * */
  get isOpen() {
    return this.ref && this.ref.hasAttached();
  }
  get isOptionsAutocompleteAllowed() {
    return this.withOptionsAutocomplete;
  }
  get isOptionsAutocompleteInputShown() {
    return this.isOptionsAutocompleteAllowed && this.isOpen;
  }
  constructor(document2, overlay, hostRef, positionBuilder, triggerStrategyBuilder, cd, focusKeyManagerFactoryService, focusMonitor, renderer, zone, statusService, activeDescendantKeyManagerFactoryService) {
    this.document = document2;
    this.overlay = overlay;
    this.hostRef = hostRef;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.cd = cd;
    this.focusKeyManagerFactoryService = focusKeyManagerFactoryService;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.activeDescendantKeyManagerFactoryService = activeDescendantKeyManagerFactoryService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "outline";
    this._fullWidth = false;
    this.placeholder = "";
    this._compareWith = (v1, v2) => v1 === v2;
    this._multiple = false;
    this.optionsOverlayOffset = 8;
    this.scrollStrategy = "block";
    this._withOptionsAutocomplete = false;
    this.selectedChange = new EventEmitter();
    this.selectOpen = new EventEmitter();
    this.selectClose = new EventEmitter();
    this.optionsAutocompleteInputChange = new EventEmitter();
    this.selectionModel = [];
    this.positionStrategy$ = new BehaviorSubject(void 0);
    this.overlayPosition = "";
    this.alive = true;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.size);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(this.disabled);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
    this.lastShownButtonWidth = void 0;
  }
  /**
   * Determines is select hidden.
   * */
  get isHidden() {
    return !this.isOpen;
  }
  /**
   * Returns width of the select button.
   * */
  get hostWidth() {
    if (this.isOptionsAutocompleteInputShown) {
      return this.optionsAutocompleteInput.nativeElement.getBoundingClientRect().width;
    }
    return this.button.nativeElement.getBoundingClientRect().width;
  }
  get selectButtonClasses() {
    const classes = [];
    if (!this.selectionModel.length) {
      classes.push("placeholder");
    }
    if (!this.selectionModel.length && !this.placeholder) {
      classes.push("empty");
    }
    if (this.isOpen) {
      classes.push(this.overlayPosition);
    }
    return classes;
  }
  /**
   * Content rendered in the label.
   * */
  get selectionView() {
    if (this.isOptionsAutocompleteInputShown && this.multiple) {
      return "";
    }
    if (this.selectionModel.length > 1) {
      return this.selectionModel.map((option) => option.content).join(", ");
    }
    return this.selectionModel[0]?.content?.trim() ?? "";
  }
  ngOnChanges({
    disabled,
    status,
    size,
    fullWidth
  }) {
    if (disabled) {
      this.disabled$.next(disabled.currentValue);
    }
    if (status) {
      this.status$.next(status.currentValue);
    }
    if (size) {
      this.size$.next(size.currentValue);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngAfterContentInit() {
    this.options.changes.pipe(
      startWith(this.options),
      filter(() => this.queue != null && this.canSelectValue()),
      // Call 'writeValue' when current change detection run is finished.
      // When writing is finished, change detection starts again, since
      // microtasks queue is empty.
      // Prevents ExpressionChangedAfterItHasBeenCheckedError.
      switchMap((options) => from(Promise.resolve(options))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.writeValue(this.queue));
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnButtonFocus();
    this.subscribeOnTriggers();
    this.subscribeOnOptionClick();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.alive = false;
    this.destroy$.next();
    this.destroy$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  onAutocompleteInputChange(event) {
    this.optionsAutocompleteInputChange.emit(event.target.value);
  }
  show() {
    if (this.shouldShow()) {
      this.lastShownButtonWidth = this.hostWidth;
      this.attachToOverlay();
      this.positionStrategy$.pipe(switchMap((positionStrategy) => positionStrategy.positionChange ?? EMPTY), take(1), takeUntil(this.destroy$)).subscribe(() => {
        if (this.isOptionsAutocompleteInputShown) {
          this.optionsAutocompleteInput.nativeElement.focus();
        }
        this.setActiveOption();
      });
      this.selectOpen.emit();
      this.cd.markForCheck();
    }
  }
  hide() {
    if (this.isOpen) {
      this.ref.detach();
      this.cd.markForCheck();
      this.selectClose.emit();
      this.resetAutocompleteInput();
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd.markForCheck();
  }
  writeValue(value) {
    if (!this.alive) {
      return;
    }
    if (this.canSelectValue()) {
      this.setSelection(value);
      if (this.selectionModel.length) {
        this.queue = null;
      }
    } else {
      this.queue = value;
    }
  }
  /**
   * Selects option or clear all selected options if value is null.
   * */
  handleOptionClick(option) {
    this.queue = null;
    if (option.value == null) {
      this.reset();
    } else {
      this.selectOption(option);
    }
    this.cd.markForCheck();
  }
  /**
   * Deselect all selected options.
   * */
  reset() {
    this.selectionModel.forEach((option) => option.deselect());
    this.selectionModel = [];
    this.hide();
    this.focusButton();
    this.emitSelected(this.multiple ? [] : null);
  }
  /**
   * Determines how to select option as multiple or single.
   * */
  selectOption(option) {
    if (this.multiple) {
      this.handleMultipleSelect(option);
    } else {
      this.handleSingleSelect(option);
    }
  }
  /**
   * Select single option.
   * */
  handleSingleSelect(option) {
    const selected = this.selectionModel.pop();
    if (selected && !this._compareWith(selected.value, option.value)) {
      selected.deselect();
    }
    this.selectionModel = [option];
    option.select();
    this.hide();
    this.focusButton();
    this.emitSelected(option.value);
  }
  /**
   * Select for multiple options.
   * */
  handleMultipleSelect(option) {
    if (option.selected) {
      this.selectionModel = this.selectionModel.filter((s) => !this._compareWith(s.value, option.value));
      option.deselect();
    } else {
      this.selectionModel.push(option);
      option.select();
    }
    this.emitSelected(this.selectionModel.map((opt) => opt.value));
  }
  attachToOverlay() {
    if (!this.ref) {
      this.createOverlay();
      this.subscribeOnPositionChange();
      this.createKeyManager();
      this.subscribeOnOverlayKeys();
      this.subscribeOnOptionsAutocompleteChange();
    }
    this.ref.attach(this.portal);
  }
  setActiveOption() {
    if (this.selectionModel.length && !this.selectionModel[0].hidden) {
      this.currentKeyManager?.setActiveItem(this.selectionModel[0]);
    } else {
      this.currentKeyManager?.setFirstItemActive();
    }
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.positionStrategy$.next(this.createPositionStrategy());
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy$.value,
      scrollStrategy,
      panelClass: this.optionsPanelClass
    });
  }
  createKeyManager() {
    this.activeDescendantKeyManager = this.activeDescendantKeyManagerFactoryService.create(this.options).skipPredicate((option) => {
      return this.isOptionHidden(option);
    });
    this.focusKeyManager = this.focusKeyManagerFactoryService.create(this.options).withTypeAhead(200).skipPredicate((option) => {
      return this.isOptionHidden(option);
    });
    this.updateCurrentKeyManager();
  }
  updateCurrentKeyManager() {
    this.currentKeyManager?.setActiveItem(-1);
    if (this.isOptionsAutocompleteAllowed) {
      this.currentKeyManager = this.activeDescendantKeyManager;
    } else {
      this.currentKeyManager = this.focusKeyManager;
    }
    this.setActiveOption();
  }
  resetAutocompleteInput() {
    if (this.optionsAutocompleteInput?.nativeElement) {
      this.optionsAutocompleteInput.nativeElement.value = this.selectionView;
      this.optionsAutocompleteInputChange.emit("");
    }
  }
  createPositionStrategy() {
    const element = this.isOptionsAutocompleteAllowed ? this.optionsAutocompleteInput : this.button;
    return this.positionBuilder.connectedTo(element).position(NbPosition.BOTTOM).offset(this.optionsOverlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  updatePositionStrategy() {
    if (this.ref) {
      this.positionStrategy$.next(this.createPositionStrategy());
      this.ref.updatePositionStrategy(this.positionStrategy$.value);
      if (this.isOpen) {
        this.ref.updatePosition();
      }
    }
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.CLICK).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(($event) => {
      this.hide();
      if (!this.isClickedWithinComponent($event)) {
        this.onTouched();
      }
    });
  }
  subscribeOnPositionChange() {
    this.positionStrategy$.pipe(switchMap((positionStrategy) => positionStrategy.positionChange ?? EMPTY), takeUntil(this.destroy$)).subscribe((position) => {
      this.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  subscribeOnOptionClick() {
    this.options.changes.pipe(startWith(this.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleOptionClick(clickedOption));
  }
  subscribeOnOverlayKeys() {
    this.ref.keydownEvents().pipe(filter(() => this.isOpen), takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE) {
        this.hide();
        this.focusButton();
      } else if (event.keyCode === ENTER && this.isOptionsAutocompleteInputShown) {
        event.preventDefault();
        const activeItem = this.currentKeyManager.activeItem;
        if (activeItem) {
          this.selectOption(activeItem);
        }
      } else {
        this.currentKeyManager.onKeydown(event);
      }
    });
    merge(this.focusKeyManager.tabOut.pipe(filter(() => !this.isOptionsAutocompleteInputShown)), this.activeDescendantKeyManager.tabOut.pipe(filter(() => this.isOptionsAutocompleteInputShown))).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.hide();
      this.onTouched();
    });
  }
  subscribeOnOptionsAutocompleteChange() {
    this.optionsAutocompleteInputChange.pipe(observeOn(animationFrameScheduler), filter(() => this.isOptionsAutocompleteInputShown), takeUntil(this.destroy$)).subscribe(() => {
      if (this.isOptionHidden(this.currentKeyManager.activeItem)) {
        this.currentKeyManager.setFirstItemActive();
      }
    });
  }
  subscribeOnButtonFocus() {
    const buttonFocus$ = this.focusMonitor.monitor(this.button).pipe(map((origin) => !!origin), startWith(false), finalize(() => this.focusMonitor.stopMonitoring(this.button)));
    const filterInputFocus$ = this.focusMonitor.monitor(this.optionsAutocompleteInput).pipe(map((origin) => !!origin), startWith(false), finalize(() => this.focusMonitor.stopMonitoring(this.button)));
    combineLatest([buttonFocus$, filterInputFocus$]).pipe(map(([buttonFocus, filterInputFocus]) => buttonFocus || filterInputFocus), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  getContainer() {
    return this.ref && this.ref.hasAttached() && {
      location: {
        nativeElement: this.ref.overlayElement
      }
    };
  }
  focusButton() {
    setTimeout(() => {
      this.button?.nativeElement?.focus();
    });
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.onChange(selected);
    this.selectedChange.emit(selected);
  }
  /**
   * Set selected value in model.
   * */
  setSelection(value) {
    const isResetValue = value == null;
    let safeValue = value;
    if (this.multiple) {
      safeValue = value ?? [];
    }
    const isArray = Array.isArray(safeValue);
    if (this.multiple && !isArray && !isResetValue) {
      throw new Error("Can't assign single value if select is marked as multiple");
    }
    if (!this.multiple && isArray) {
      throw new Error("Can't assign array if select is not marked as multiple");
    }
    const previouslySelectedOptions = this.selectionModel;
    this.selectionModel = [];
    if (this.multiple) {
      safeValue.forEach((option) => this.selectValue(option));
    } else {
      this.selectValue(safeValue);
    }
    previouslySelectedOptions.filter((option) => !this.selectionModel.includes(option)).forEach((option) => option.deselect());
    this.cd.markForCheck();
  }
  /**
   * Selects value.
   * */
  selectValue(value) {
    if (value == null) {
      return;
    }
    const corresponding = this.options.find((option) => this._compareWith(option.value, value));
    if (corresponding) {
      corresponding.select();
      this.selectionModel.push(corresponding);
    }
  }
  shouldShow() {
    return this.isHidden && this.options?.length > 0;
  }
  /**
   * Sets touched if focus moved outside of button and overlay,
   * ignoring the case when focus moved to options overlay.
   */
  trySetTouched() {
    if (this.isHidden) {
      this.onTouched();
    }
  }
  isClickedWithinComponent($event) {
    return this.hostRef.nativeElement === $event.target || this.hostRef.nativeElement.contains($event.target);
  }
  canSelectValue() {
    return !!(this.options && this.options.length);
  }
  isOptionHidden(option) {
    return option.hidden;
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  static {
    this.ɵfac = function NbSelectWithAutocompleteComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSelectWithAutocompleteComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbFocusKeyManagerFactoryService), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService), ɵɵdirectiveInject(NbActiveDescendantKeyManagerFactoryService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbSelectWithAutocompleteComponent,
      selectors: [["nb-select-with-autocomplete"]],
      contentQueries: function NbSelectWithAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbSelectLabelComponent, 5);
          ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.customLabel = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
        }
      },
      viewQuery: function NbSelectWithAutocompleteComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbPortalDirective, 5);
          ɵɵviewQuery(_c40, 5, ElementRef);
          ɵɵviewQuery(_c47, 5, ElementRef);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.button = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionsAutocompleteInput = _t.first);
        }
      },
      hostVars: 42,
      hostBindings: function NbSelectWithAutocompleteComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("appearance-outline", ctx.outline)("appearance-filled", ctx.filled)("appearance-hero", ctx.hero)("full-width", ctx.fullWidth)("open", ctx.isOpen)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound);
        }
      },
      inputs: {
        size: "size",
        status: "status",
        shape: "shape",
        appearance: "appearance",
        optionsListClass: "optionsListClass",
        optionsPanelClass: "optionsPanelClass",
        optionsWidth: "optionsWidth",
        outline: "outline",
        filled: "filled",
        hero: "hero",
        disabled: "disabled",
        fullWidth: "fullWidth",
        placeholder: "placeholder",
        compareWith: "compareWith",
        selected: "selected",
        multiple: "multiple",
        optionsOverlayOffset: "optionsOverlayOffset",
        scrollStrategy: "scrollStrategy",
        withOptionsAutocomplete: "withOptionsAutocomplete"
      },
      outputs: {
        selectedChange: "selectedChange",
        selectOpen: "selectOpen",
        selectClose: "selectClose",
        optionsAutocompleteInputChange: "optionsAutocompleteInputChange"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _NbSelectWithAutocompleteComponent),
        multi: true
      }, {
        provide: NB_SELECT_INJECTION_TOKEN,
        useExisting: _NbSelectWithAutocompleteComponent
      }, {
        provide: NbFormFieldControl,
        useExisting: _NbSelectWithAutocompleteComponent
      }, {
        provide: NbFormFieldControlConfig,
        useFactory: nbSelectFormFieldControlConfigFactory
      }]), ɵɵNgOnChangesFeature],
      ngContentSelectors: _c42,
      decls: 12,
      vars: 13,
      consts: [["selectButton", ""], ["placeholderTemplate", ""], ["optionsAutocompleteInput", ""], ["defaultSelectionTemplate", ""], ["type", "button", 1, "select-button", 3, "blur", "keydown.arrowDown", "keydown.arrowUp", "hidden", "disabled", "ngClass"], [3, "click"], [4, "ngIf", "ngIfElse"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"], [3, "hidden"], ["nbInput", "", "fullWidth", "", 3, "blur", "click", "dblclick", "input", "value", "placeholder", "status", "shape", "fieldSize"], ["nbSuffix", "", "icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true"], [3, "size", "position", "width", "ngClass", 4, "nbPortal"], [3, "size", "position", "ngClass"]],
      template: function NbSelectWithAutocompleteComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵprojectionDef(_c41);
          ɵɵelementStart(0, "button", 4, 0);
          ɵɵlistener("blur", function NbSelectWithAutocompleteComponent_Template_button_blur_0_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.trySetTouched());
          })("keydown.arrowDown", function NbSelectWithAutocompleteComponent_Template_button_keydown_arrowDown_0_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.show());
          })("keydown.arrowUp", function NbSelectWithAutocompleteComponent_Template_button_keydown_arrowUp_0_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.show());
          });
          ɵɵelementStart(2, "span", 5);
          ɵɵlistener("click", function NbSelectWithAutocompleteComponent_Template_span_click_2_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.disabled && $event.stopPropagation());
          });
          ɵɵtemplate(3, NbSelectWithAutocompleteComponent_ng_container_3_Template, 4, 2, "ng-container", 6)(4, NbSelectWithAutocompleteComponent_ng_template_4_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
          ɵɵelementEnd();
          ɵɵelementStart(6, "nb-icon", 7);
          ɵɵlistener("click", function NbSelectWithAutocompleteComponent_Template_nb_icon_click_6_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.disabled && $event.stopPropagation());
          });
          ɵɵelementEnd()();
          ɵɵelementStart(7, "nb-form-field", 8)(8, "input", 9, 2);
          ɵɵlistener("blur", function NbSelectWithAutocompleteComponent_Template_input_blur_8_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.trySetTouched());
          })("click", function NbSelectWithAutocompleteComponent_Template_input_click_8_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView($event.stopPropagation());
          })("dblclick", function NbSelectWithAutocompleteComponent_Template_input_dblclick_8_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView($event.stopPropagation());
          })("input", function NbSelectWithAutocompleteComponent_Template_input_input_8_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.onAutocompleteInputChange($event));
          });
          ɵɵelementEnd();
          ɵɵelement(10, "nb-icon", 10);
          ɵɵelementEnd();
          ɵɵtemplate(11, NbSelectWithAutocompleteComponent_nb_option_list_11_Template, 2, 5, "nb-option-list", 11);
        }
        if (rf & 2) {
          const placeholderTemplate_r4 = ɵɵreference(5);
          ɵɵproperty("hidden", ctx.isOptionsAutocompleteInputShown)("disabled", ctx.disabled)("ngClass", ctx.selectButtonClasses);
          ɵɵadvance(3);
          ɵɵproperty("ngIf", ctx.selectionModel.length)("ngIfElse", placeholderTemplate_r4);
          ɵɵadvance(4);
          ɵɵproperty("hidden", !ctx.isOptionsAutocompleteInputShown);
          ɵɵadvance();
          ɵɵstyleProp("max-width", ctx.lastShownButtonWidth, "px");
          ɵɵproperty("value", ctx.selectionView)("placeholder", ctx.placeholder)("status", ctx.status)("shape", ctx.shape)("fieldSize", ctx.size);
        }
      },
      dependencies: [NgClass, NgIf, NbPortalDirective, NbInputDirective, NbIconComponent, NbOptionListComponent, NbFormFieldComponent, NbSuffixDirective],
      styles: ["[_nghost-%COMP%]{display:inline-block;max-width:100%}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:left}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.2em}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:right}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.2em}.full-width[_nghost-%COMP%]{width:100%}.nb-transition[_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button[_ngcontent-%COMP%], nb-form-field[_ngcontent-%COMP%]{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){right:.5rem}[dir=rtl][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){left:.5rem}.open[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){transform:translateY(-50%) rotate(180deg)}\n\n\n\n\n\n\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectWithAutocompleteComponent, [{
    type: Component,
    args: [{
      selector: "nb-select-with-autocomplete",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbSelectWithAutocompleteComponent),
        multi: true
      }, {
        provide: NB_SELECT_INJECTION_TOKEN,
        useExisting: NbSelectWithAutocompleteComponent
      }, {
        provide: NbFormFieldControl,
        useExisting: NbSelectWithAutocompleteComponent
      }, {
        provide: NbFormFieldControlConfig,
        useFactory: nbSelectFormFieldControlConfigFactory
      }],
      standalone: false,
      template: '<button\n  [hidden]="isOptionsAutocompleteInputShown"\n  [disabled]="disabled"\n  [ngClass]="selectButtonClasses"\n  (blur)="trySetTouched()"\n  (keydown.arrowDown)="show()"\n  (keydown.arrowUp)="show()"\n  class="select-button"\n  type="button"\n  #selectButton\n>\n  <span (click)="disabled && $event.stopPropagation()">\n    <ng-container *ngIf="selectionModel.length; else placeholderTemplate">\n      <ng-container *ngIf="customLabel; else defaultSelectionTemplate">\n        <ng-content select="nb-select-label"></ng-content>\n      </ng-container>\n\n      <ng-template #defaultSelectionTemplate>{{ selectionView }}</ng-template>\n    </ng-container>\n\n    <ng-template #placeholderTemplate>{{ placeholder }}</ng-template>\n  </span>\n\n  <nb-icon\n    icon="chevron-down-outline"\n    pack="nebular-essentials"\n    (click)="disabled && $event.stopPropagation()"\n    aria-hidden="true"\n  >\n  </nb-icon>\n</button>\n\n<nb-form-field [hidden]="!isOptionsAutocompleteInputShown">\n  <input\n    nbInput\n    fullWidth\n    [style.max-width.px]="lastShownButtonWidth"\n    #optionsAutocompleteInput\n    [value]="selectionView"\n    [placeholder]="placeholder"\n    [status]="status"\n    [shape]="shape"\n    [fieldSize]="size"\n    (blur)="trySetTouched()"\n    (click)="$event.stopPropagation()"\n    (dblclick)="$event.stopPropagation()"\n    (input)="onAutocompleteInputChange($event)"\n  />\n  <nb-icon nbSuffix icon="chevron-up-outline" pack="nebular-essentials" aria-hidden="true"> </nb-icon>\n</nb-form-field>\n\n<nb-option-list\n  *nbPortal\n  [size]="size"\n  [position]="overlayPosition"\n  [style.width.px]="optionsWidth"\n  [ngClass]="optionsListClass"\n>\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: [":host{display:inline-block;max-width:100%}[dir=ltr] :host .select-button{text-align:left}[dir=ltr] :host .select-button nb-icon{right:.2em}[dir=rtl] :host .select-button{text-align:right}[dir=rtl] :host .select-button nb-icon{left:.2em}:host(.full-width){width:100%}:host(.nb-transition) .select-button{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button,nb-form-field{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon:not([nbSuffix]){font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr] nb-icon:not([nbSuffix]){right:.5rem}[dir=rtl] nb-icon:not([nbSuffix]){left:.5rem}:host(.open) nb-icon:not([nbSuffix]){transform:translateY(-50%) rotate(180deg)}\n/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbOverlayService
  }, {
    type: ElementRef
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbFocusKeyManagerFactoryService
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    disabled: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    placeholder: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    optionsOverlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    withOptionsAutocomplete: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    selectedChange: [{
      type: Output
    }],
    selectOpen: [{
      type: Output
    }],
    selectClose: [{
      type: Output
    }],
    optionsAutocompleteInputChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    customLabel: [{
      type: ContentChild,
      args: [NbSelectLabelComponent]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    button: [{
      type: ViewChild,
      args: ["selectButton", {
        read: ElementRef
      }]
    }],
    optionsAutocompleteInput: [{
      type: ViewChild,
      args: ["optionsAutocompleteInput", {
        read: ElementRef
      }]
    }],
    isOpen: [{
      type: HostBinding,
      args: ["class.open"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }]
  });
})();
var COMPONENTS$1 = [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective];
var NbFormFieldModule = class _NbFormFieldModule {
  static {
    this.ɵfac = function NbFormFieldModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbFormFieldModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbFormFieldModule,
      declarations: [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective],
      imports: [CommonModule],
      exports: [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [...COMPONENTS$1],
      exports: [...COMPONENTS$1]
    }]
  }], null, null);
})();
var NB_SELECT_COMPONENTS = [NbSelectWithAutocompleteComponent];
var NbSelectWithAutocompleteModule = class _NbSelectWithAutocompleteModule {
  static {
    this.ɵfac = function NbSelectWithAutocompleteModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSelectWithAutocompleteModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbSelectWithAutocompleteModule,
      declarations: [NbSelectWithAutocompleteComponent],
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule],
      exports: [NbSelectWithAutocompleteComponent, NbOptionModule, NbSelectModule]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule, NbOptionModule, NbSelectModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectWithAutocompleteModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule],
      exports: [...NB_SELECT_COMPONENTS, NbOptionModule, NbSelectModule],
      declarations: [...NB_SELECT_COMPONENTS]
    }]
  }], null, null);
})();
var lastAutocompleteId = 0;
var NbAutocompleteComponent = class _NbAutocompleteComponent {
  get overlayPosition() {
    return this._overlayPosition;
  }
  set overlayPosition(value) {
    this._overlayPosition = value;
    this.cd.detectChanges();
  }
  /**
   * Returns width of the input.
   * */
  get hostWidth() {
    return this.hostRef.nativeElement.getBoundingClientRect().width;
  }
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  constructor(cd) {
    this.cd = cd;
    this.destroy$ = new Subject();
    this.id = `nb-autocomplete-${lastAutocompleteId++}`;
    this._overlayPosition = "";
    this.size = "medium";
    this.activeFirst = false;
    this.selectedChange = new EventEmitter();
  }
  ngAfterContentInit() {
    this.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Autocomplete knows nothing about host html input element.
   * So, attach method set input hostRef for styling.
   * */
  setHost(hostRef) {
    this.hostRef = hostRef;
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.selectedChange.emit(selected);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  static {
    this.ɵfac = function NbAutocompleteComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbAutocompleteComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbAutocompleteComponent,
      selectors: [["nb-autocomplete"]],
      contentQueries: function NbAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
        }
      },
      viewQuery: function NbAutocompleteComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbPortalDirective, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
        }
      },
      hostVars: 10,
      hostBindings: function NbAutocompleteComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
        }
      },
      inputs: {
        handleDisplayFn: "handleDisplayFn",
        size: "size",
        activeFirst: "activeFirst",
        optionsListClass: "optionsListClass",
        optionsPanelClass: "optionsPanelClass",
        optionsWidth: "optionsWidth"
      },
      outputs: {
        selectedChange: "selectedChange"
      },
      standalone: false,
      ngContentSelectors: _c49,
      decls: 1,
      vars: 0,
      consts: [["role", "listbox", 3, "size", "position", "width", "id", "empty", "ngClass", 4, "nbPortal"], ["role", "listbox", 3, "size", "position", "id", "ngClass"]],
      template: function NbAutocompleteComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c48);
          ɵɵtemplate(0, NbAutocompleteComponent_nb_option_list_0_Template, 2, 8, "nb-option-list", 0);
        }
      },
      dependencies: [NgClass, NbPortalDirective, NbOptionListComponent],
      styles: ["[_nghost-%COMP%]:hover{cursor:pointer}nb-option-list.empty[_ngcontent-%COMP%]{border:none}\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteComponent, [{
    type: Component,
    args: [{
      selector: "nb-autocomplete",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<nb-option-list *nbPortal\n                [size]="size"\n                [position]="overlayPosition"\n                [style.width.px]="optionsWidth"\n                role="listbox"\n                [id]="id"\n                [class.empty]="!options?.length"\n                [ngClass]="optionsListClass">\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: [":host(:hover){cursor:pointer}nb-option-list.empty{border:none}\n/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    handleDisplayFn: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    activeFirst: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    selectedChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var NbAutocompleteDirective = class _NbAutocompleteDirective {
  /**
   * Determines is autocomplete overlay opened.
   * */
  get isOpen() {
    return this.overlayRef && this.overlayRef.hasAttached();
  }
  /**
   * Determines is autocomplete overlay closed.
   * */
  get isClosed() {
    return !this.isOpen;
  }
  /**
   * Provides autocomplete component.
   * */
  get autocomplete() {
    return this._autocomplete;
  }
  set autocomplete(autocomplete) {
    this._autocomplete = autocomplete;
  }
  get top() {
    return this.isOpen && this.autocomplete.options.length && this.autocomplete.overlayPosition === NbPosition.TOP;
  }
  get bottom() {
    return this.isOpen && this.autocomplete.options.length && this.autocomplete.overlayPosition === NbPosition.BOTTOM;
  }
  get ariaExpanded() {
    return this.isOpen && this.isOpen.toString();
  }
  get ariaOwns() {
    return this.isOpen ? this.autocomplete.id : null;
  }
  get ariaActiveDescendant() {
    return this.isOpen && this.keyManager.activeItem ? this.keyManager.activeItem.id : null;
  }
  constructor(hostRef, overlay, cd, triggerStrategyBuilder, positionBuilder, activeDescendantKeyManagerFactory, renderer) {
    this.hostRef = hostRef;
    this.overlay = overlay;
    this.cd = cd;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.positionBuilder = positionBuilder;
    this.activeDescendantKeyManagerFactory = activeDescendantKeyManagerFactory;
    this.renderer = renderer;
    this.destroy$ = new Subject();
    this._onChange = () => {
    };
    this._onTouched = () => {
    };
    this.overlayOffset = 8;
    this.scrollStrategy = "block";
    this.role = "combobox";
    this.ariaAutocomplete = "list";
    this.hasPopup = "true";
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnTriggers();
  }
  ngOnDestroy() {
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
    if (this.positionStrategy) {
      this.positionStrategy.dispose();
    }
    if (this.overlayRef) {
      this.overlayRef.dispose();
    }
    this.destroy$.next();
    this.destroy$.complete();
  }
  handleInput() {
    const currentValue = this.hostRef.nativeElement.value;
    this._onChange(currentValue);
    this.setHostInputValue(this.getDisplayValue(currentValue));
    this.show();
  }
  handleKeydown() {
    this.show();
  }
  handleBlur() {
    this._onTouched();
  }
  show() {
    if (this.shouldShow()) {
      this.attachToOverlay();
      this.setActiveItem();
    }
  }
  hide() {
    if (this.isOpen) {
      this.overlayRef.detach();
      this.cd.markForCheck();
    }
  }
  writeValue(value) {
    this.handleInputValueUpdate(value);
  }
  registerOnChange(fn) {
    this._onChange = fn;
  }
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  setDisabledState(disabled) {
    this.renderer.setProperty(this.hostRef.nativeElement, "disabled", disabled);
  }
  subscribeOnOptionClick() {
    this.autocomplete.options.changes.pipe(tap(() => this.setActiveItem()), startWith(this.autocomplete.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleInputValueUpdate(clickedOption.value, true));
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => {
      this.autocomplete.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  getActiveItem() {
    return this.keyManager.activeItem;
  }
  setupAutocomplete() {
    this.autocomplete.setHost(this.customOverlayHost || this.hostRef);
  }
  getDisplayValue(value) {
    const displayFn = this.autocomplete.handleDisplayFn;
    return displayFn ? displayFn(value) : value;
  }
  getContainer() {
    return this.overlayRef && this.isOpen && {
      location: {
        nativeElement: this.overlayRef.overlayElement
      }
    };
  }
  handleInputValueUpdate(value, focusInput = false) {
    this.setHostInputValue(value ?? "");
    this._onChange(value);
    if (focusInput) {
      this.hostRef.nativeElement.focus();
    }
    this.autocomplete.emitSelected(value);
    this.hide();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.pipe(filter(() => this.isClosed)).subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(() => this.hide());
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  createKeyManager() {
    this.keyManager = this.activeDescendantKeyManagerFactory.create(this.autocomplete.options);
  }
  setHostInputValue(value) {
    this.hostRef.nativeElement.value = this.getDisplayValue(value);
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.customOverlayHost || this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  subscribeOnOverlayKeys() {
    this.overlayRef.keydownEvents().pipe(takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE && this.isOpen) {
        event.preventDefault();
        this.hostRef.nativeElement.focus();
        this.hide();
      } else if (event.keyCode === ENTER) {
        event.preventDefault();
        const activeItem = this.getActiveItem();
        if (!activeItem) {
          return;
        }
        this.handleInputValueUpdate(activeItem.value, true);
      } else {
        this.keyManager.onKeydown(event);
      }
    });
  }
  setActiveItem() {
    const mode = this.autocomplete.activeFirst ? NbKeyManagerActiveItemMode.FIRST_ACTIVE : NbKeyManagerActiveItemMode.RESET_ACTIVE;
    this.keyManager.setActiveItem(mode);
    this.cd.detectChanges();
  }
  attachToOverlay() {
    if (!this.overlayRef) {
      this.setupAutocomplete();
      this.initOverlay();
    }
    this.overlayRef.attach(this.autocomplete.portal);
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.overlayRef = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy,
      panelClass: this.autocomplete.optionsPanelClass
    });
  }
  initOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.createKeyManager();
    this.subscribeOnPositionChange();
    this.subscribeOnOptionClick();
    this.checkOverlayVisibility();
    this.createOverlay();
    this.subscribeOnOverlayKeys();
  }
  checkOverlayVisibility() {
    this.autocomplete.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
      if (!this.autocomplete.options.length) {
        this.hide();
      }
    });
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  shouldShow() {
    return this.isClosed;
  }
  static {
    this.ɵfac = function NbAutocompleteDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbAutocompleteDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbActiveDescendantKeyManagerFactoryService), ɵɵdirectiveInject(Renderer2));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbAutocompleteDirective,
      selectors: [["input", "nbAutocomplete", ""]],
      hostVars: 10,
      hostBindings: function NbAutocompleteDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("input", function NbAutocompleteDirective_input_HostBindingHandler() {
            return ctx.handleInput();
          })("keydown.arrowDown", function NbAutocompleteDirective_keydown_arrowDown_HostBindingHandler() {
            return ctx.handleKeydown();
          })("keydown.arrowUp", function NbAutocompleteDirective_keydown_arrowUp_HostBindingHandler() {
            return ctx.handleKeydown();
          })("blur", function NbAutocompleteDirective_blur_HostBindingHandler() {
            return ctx.handleBlur();
          });
        }
        if (rf & 2) {
          ɵɵattribute("role", ctx.role)("aria-autocomplete", ctx.ariaAutocomplete)("haspopup", ctx.hasPopup)("aria-expanded", ctx.ariaExpanded)("aria-owns", ctx.ariaOwns)("aria-activedescendant", ctx.ariaActiveDescendant);
          ɵɵclassProp("nb-autocomplete-position-top", ctx.top)("nb-autocomplete-position-bottom", ctx.bottom);
        }
      },
      inputs: {
        autocomplete: [0, "nbAutocomplete", "autocomplete"],
        overlayOffset: "overlayOffset",
        scrollStrategy: "scrollStrategy",
        customOverlayHost: "customOverlayHost"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _NbAutocompleteDirective),
        multi: true
      }])]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbAutocomplete]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbAutocompleteDirective),
        multi: true
      }],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }, {
    type: Renderer2
  }], {
    autocomplete: [{
      type: Input,
      args: ["nbAutocomplete"]
    }],
    overlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    customOverlayHost: [{
      type: Input
    }],
    top: [{
      type: HostBinding,
      args: ["class.nb-autocomplete-position-top"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.nb-autocomplete-position-bottom"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaAutocomplete: [{
      type: HostBinding,
      args: ["attr.aria-autocomplete"]
    }],
    hasPopup: [{
      type: HostBinding,
      args: ["attr.haspopup"]
    }],
    ariaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    ariaOwns: [{
      type: HostBinding,
      args: ["attr.aria-owns"]
    }],
    ariaActiveDescendant: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    handleInput: [{
      type: HostListener,
      args: ["input"]
    }],
    handleKeydown: [{
      type: HostListener,
      args: ["keydown.arrowDown"]
    }, {
      type: HostListener,
      args: ["keydown.arrowUp"]
    }],
    handleBlur: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var NB_AUTOCOMPLETE_COMPONENTS = [NbAutocompleteComponent, NbAutocompleteDirective];
var NbAutocompleteModule = class _NbAutocompleteModule {
  static {
    this.ɵfac = function NbAutocompleteModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbAutocompleteModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbAutocompleteModule,
      declarations: [NbAutocompleteComponent, NbAutocompleteDirective],
      imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule],
      exports: [NbAutocompleteComponent, NbAutocompleteDirective, NbOptionModule]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule, NbOptionModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule],
      exports: [...NB_AUTOCOMPLETE_COMPONENTS, NbOptionModule],
      declarations: [...NB_AUTOCOMPLETE_COMPONENTS]
    }]
  }], null, null);
})();
var NbWindowState;
(function(NbWindowState2) {
  NbWindowState2["MINIMIZED"] = "minimized";
  NbWindowState2["MAXIMIZED"] = "maximized";
  NbWindowState2["FULL_SCREEN"] = "full-screen";
})(NbWindowState || (NbWindowState = {}));
var NB_WINDOW_DEFAULT_BUTTONS_CONFIG = {
  minimize: true,
  maximize: true,
  fullScreen: true,
  close: true
};
var NbWindowConfig = class {
  constructor(...configs) {
    this.title = "";
    this.titleTemplateContext = {};
    this.initialState = NbWindowState.FULL_SCREEN;
    this.hasBackdrop = true;
    this.closeOnBackdropClick = true;
    this.closeOnEsc = true;
    this.windowClass = "";
    this.context = {};
    this.viewContainerRef = null;
    this.buttons = {};
    Object.assign(this, ...configs);
    this.applyDefaultButtonConfig();
  }
  applyDefaultButtonConfig() {
    Object.assign(this, {
      buttons: __spreadValues(__spreadValues({}, NB_WINDOW_DEFAULT_BUTTONS_CONFIG), this.buttons)
    });
  }
};
var NB_WINDOW_CONTENT = new InjectionToken("Nebular Window Content");
var NB_WINDOW_CONFIG = new InjectionToken("Nebular Window Config");
var NB_WINDOW_CONTEXT = new InjectionToken("Nebular Window Context");
var NbWindowRef = class {
  /**
   * Current window state.
   */
  get state() {
    return this.stateValue;
  }
  set state(newState) {
    if (newState && this.stateValue !== newState) {
      this.prevStateValue = this.state;
      this.stateValue = newState;
      this.stateChange$.next({
        oldState: this.prevStateValue,
        newState
      });
    }
  }
  /**
   * Emits when window state change.
   */
  get stateChange() {
    return this.stateChange$.asObservable();
  }
  /**
   * Emits when window was closed.
   */
  get onClose() {
    return this.closed$.asObservable();
  }
  constructor(config) {
    this.config = config;
    this.stateChange$ = new ReplaySubject(1);
    this._closed = false;
    this.closed$ = new Subject();
    this.state = config.initialState;
  }
  /**
   * Minimize window.
   */
  minimize() {
    this.state = NbWindowState.MINIMIZED;
  }
  /**
   * Maximize window.
   */
  maximize() {
    this.state = NbWindowState.MAXIMIZED;
  }
  /**
   * Set window on top.
   */
  fullScreen() {
    this.state = NbWindowState.FULL_SCREEN;
  }
  toPreviousState() {
    this.state = this.prevStateValue;
  }
  /**
   * Closes window.
   * */
  close(res) {
    if (this._closed) {
      return;
    }
    this._closed = true;
    this.componentRef.destroy();
    this.componentInstance = null;
    this.stateChange$.complete();
    this.closed$.next(res);
    this.closed$.complete();
  }
};
var NbWindowsContainerComponent = class _NbWindowsContainerComponent {
  static {
    this.ɵfac = function NbWindowsContainerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbWindowsContainerComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbWindowsContainerComponent,
      selectors: [["nb-windows-container"]],
      viewQuery: function NbWindowsContainerComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c50, 7, ViewContainerRef);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);
        }
      },
      standalone: false,
      decls: 2,
      vars: 0,
      consts: [["viewContainerRef", ""]],
      template: function NbWindowsContainerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementContainer(0, null, 0);
        }
      },
      styles: ["[_nghost-%COMP%]{display:flex;align-items:flex-end;overflow-x:auto}[_nghost-%COMP%]     nb-window:not(.full-screen){margin:0 2rem}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowsContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-windows-container",
      template: `<ng-container #viewContainerRef></ng-container>`,
      standalone: false,
      styles: [":host{display:flex;align-items:flex-end;overflow-x:auto}:host ::ng-deep nb-window:not(.full-screen){margin:0 2rem}\n"]
    }]
  }], null, {
    viewContainerRef: [{
      type: ViewChild,
      args: ["viewContainerRef", {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
var NbWindowComponent = class _NbWindowComponent {
  get isFullScreen() {
    return this.windowRef.state === NbWindowState.FULL_SCREEN;
  }
  get maximized() {
    return this.windowRef.state === NbWindowState.MAXIMIZED;
  }
  get minimized() {
    return this.windowRef.state === NbWindowState.MINIMIZED;
  }
  get showMinimize() {
    return this.config.buttons.minimize;
  }
  get showMaximize() {
    return this.config.buttons.maximize;
  }
  get showFullScreen() {
    return this.config.buttons.fullScreen;
  }
  get showClose() {
    return this.config.buttons.close;
  }
  constructor(content, context, windowRef, config, focusTrapFactory, elementRef, renderer) {
    this.content = content;
    this.context = context;
    this.windowRef = windowRef;
    this.config = config;
    this.focusTrapFactory = focusTrapFactory;
    this.elementRef = elementRef;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
    this.focusTrap.blurPreviouslyFocusedElement();
    this.focusTrap.focusInitialElement();
    if (this.config.windowClass) {
      this.renderer.addClass(this.elementRef.nativeElement, this.config.windowClass);
    }
  }
  ngAfterViewChecked() {
    if (!this.overlayContainer || this.overlayContainer.isAttached) {
      return;
    }
    if (this.content instanceof TemplateRef) {
      this.attachTemplate();
    } else {
      this.attachComponent();
    }
  }
  ngOnDestroy() {
    if (this.focusTrap) {
      this.focusTrap.restoreFocus();
    }
    this.close();
  }
  minimize() {
    if (this.windowRef.state === NbWindowState.MINIMIZED) {
      this.windowRef.toPreviousState();
    } else {
      this.windowRef.minimize();
    }
  }
  maximize() {
    this.windowRef.maximize();
  }
  fullScreen() {
    this.windowRef.fullScreen();
  }
  maximizeOrFullScreen() {
    if (this.windowRef.state === NbWindowState.MINIMIZED && this.showMaximize) {
      this.maximize();
    } else {
      this.fullScreen();
    }
  }
  close() {
    this.windowRef.close();
  }
  attachTemplate() {
    this.overlayContainer.attachTemplatePortal(new NbTemplatePortal(this.content, null, this.context));
  }
  attachComponent() {
    const portal = new NbComponentPortal(this.content, null, null, this.cfr);
    const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
    this.windowRef.componentInstance = ref.instance;
    ref.changeDetectorRef.detectChanges();
  }
  static {
    this.ɵfac = function NbWindowComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbWindowComponent)(ɵɵdirectiveInject(NB_WINDOW_CONTENT), ɵɵdirectiveInject(NB_WINDOW_CONTEXT), ɵɵdirectiveInject(NbWindowRef), ɵɵdirectiveInject(NbWindowConfig), ɵɵdirectiveInject(NbFocusTrapFactoryService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbWindowComponent,
      selectors: [["nb-window"]],
      viewQuery: function NbWindowComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(NbOverlayContainerComponent, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
        }
      },
      hostVars: 6,
      hostBindings: function NbWindowComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("full-screen", ctx.isFullScreen)("maximized", ctx.maximized)("minimized", ctx.minimized);
        }
      },
      inputs: {
        cfr: "cfr"
      },
      standalone: false,
      decls: 11,
      vars: 7,
      consts: [["textTitleTemplate", ""], ["cdkFocusInitial", "", "tabindex", "-1", 4, "ngIf", "ngIfElse"], [1, "buttons"], [4, "ngIf"], ["cdkFocusInitial", "", "tabindex", "-1"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["cdkFocusInitial", "", "tabindex", "-1", 1, "title"], ["nbButton", "", "ghost", "", 3, "click"], ["icon", "minus-outline", "pack", "nebular-essentials"], ["nbButton", "", "ghost", "", 3, "click", 4, "ngIf"], ["icon", "collapse-outline", "pack", "nebular-essentials"], ["icon", "expand-outline", "pack", "nebular-essentials"], ["icon", "close-outline", "pack", "nebular-essentials"]],
      template: function NbWindowComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "nb-card")(1, "nb-card-header");
          ɵɵtemplate(2, NbWindowComponent_div_2_Template, 2, 4, "div", 1)(3, NbWindowComponent_ng_template_3_Template, 2, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
          ɵɵelementStart(5, "div", 2);
          ɵɵtemplate(6, NbWindowComponent_ng_container_6_Template, 3, 0, "ng-container", 3)(7, NbWindowComponent_ng_container_7_Template, 2, 1, "ng-container", 3)(8, NbWindowComponent_ng_container_8_Template, 2, 1, "ng-container", 3)(9, NbWindowComponent_ng_container_9_Template, 3, 0, "ng-container", 3);
          ɵɵelementEnd()();
          ɵɵtemplate(10, NbWindowComponent_nb_card_body_10_Template, 2, 0, "nb-card-body", 3);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          const textTitleTemplate_r6 = ɵɵreference(4);
          ɵɵadvance(2);
          ɵɵproperty("ngIf", ctx.config.titleTemplate)("ngIfElse", textTitleTemplate_r6);
          ɵɵadvance(4);
          ɵɵproperty("ngIf", ctx.showMinimize);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.showMaximize);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.showFullScreen);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.showClose);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.maximized || ctx.isFullScreen);
        }
      },
      dependencies: [NgIf, NgTemplateOutlet, NbOverlayContainerComponent, NbCardComponent, NbCardBodyComponent, NbCardHeaderComponent, NbIconComponent, NbButtonComponent],
      styles: ["[_nghost-%COMP%]{flex:1 0 auto;min-width:20rem}[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{margin:0}[_nghost-%COMP%]   nb-card-header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;overflow:hidden}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]{width:9.5rem;display:flex;justify-content:flex-end}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]   [nbButton][_ngcontent-%COMP%]{flex:0 0 3rem}.full-screen[_nghost-%COMP%]{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}.maximized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]   nb-card-header[_ngcontent-%COMP%]{border-bottom:none}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowComponent, [{
    type: Component,
    args: [{
      selector: "nb-window",
      template: `
    <nb-card>
      <nb-card-header>
        <div *ngIf="config.titleTemplate; else textTitleTemplate" cdkFocusInitial tabindex="-1">
          <ng-container
            *ngTemplateOutlet="config.titleTemplate; context: { $implicit: config.titleTemplateContext }"
          ></ng-container>
        </div>

        <ng-template #textTitleTemplate>
          <div cdkFocusInitial class="title" tabindex="-1">{{ config.title }}</div>
        </ng-template>

        <div class="buttons">
          <ng-container *ngIf="showMinimize">
            <button nbButton ghost (click)="minimize()">
              <nb-icon icon="minus-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showMaximize">
            <button nbButton ghost *ngIf="isFullScreen" (click)="maximize()">
              <nb-icon icon="collapse-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showFullScreen">
            <button nbButton ghost *ngIf="minimized || maximized" (click)="maximizeOrFullScreen()">
              <nb-icon icon="expand-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showClose">
            <button nbButton ghost (click)="close()">
              <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>
        </div>
      </nb-card-header>
      <nb-card-body *ngIf="maximized || isFullScreen">
        <nb-overlay-container></nb-overlay-container>
      </nb-card-body>
    </nb-card>
  `,
      standalone: false,
      styles: [":host{flex:1 0 auto;min-width:20rem}:host nb-card{margin:0}:host nb-card-header{display:flex;justify-content:space-between;align-items:center;overflow:hidden}:host .title{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host .buttons{width:9.5rem;display:flex;justify-content:flex-end}:host .buttons [nbButton]{flex:0 0 3rem}:host(.full-screen){position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}:host(.maximized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0}:host(.minimized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}:host(.minimized) nb-card nb-card-header{border-bottom:none}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONTENT]
    }]
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONTEXT]
    }]
  }, {
    type: NbWindowRef
  }, {
    type: NbWindowConfig
  }, {
    type: NbFocusTrapFactoryService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    cfr: [{
      type: Input
    }],
    isFullScreen: [{
      type: HostBinding,
      args: ["class.full-screen"]
    }],
    maximized: [{
      type: HostBinding,
      args: ["class.maximized"]
    }],
    minimized: [{
      type: HostBinding,
      args: ["class.minimized"]
    }],
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent]
    }]
  });
})();
var NbWindowService = class _NbWindowService {
  constructor(componentFactoryResolver, overlayService, overlayPositionBuilder, blockScrollStrategy, defaultWindowsConfig, cfr, document2) {
    this.componentFactoryResolver = componentFactoryResolver;
    this.overlayService = overlayService;
    this.overlayPositionBuilder = overlayPositionBuilder;
    this.blockScrollStrategy = blockScrollStrategy;
    this.defaultWindowsConfig = defaultWindowsConfig;
    this.cfr = cfr;
    this.openWindows = [];
    this.document = document2;
  }
  /**
   * Opens new window.
   * @param windowContent
   * @param windowConfig
   * */
  open(windowContent, windowConfig = {}) {
    if (this.shouldCreateWindowsContainer()) {
      this.createWindowsContainer();
    }
    const config = new NbWindowConfig(this.defaultWindowsConfig, windowConfig);
    const windowRef = new NbWindowRef(config);
    windowRef.componentRef = this.appendWindow(windowContent, config, windowRef);
    this.openWindows.push(windowRef);
    this.subscribeToEvents(windowRef);
    return windowRef;
  }
  shouldCreateWindowsContainer() {
    if (this.windowsContainerViewRef) {
      const containerEl = this.windowsContainerViewRef.element.nativeElement;
      return !this.document.body.contains(containerEl);
    }
    return true;
  }
  createWindowsContainer() {
    if (this.overlayRef) {
      this.overlayRef.dispose();
    }
    this.overlayRef = this.overlayService.create({
      scrollStrategy: this.overlayService.scrollStrategies.noop(),
      positionStrategy: this.overlayPositionBuilder.global().bottom().right(),
      hasBackdrop: true
    });
    const windowsContainerPortal = new NbComponentPortal(NbWindowsContainerComponent, null, null, this.cfr);
    const overlayRef = this.overlayRef.attach(windowsContainerPortal);
    this.windowsContainerViewRef = overlayRef.instance.viewContainerRef;
  }
  appendWindow(content, config, windowRef) {
    const context = content instanceof TemplateRef ? {
      $implicit: config.context,
      windowRef
    } : config.context;
    const providers = [{
      provide: NB_WINDOW_CONTENT,
      useValue: content
    }, {
      provide: NB_WINDOW_CONTEXT,
      useValue: context
    }, {
      provide: NbWindowConfig,
      useValue: config
    }, {
      provide: NbWindowRef,
      useValue: windowRef
    }];
    const parentInjector = config.viewContainerRef ? config.viewContainerRef.injector : this.windowsContainerViewRef.injector;
    const injector = Injector.create({
      parent: parentInjector,
      providers
    });
    const windowFactory2 = this.componentFactoryResolver.resolveComponentFactory(NbWindowComponent);
    const ref = this.windowsContainerViewRef.createComponent(windowFactory2, this.windowsContainerViewRef.length, injector);
    ref.instance.cfr = this.cfr;
    ref.changeDetectorRef.detectChanges();
    return ref;
  }
  subscribeToEvents(windowRef) {
    if (windowRef.config.closeOnBackdropClick) {
      this.overlayRef.backdropClick().subscribe(() => windowRef.close());
    }
    if (windowRef.config.closeOnEsc) {
      this.overlayRef.keydownEvents().pipe(filter((event) => event.keyCode === 27)).subscribe(() => windowRef.close());
    }
    windowRef.stateChange.subscribe(() => this.checkAndUpdateOverlay());
    windowRef.onClose.subscribe(() => {
      this.openWindows.splice(this.openWindows.indexOf(windowRef), 1);
      this.checkAndUpdateOverlay();
    });
  }
  checkAndUpdateOverlay() {
    const fullScreenWindows = this.openWindows.filter((w) => w.state === NbWindowState.FULL_SCREEN);
    if (fullScreenWindows.length > 0) {
      this.blockScrollStrategy.enable();
    } else {
      this.blockScrollStrategy.disable();
    }
    if (fullScreenWindows.some((w) => w.config.hasBackdrop)) {
      this.overlayRef.backdropElement.removeAttribute("hidden");
    } else {
      this.overlayRef.backdropElement.setAttribute("hidden", "");
    }
  }
  static {
    this.ɵfac = function NbWindowService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbWindowService)(ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NbOverlayService), ɵɵinject(NbOverlayPositionBuilder), ɵɵinject(NbBlockScrollStrategyAdapter), ɵɵinject(NB_WINDOW_CONFIG), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NB_DOCUMENT));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbWindowService,
      factory: _NbWindowService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowService, [{
    type: Injectable
  }], () => [{
    type: ComponentFactoryResolver$1
  }, {
    type: NbOverlayService
  }, {
    type: NbOverlayPositionBuilder
  }, {
    type: NbBlockScrollStrategyAdapter
  }, {
    type: NbWindowConfig,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONFIG]
    }]
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbWindowModule = class _NbWindowModule {
  static forRoot(defaultConfig) {
    return {
      ngModule: _NbWindowModule,
      providers: [NbWindowService, {
        provide: NB_WINDOW_CONFIG,
        useValue: defaultConfig
      }]
    };
  }
  static forChild(defaultConfig) {
    return {
      ngModule: _NbWindowModule,
      providers: [NbWindowService, {
        provide: NB_WINDOW_CONFIG,
        useValue: defaultConfig
      }]
    };
  }
  static {
    this.ɵfac = function NbWindowModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbWindowModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbWindowModule,
      declarations: [NbWindowsContainerComponent, NbWindowComponent],
      imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule],
      declarations: [NbWindowsContainerComponent, NbWindowComponent]
    }]
  }], null, null);
})();
var NbTimePickerDirective = class _NbTimePickerDirective {
  /**
   * Provides timepicker component.
   * */
  get timepicker() {
    return this._timePickerComponent;
  }
  set timepicker(timePicker) {
    this._timePickerComponent = timePicker;
    this.pickerInputsChangedSubscription?.unsubscribe();
    this.pickerInputsChangedSubscription = this._timePickerComponent.timepickerFormatChange$.pipe(map(() => this._timePickerComponent.computedTimeFormat), startWith(this._timePickerComponent.computedTimeFormat), distinctUntilChanged(), pairwise(), takeUntil(this.destroy$)).subscribe(([prevFormat, nextFormat]) => {
      if (this.inputValue) {
        const date = this.dateService.parse(this.inputValue, prevFormat);
        this.writeValue(date);
      }
    });
  }
  /**
   * Returns html input element.
   * @docs-private
   * */
  get input() {
    return this.hostRef.nativeElement;
  }
  /**
   * Determines is timepicker overlay opened.
   * @docs-private
   * */
  get isOpen() {
    return this.overlayRef && this.overlayRef.hasAttached();
  }
  /**
   * Determines is timepicker overlay closed.
   * @docs-private
   * */
  get isClosed() {
    return !this.isOpen;
  }
  constructor(document2, positionBuilder, hostRef, triggerStrategyBuilder, overlay, cd, calendarTimeModelService, dateService, renderer, placeholder) {
    this.document = document2;
    this.positionBuilder = positionBuilder;
    this.hostRef = hostRef;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.overlay = overlay;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
    this.dateService = dateService;
    this.renderer = renderer;
    this.placeholder = placeholder;
    this.overlayOffset = 8;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
  }
  /**
   * Returns host input value.
   * @docs-private
   * */
  get inputValue() {
    return this.input.value;
  }
  set inputValue(value) {
    this.input.value = value;
  }
  ngAfterViewInit() {
    this.subscribeOnInputChange();
    if (!this.placeholder) {
      this.renderer.setProperty(this.input, "placeholder", this.timepicker.computedTimeFormat);
    }
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnTriggers();
    this.subscribeToBlur();
  }
  show() {
    if (this.isClosed) {
      this.attachToOverlay();
    }
  }
  hide() {
    if (this.isOpen) {
      this.overlayRef.detach();
      this.cd.markForCheck();
    }
  }
  /**
   * Attaches picker to the timepicker portal.
   * @docs-private
   * */
  attachToOverlay() {
    if (!this.overlayRef) {
      this.setupTimepicker();
      this.initOverlay();
    }
    this.overlayRef.attach(this.timepicker.portal);
  }
  setupTimepicker() {
    if (this.dateService.getId() === "native" && isDevMode()) {
      console.warn("Date.parse does not support parsing time with custom format. See details here https://akveo.github.io/nebular/docs/components/datepicker/overview#native-parse-issue");
    }
    this.timepicker.setHost(this.hostRef);
    if (this.inputValue) {
      const val = this.dateService.getId() === "native" ? this.parseNativeDateString(this.inputValue) : this.inputValue;
      this.timepicker.date = this.dateService.parse(val, this.timepicker.computedTimeFormat);
    } else {
      this.timepicker.date = this.calendarTimeModelService.getResetTime();
    }
  }
  initOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.subscribeOnApplyClick();
    this.createOverlay();
  }
  subscribeOnApplyClick() {
    this.timepicker.onSelectTime.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      const time = this.dateService.format(value.time, this.timepicker.computedTimeFormat).toUpperCase();
      this.inputValue = time;
      this.timepicker.date = value.time;
      this.onChange(value.time);
      if (value.save) {
        this.lastInputValue = time;
        this.hide();
      }
    });
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.overlayRef = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy
    });
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.pipe(filter(() => this.isClosed)).subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(() => {
      this.inputValue = this.lastInputValue || "";
      this.hide();
    });
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(NbAdjustment.COUNTERCLOCKWISE);
  }
  getContainer() {
    return this.overlayRef && this.isOpen && {
      location: {
        nativeElement: this.overlayRef.overlayElement
      }
    };
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies.block();
  }
  subscribeOnInputChange() {
    fromEvent(this.input, "input").pipe(map(() => this.inputValue), takeUntil(this.destroy$)).subscribe((value) => this.handleInputChange(value));
  }
  subscribeToBlur() {
    merge(this.timepicker.blur, fromEvent(this.input, "blur").pipe(filter(() => !this.isOpen && this.document.activeElement !== this.input))).pipe(takeUntil(this.destroy$)).subscribe(() => this.onTouched());
  }
  /**
   * Parses input value and write if it isn't null.
   * @docs-private
   * */
  handleInputChange(value) {
    if (this.dateService.getId() === "native") {
      value = this.parseNativeDateString(value);
    }
    const isValidDate = this.dateService.isValidDateString(value, this.timepicker.computedTimeFormat);
    if (isValidDate) {
      this.lastInputValue = value;
      const date = this.dateService.parse(value, this.timepicker.computedTimeFormat);
      this.onChange(date);
      this.timepicker.date = date;
    }
  }
  updateValue(value) {
    if (value) {
      this.timepicker.date = value;
      const timeString = this.dateService.format(value, this.timepicker.computedTimeFormat).toUpperCase();
      this.inputValue = timeString;
      this.lastInputValue = timeString;
    }
  }
  writeValue(value) {
    this.updateValue(value);
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.input.disabled = isDisabled;
  }
  parseNativeDateString(value) {
    const date = this.dateService.today();
    const year = this.dateService.getYear(date);
    const month = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getMonth(date));
    const day = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getDate(date));
    return `${year}-${month}-${day} ${value}`;
  }
  static {
    this.ɵfac = function NbTimePickerDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTimePickerDirective)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbCalendarTimeModelService), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(Renderer2), ɵɵinjectAttribute("placeholder"));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTimePickerDirective,
      selectors: [["input", "nbTimepicker", ""]],
      inputs: {
        timepicker: [0, "nbTimepicker", "timepicker"],
        overlayOffset: "overlayOffset"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _NbTimePickerDirective),
        multi: true
      }])]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbTimepicker]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbTimePickerDirective),
        multi: true
      }],
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: ElementRef
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }, {
    type: NbDateService
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["placeholder"]
    }]
  }], {
    timepicker: [{
      type: Input,
      args: ["nbTimepicker"]
    }],
    overlayOffset: [{
      type: Input
    }]
  });
})();
var NbTimepickerModule = class _NbTimepickerModule {
  static forRoot(config = {}) {
    return {
      ngModule: _NbTimepickerModule,
      providers: [{
        provide: NB_TIME_PICKER_CONFIG,
        useValue: config
      }]
    };
  }
  static forChild(config = {}) {
    return {
      ngModule: _NbTimepickerModule,
      providers: [{
        provide: NB_TIME_PICKER_CONFIG,
        useValue: config
      }]
    };
  }
  static {
    this.ɵfac = function NbTimepickerModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTimepickerModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbTimepickerModule,
      declarations: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective],
      imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule],
      exports: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [NbCalendarTimeModelService],
      imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimepickerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule],
      providers: [NbCalendarTimeModelService],
      exports: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective],
      declarations: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective]
    }]
  }], null, null);
})();
var NbDateAdapterService = class _NbDateAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbDatepickerComponent;
  }
  parse(date, format) {
    return this.dateService.parse(date, format);
  }
  format(date, format) {
    return this.dateService.format(date, format);
  }
  isValid(date, format) {
    return this.dateService.isValidDateString(date, format);
  }
  static {
    this.ɵfac = function NbDateAdapterService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbDateAdapterService)(ɵɵinject(NbDateService));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbDateAdapterService,
      factory: _NbDateAdapterService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var NbRangeAdapterService = class _NbRangeAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbRangepickerComponent;
  }
  parse(range2, format) {
    const [start, end] = range2.split("-").map((subDate) => subDate.trim());
    return {
      start: this.dateService.parse(start, format),
      end: this.dateService.parse(end, format)
    };
  }
  format(range2, format) {
    if (!range2) {
      return "";
    }
    const start = this.dateService.format(range2.start, format);
    const isStartValid = this.dateService.isValidDateString(start, format);
    if (!isStartValid) {
      return "";
    }
    const end = this.dateService.format(range2.end, format);
    const isEndValid = this.dateService.isValidDateString(end, format);
    if (isEndValid) {
      return `${start} - ${end}`;
    } else {
      return start;
    }
  }
  isValid(range2, format) {
    const [start, end] = range2.split("-").map((subDate) => subDate.trim());
    return this.dateService.isValidDateString(start, format) && this.dateService.isValidDateString(end, format);
  }
  static {
    this.ɵfac = function NbRangeAdapterService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbRangeAdapterService)(ɵɵinject(NbDateService));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbRangeAdapterService,
      factory: _NbRangeAdapterService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRangeAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var NbDateTimeAdapterService = class _NbDateTimeAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbDateTimePickerComponent;
  }
  parse(date, format) {
    return this.dateService.parse(date, format);
  }
  format(date, format) {
    return this.dateService.format(date, format);
  }
  isValid(date, format) {
    return this.dateService.isValidDateString(date, format);
  }
  static {
    this.ɵfac = function NbDateTimeAdapterService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbDateTimeAdapterService)(ɵɵinject(NbDateService));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbDateTimeAdapterService,
      factory: _NbDateTimeAdapterService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateTimeAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var NbDatepickerModule = class _NbDatepickerModule {
  static forRoot() {
    return {
      ngModule: _NbDatepickerModule,
      providers: [DatePipe, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbDateAdapterService
      }, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbRangeAdapterService
      }, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbDateTimeAdapterService
      }]
    };
  }
  static {
    this.ɵfac = function NbDatepickerModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbDatepickerModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbDatepickerModule,
      declarations: [NbDatepickerDirective, NbDatepickerContainerComponent, NbCalendarWithTimeComponent, NbDateTimePickerComponent, NbDatepickerComponent, NbRangepickerComponent, NbBasePickerComponent],
      imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule],
      exports: [NbDatepickerDirective, NbDatepickerComponent, NbRangepickerComponent, NbDateTimePickerComponent, NbCalendarWithTimeComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerModule, [{
    type: NgModule,
    args: [{
      imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule],
      exports: [NbDatepickerDirective, NbDatepickerComponent, NbRangepickerComponent, NbDateTimePickerComponent, NbCalendarWithTimeComponent],
      declarations: [NbDatepickerDirective, NbDatepickerContainerComponent, NbCalendarWithTimeComponent, NbDateTimePickerComponent, NbDatepickerComponent, NbRangepickerComponent, NbBasePickerComponent]
    }]
  }], null, null);
})();
var NbRadioComponent = class _NbRadioComponent {
  get name() {
    return this._name;
  }
  set name(value) {
    if (this._name !== value) {
      this._name = value;
    }
  }
  get checked() {
    return this._checked;
  }
  set checked(value) {
    const boolValue = convertToBoolProperty(value);
    if (this._checked !== boolValue) {
      this._checked = boolValue;
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (this._value !== value) {
      this._value = value;
    }
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(disabled) {
    const boolValue = convertToBoolProperty(disabled);
    if (this._disabled !== boolValue) {
      this._disabled = boolValue;
    }
  }
  constructor(cd, renderer, statusService) {
    this.cd = cd;
    this.renderer = renderer;
    this.statusService = statusService;
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this.valueChange = new EventEmitter();
    this.blur = new EventEmitter();
  }
  get isPrimary() {
    return this.status === "primary";
  }
  get isSuccess() {
    return this.status === "success";
  }
  get isWarning() {
    return this.status === "warning";
  }
  get isDanger() {
    return this.status === "danger";
  }
  get isInfo() {
    return this.status === "info";
  }
  get isBasic() {
    return this.status === "basic";
  }
  get isControl() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  onChange(event) {
    event.stopPropagation();
    this.checked = true;
    this.valueChange.emit(this.value);
  }
  onClick(event) {
    event.stopPropagation();
  }
  /*
   * @docs-private
   * We use this method when setting radio inputs from radio group component.
   * Otherwise Angular won't detect changes in radio template as cached last rendered
   * value didn't updated.
   **/
  _markForCheck() {
    this.cd.markForCheck();
  }
  /*
   * @docs-private
   * Use this method when setting radio name from radio group component.
   * In case option 'name' isn't set on nb-radio component we need to set name
   * right away, so it won't overlap with options without names from other radio
   * groups. Otherwise they all would have same name and will be considered as
   * options from one group so only the last option will stay selected.
   **/
  _setName(name) {
    this.name = name;
    if (this.input) {
      this.renderer.setProperty(this.input.nativeElement, "name", name);
    }
  }
  static {
    this.ɵfac = function NbRadioComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbRadioComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbRadioComponent,
      selectors: [["nb-radio"]],
      viewQuery: function NbRadioComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c51, 5, ElementRef);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
        }
      },
      hostVars: 16,
      hostBindings: function NbRadioComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("status-primary", ctx.isPrimary)("status-success", ctx.isSuccess)("status-warning", ctx.isWarning)("status-danger", ctx.isDanger)("status-info", ctx.isInfo)("status-basic", ctx.isBasic)("status-control", ctx.isControl);
        }
      },
      inputs: {
        name: "name",
        checked: "checked",
        value: "value",
        disabled: "disabled",
        status: "status"
      },
      outputs: {
        valueChange: "valueChange",
        blur: "blur"
      },
      standalone: false,
      ngContentSelectors: _c03,
      decls: 7,
      vars: 4,
      consts: [["input", ""], ["type", "radio", 1, "native-input", "visually-hidden", 3, "change", "click", "name", "value", "checked", "disabled"], [1, "outer-circle"], [1, "inner-circle"], [1, "text"]],
      template: function NbRadioComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵprojectionDef();
          ɵɵelementStart(0, "label")(1, "input", 1, 0);
          ɵɵlistener("change", function NbRadioComponent_Template_input_change_1_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.onChange($event));
          })("click", function NbRadioComponent_Template_input_click_1_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.onClick($event));
          });
          ɵɵelementEnd();
          ɵɵelement(3, "span", 2)(4, "span", 3);
          ɵɵelementStart(5, "span", 4);
          ɵɵprojection(6);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("name", ctx.name)("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
        }
      },
      styles: ["[_nghost-%COMP%]{display:block;position:relative}[_nghost-%COMP%]   label[_ngcontent-%COMP%]{display:inline-flex;margin:0;min-height:inherit;padding:.375rem 0;align-items:center}[dir=ltr]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-right:1.5rem}[dir=rtl]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-left:1.5rem}[_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=ltr]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{left:0}[dir=rtl]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{right:0}[_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{transform:translateY(-50%) scale(.6)}[dir=ltr]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-right:.5rem}\n\n\n\n\n\n\n\n\n\n\n\n"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioComponent, [{
    type: Component,
    args: [{
      selector: "nb-radio",
      template: `
    <label>
      <input
        #input
        type="radio"
        class="native-input visually-hidden"
        [name]="name"
        [value]="value"
        [checked]="checked"
        [disabled]="disabled"
        (change)="onChange($event)"
        (click)="onClick($event)">
      <span class="outer-circle"></span>
      <span class="inner-circle"></span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:block;position:relative}:host label{display:inline-flex;margin:0;min-height:inherit;padding:.375rem 0;align-items:center}[dir=ltr] :host label{padding-right:1.5rem}[dir=rtl] :host label{padding-left:1.5rem}:host .outer-circle,:host .inner-circle{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] :host .outer-circle,[dir=ltr] :host .inner-circle{left:0}[dir=rtl] :host .outer-circle,[dir=rtl] :host .inner-circle{right:0}:host .inner-circle{transform:translateY(-50%) scale(.6)}[dir=ltr] :host .text{padding-left:.5rem}[dir=rtl] :host .text{padding-right:.5rem}\n/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NbStatusService
  }], {
    name: [{
      type: Input
    }],
    checked: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    blur: [{
      type: Output
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        read: ElementRef
      }]
    }],
    isPrimary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    isSuccess: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    isWarning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    isDanger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    isInfo: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    isBasic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    isControl: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NbRadioGroupComponent = class _NbRadioGroupComponent {
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.updateValues();
  }
  get name() {
    return this._name;
  }
  set name(name) {
    this._name = name;
    this.updateNames();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(disabled) {
    this._disabled = convertToBoolProperty(disabled);
    this.updateDisabled();
  }
  /**
   * Radio buttons status.
   * Possible values are `primary` (default), `success`, `warning`, `danger`, `info`.
   */
  get status() {
    return this._status;
  }
  set status(value) {
    if (this._status !== value) {
      this._status = value;
      this.updateStatus();
    }
  }
  constructor(hostElement, platformId, document2) {
    this.hostElement = hostElement;
    this.platformId = platformId;
    this.document = document2;
    this.destroy$ = new Subject();
    this.onChange = (value) => {
    };
    this.onTouched = () => {
    };
    this._status = "basic";
    this.valueChange = new EventEmitter();
  }
  ngAfterContentInit() {
    this.updateNames();
    this.radios.changes.pipe(
      startWith(this.radios),
      // 'changes' emit during change detection run and we can't update
      // option properties right of since they already was initialized.
      // Instead we schedule microtask to update radios after change detection
      // run is finished and trigger one more change detection run.
      switchMap((radios) => from(Promise.resolve(radios))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.updateAndSubscribeToRadios());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(value) {
    this.value = value;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  updateAndSubscribeToRadios() {
    this.updateValueFromCheckedOption();
    this.updateNames();
    this.updateValues();
    this.updateDisabled();
    this.updateStatus();
    this.subscribeOnRadiosValueChange();
    this.subscribeOnRadiosBlur();
  }
  updateNames() {
    if (this.radios) {
      this.radios.forEach((radio) => radio._setName(this.name));
    }
  }
  updateValues() {
    this.updateAndMarkForCheckRadios((radio) => radio.checked = radio.value === this.value);
  }
  updateDisabled() {
    if (typeof this.disabled !== "undefined") {
      this.updateAndMarkForCheckRadios((radio) => radio.disabled = this.disabled);
    }
  }
  subscribeOnRadiosValueChange() {
    if (!this.radios || !this.radios.length) {
      return;
    }
    merge(...this.radios.map((radio) => radio.valueChange)).pipe(takeUntil(merge(this.radios.changes, this.destroy$))).subscribe((value) => {
      this.writeValue(value);
      this.propagateValue(value);
    });
  }
  propagateValue(value) {
    this.valueChange.emit(value);
    this.onChange(value);
  }
  subscribeOnRadiosBlur() {
    const hasNoRadios = !this.radios || !this.radios.length;
    if (!isPlatformBrowser(this.platformId) || hasNoRadios) {
      return;
    }
    const hostElement = this.hostElement.nativeElement;
    fromEvent(hostElement, "focusin").pipe(filter((event) => hostElement.contains(event.target)), switchMap(() => merge(fromEvent(this.document, "focusin"), fromEvent(this.document, "click"))), filter((event) => !hostElement.contains(event.target)), takeUntil(merge(this.radios.changes, this.destroy$))).subscribe(() => this.onTouched());
  }
  updateStatus() {
    this.updateAndMarkForCheckRadios((radio) => radio.status = this.status);
  }
  updateAndMarkForCheckRadios(updateFn) {
    if (this.radios) {
      this.radios.forEach((radio) => {
        updateFn(radio);
        radio._markForCheck();
      });
    }
  }
  updateValueFromCheckedOption() {
    const checkedRadio = this.radios.find((radio) => radio.checked);
    const isValueMissing = this.value === void 0 || this.value === null;
    if (checkedRadio && isValueMissing && checkedRadio.value !== this.value) {
      this.value = checkedRadio.value;
    }
  }
  static {
    this.ɵfac = function NbRadioGroupComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbRadioGroupComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NB_DOCUMENT));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbRadioGroupComponent,
      selectors: [["nb-radio-group"]],
      contentQueries: function NbRadioGroupComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbRadioComponent, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radios = _t);
        }
      },
      inputs: {
        value: "value",
        name: "name",
        disabled: "disabled",
        status: "status"
      },
      outputs: {
        valueChange: "valueChange"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _NbRadioGroupComponent),
        multi: true
      }])],
      ngContentSelectors: _c53,
      decls: 1,
      vars: 0,
      template: function NbRadioGroupComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c52);
          ɵɵprojection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-radio-group",
      template: `
    <ng-content select="nb-radio"></ng-content>`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbRadioGroupComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], {
    value: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    radios: [{
      type: ContentChildren,
      args: [NbRadioComponent, {
        descendants: true
      }]
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var NbRadioModule = class _NbRadioModule {
  static {
    this.ɵfac = function NbRadioModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbRadioModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbRadioModule,
      declarations: [NbRadioComponent, NbRadioGroupComponent],
      exports: [NbRadioComponent, NbRadioGroupComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioModule, [{
    type: NgModule,
    args: [{
      imports: [],
      exports: [NbRadioComponent, NbRadioGroupComponent],
      declarations: [NbRadioComponent, NbRadioGroupComponent]
    }]
  }], null, null);
})();
var tagUniqueId = 0;
var NbTagComponent = class _NbTagComponent {
  get destroy$() {
    return this._destroy$.asObservable();
  }
  get selected() {
    return this._selected;
  }
  set selected(value) {
    if (this.selected !== convertToBoolProperty(value)) {
      this._selected = !this.selected;
      this.selectedChange.emit({
        tag: this,
        selected: this.selected
      });
    }
  }
  /**
   * Controls whether the user can remove a tag or not.
   */
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = convertToBoolProperty(value);
  }
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  get basic() {
    return this.status === "basic";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get control() {
    return this.status === "control";
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  _remove() {
    if (this.removable) {
      this.remove.emit(this);
    }
  }
  constructor(_hostElement, cd, renderer, zone, statusService) {
    this._hostElement = _hostElement;
    this.cd = cd;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this._destroy$ = new Subject();
    this._selected = false;
    this._removable = false;
    this.appearance = "filled";
    this.status = "basic";
    this.size = "medium";
    this.role = "option";
    this.remove = new EventEmitter();
    this.selectedChange = new EventEmitter();
    this._isActive = false;
    this._id = `nb-tag-${tagUniqueId++}`;
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this._hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this._destroy$.next(this);
  }
  _toggleSelection() {
    this.selected = !this.selected;
    this.cd.markForCheck();
  }
  setActiveStyles() {
    if (!this._isActive) {
      this._isActive = true;
      this.cd.markForCheck();
    }
  }
  setInactiveStyles() {
    if (this._isActive) {
      this._isActive = false;
      this.cd.markForCheck();
    }
  }
  static {
    this.ɵfac = function NbTagComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTagComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTagComponent,
      selectors: [["nb-tag"]],
      hostVars: 37,
      hostBindings: function NbTagComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("keydown.delete", function NbTagComponent_keydown_delete_HostBindingHandler() {
            return ctx._remove();
          })("keydown.backspace", function NbTagComponent_keydown_backspace_HostBindingHandler() {
            return ctx._remove();
          });
        }
        if (rf & 2) {
          ɵɵattribute("aria-selected", ctx.selected)("role", ctx.role)("id", ctx._id);
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("selected", ctx.selected)("active", ctx._isActive)("appearance-filled", ctx.filled)("appearance-outline", ctx.outline)("status-basic", ctx.basic)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-control", ctx.control)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
        }
      },
      inputs: {
        text: "text",
        selected: "selected",
        removable: "removable",
        appearance: "appearance",
        status: "status",
        size: "size",
        role: "role"
      },
      outputs: {
        remove: "remove",
        selectedChange: "selectedChange"
      },
      exportAs: ["nbTag"],
      standalone: false,
      decls: 2,
      vars: 2,
      consts: [["icon", "close-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "class", "click", 4, "ngIf"], ["icon", "close-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"]],
      template: function NbTagComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtext(0);
          ɵɵtemplate(1, NbTagComponent_nb_icon_1_Template, 1, 3, "nb-icon", 0);
        }
        if (rf & 2) {
          ɵɵtextInterpolate1("", ctx.text, "\n");
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.removable);
        }
      },
      dependencies: [NgIf, NbIconComponent],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagComponent, [{
    type: Component,
    args: [{
      selector: "nb-tag",
      exportAs: "nbTag",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '{{ text }}\n<nb-icon *ngIf="removable"\n         (click)="_remove()"\n         class="nb-tag-remove size-{{size}}"\n         icon="close-outline"\n         pack="nebular-essentials"\n         aria-hidden="true">\n</nb-icon>\n'
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    text: [{
      type: Input
    }],
    selected: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.selected"]
    }, {
      type: HostBinding,
      args: ["attr.aria-selected"]
    }],
    removable: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }],
    remove: [{
      type: Output
    }],
    selectedChange: [{
      type: Output
    }],
    _isActive: [{
      type: HostBinding,
      args: ["class.active"]
    }],
    _id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    filled: [{
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    outline: [{
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    _remove: [{
      type: HostListener,
      args: ["keydown.delete"]
    }, {
      type: HostListener,
      args: ["keydown.backspace"]
    }]
  });
})();
var NbTagInputDirective = class _NbTagInputDirective extends NbInputDirective {
  get _value() {
    return this._hostElement.nativeElement.value;
  }
  _onKeydown(event) {
    this.keyDown$.next(event);
  }
  constructor(_hostElement, focusMonitor, renderer, zone, statusService) {
    super(_hostElement, focusMonitor, renderer, zone, statusService);
    this._hostElement = _hostElement;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.keyDown$ = new Subject();
    this.separatorKeys = [ENTER];
    this.tagAdd = new EventEmitter();
    this.nbTagInputClass = true;
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    this.keyDown$.pipe(filter(({
      keyCode
    }) => this.isSeparatorKey(keyCode)), map(() => this._value), takeUntil(this.destroy$)).subscribe((value) => this.tagAdd.emit({
      value,
      input: this._hostElement
    }));
  }
  isSeparatorKey(keyCode) {
    return this.separatorKeys.includes(keyCode);
  }
  static {
    this.ɵfac = function NbTagInputDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTagInputDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTagInputDirective,
      selectors: [["input", "nbTagInput", ""]],
      hostVars: 2,
      hostBindings: function NbTagInputDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("keydown", function NbTagInputDirective_keydown_HostBindingHandler($event) {
            return ctx._onKeydown($event);
          });
        }
        if (rf & 2) {
          ɵɵclassProp("nb-tag-input", ctx.nbTagInputClass);
        }
      },
      inputs: {
        separatorKeys: "separatorKeys"
      },
      outputs: {
        tagAdd: "tagAdd"
      },
      exportAs: ["nbTagInput"],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbFormFieldControl,
        useExisting: _NbTagInputDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagInputDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbTagInput]",
      exportAs: "nbTagInput",
      providers: [{
        provide: NbFormFieldControl,
        useExisting: NbTagInputDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    separatorKeys: [{
      type: Input
    }],
    tagAdd: [{
      type: Output
    }],
    nbTagInputClass: [{
      type: HostBinding,
      args: ["class.nb-tag-input"]
    }],
    _onKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var NbTagListComponent = class _NbTagListComponent {
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  get _hasInput() {
    return !!this.tagInput;
  }
  get _isFocused() {
    return this.focused;
  }
  get _isFullWidth() {
    return !!this.tagInput?.fullWidth;
  }
  get _inputClasses() {
    if (this._hasInput) {
      return [`shape-${this.tagInput.shape}`, `size-${this.tagInput.fieldSize}`, this.statusService.getStatusClass(this.tagInput.status)];
    }
    return [`size-${this.size}`];
  }
  _onKeydown(event) {
    this.keyDown$.next(event);
  }
  _onClick({
    target
  }) {
    const clickedTag = this.tags.find((tag) => tag._hostElement.nativeElement === target);
    if (clickedTag) {
      this.tagClick$.next(clickedTag);
    }
  }
  constructor(hostElement, cd, renderer, zone, focusMonitor, activeDescendantKeyManagerFactory, directionService, statusService) {
    this.hostElement = hostElement;
    this.cd = cd;
    this.renderer = renderer;
    this.zone = zone;
    this.focusMonitor = focusMonitor;
    this.activeDescendantKeyManagerFactory = activeDescendantKeyManagerFactory;
    this.directionService = directionService;
    this.statusService = statusService;
    this.destroy$ = new Subject();
    this.keyDown$ = new Subject();
    this.tagClick$ = new Subject();
    this.focused = false;
    this.size = "medium";
    this.tabIndex = 0;
    this.role = "listbox";
    this._multiple = false;
    this.activeTagId = null;
    this.tagRemove = new EventEmitter();
  }
  ngOnInit() {
    this.focusMonitor.monitor(this.hostElement, true).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.hostElement)), takeUntil(this.destroy$)).subscribe((isFocused) => this.onFocusChange(isFocused));
  }
  ngAfterContentInit() {
    this.initKeyManager();
    this.setAutocompleteCustomHost();
  }
  ngAfterViewInit() {
    this.listenToLayoutDirectionChange();
    this.listenListKeyDown();
    this.listenInputKeyDown();
    this.listenTagClick();
    this.listenTagRemove();
    this.listenTagDestroy();
    this.listenActiveTagChange();
    this.listenNoTags();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  initKeyManager() {
    this.keyManager = this.activeDescendantKeyManagerFactory.create(this.tags).withHorizontalOrientation(this.directionService.getDirection()).withWrap();
  }
  listenToLayoutDirectionChange() {
    this.directionService.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe((direction) => this.keyManager.withHorizontalOrientation(direction));
  }
  listenListKeyDown() {
    const tagListKeyDown$ = this.keyDown$.pipe(filter(({
      target
    }) => target === this.hostElement.nativeElement));
    const activeTagKeyDown$ = tagListKeyDown$.pipe(filter(() => !!this.keyManager.activeItem));
    tagListKeyDown$.pipe(takeUntil(this.destroy$)).subscribe((event) => this.keyManager.onKeydown(event));
    activeTagKeyDown$.pipe(filter(({
      keyCode
    }) => keyCode === SPACE), takeUntil(this.destroy$)).subscribe((event) => {
      this.toggleTag(this.keyManager.activeItem);
      event.preventDefault();
    });
    activeTagKeyDown$.pipe(filter(({
      keyCode
    }) => this.isBackspaceOrDelete(keyCode)), map(() => this.keyManager.activeItem), takeUntil(this.destroy$)).subscribe((tagToRemove) => tagToRemove._remove());
  }
  listenInputKeyDown() {
    const inputKeyDown$ = this.keyDown$.pipe(filter(({
      target
    }) => target === this.tagInput?._hostElement.nativeElement));
    inputKeyDown$.pipe(filter(({
      keyCode
    }) => {
      return this.tagInput._value === "" && this.isBackspaceOrDelete(keyCode) && this.tags.length > 0;
    }), takeUntil(this.destroy$)).subscribe(() => {
      this.hostElement.nativeElement.focus();
      this.keyManager.setLastItemActive();
      this.cd.markForCheck();
    });
  }
  listenTagClick() {
    this.tagClick$.pipe(takeUntil(this.destroy$)).subscribe((clickedTag) => {
      this.toggleTag(clickedTag);
      this.keyManager.setActiveItem(clickedTag);
    });
  }
  listenTagRemove() {
    this.tags.changes.pipe(startWith(this.tags), switchMap((tags) => merge(...tags.map((tag) => tag.remove))), takeUntil(this.destroy$)).subscribe((tagToRemove) => this.tagRemove.emit(tagToRemove));
  }
  listenTagDestroy() {
    this.tags.changes.pipe(startWith(this.tags), switchMap((tags) => merge(...tags.map((tag) => tag.destroy$))), filter((destroyedTag) => destroyedTag === this.keyManager.activeItem), map((destroyedTag) => destroyedTag === this.tags.last), takeUntil(this.destroy$)).subscribe((isLastTagDestroyed) => {
      if (isLastTagDestroyed) {
        this.keyManager.setPreviousItemActive();
      } else {
        this.keyManager.setNextItemActive();
      }
    });
  }
  listenNoTags() {
    this.tags.changes.pipe(startWith(this.tags), filter((tags) => tags.length === 0), takeUntil(this.destroy$)).subscribe(() => this.focusInputIfActive());
  }
  listenActiveTagChange() {
    this.keyManager.change.pipe(map(() => this.keyManager.activeItem?._id), takeUntil(this.destroy$)).subscribe((activeTagId) => {
      this.activeTagId = activeTagId;
      this.cd.markForCheck();
    });
  }
  onFocusChange(isFocused) {
    this.focused = isFocused;
    this.cd.markForCheck();
    if (!isFocused || this.tagInput?.focused$.value) {
      this.keyManager?.setActiveItem(-1);
      return;
    }
    if (this.tags.length === 0 && this._hasInput) {
      this.focusInput();
    } else {
      this.keyManager.setFirstItemActive();
    }
  }
  isBackspaceOrDelete(keyCode) {
    return keyCode === BACKSPACE || keyCode === DELETE;
  }
  setAutocompleteCustomHost() {
    if (this.autocompleteDirective) {
      this.autocompleteDirective.customOverlayHost = this.hostElement;
    }
  }
  toggleTag(tagToToggle) {
    tagToToggle._toggleSelection();
    if (tagToToggle.selected && !this.multiple) {
      this.tags.forEach((tag) => {
        if (tag !== tagToToggle) {
          tag.selected = false;
        }
      });
    }
  }
  focusInput() {
    if (this._hasInput) {
      this.tagInput._hostElement.nativeElement.focus();
    }
  }
  focusInputIfActive() {
    if (this._isFocused) {
      this.focusInput();
    }
  }
  static {
    this.ɵfac = function NbTagListComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTagListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(NbActiveDescendantKeyManagerFactoryService), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTagListComponent,
      selectors: [["nb-tag-list"]],
      contentQueries: function NbTagListComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbTagInputDirective, 5);
          ɵɵcontentQuery(dirIndex, NbAutocompleteDirective, 5);
          ɵɵcontentQuery(dirIndex, NbTagComponent, 4);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagInput = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.autocompleteDirective = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tags = _t);
        }
      },
      hostVars: 12,
      hostBindings: function NbTagListComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("keydown", function NbTagListComponent_keydown_HostBindingHandler($event) {
            return ctx._onKeydown($event);
          })("click", function NbTagListComponent_click_HostBindingHandler($event) {
            return ctx._onClick($event);
          });
        }
        if (rf & 2) {
          ɵɵattribute("tabindex", ctx.tabIndex)("role", ctx.role)("aria-multiselectable", ctx.multiple)("aria-activedescendant", ctx.activeTagId);
          ɵɵclassMap(ctx._inputClasses);
          ɵɵclassProp("nb-tag-list-with-input", ctx._hasInput)("focus", ctx._isFocused)("input-full-width", ctx._isFullWidth);
        }
      },
      inputs: {
        size: "size",
        tabIndex: "tabIndex",
        role: "role",
        multiple: "multiple"
      },
      outputs: {
        tagRemove: "tagRemove"
      },
      exportAs: ["nbTagList"],
      standalone: false,
      ngContentSelectors: _c55,
      decls: 2,
      vars: 0,
      consts: [[1, "nb-tag-list-tags-wrapper"]],
      template: function NbTagListComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c54);
          ɵɵelementStart(0, "div", 0);
          ɵɵprojection(1);
          ɵɵelementEnd();
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagListComponent, [{
    type: Component,
    args: [{
      selector: "nb-tag-list",
      template: `
    <div class="nb-tag-list-tags-wrapper">
      <ng-content select="nb-tag, input[nbTagInput]"></ng-content>
    </div>
  `,
      exportAs: "nbTagList",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbFocusMonitor
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbStatusService
  }], {
    tags: [{
      type: ContentChildren,
      args: [NbTagComponent]
    }],
    tagInput: [{
      type: ContentChild,
      args: [NbTagInputDirective]
    }],
    autocompleteDirective: [{
      type: ContentChild,
      args: [NbAutocompleteDirective]
    }],
    size: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }],
    multiple: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-multiselectable"]
    }],
    activeTagId: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    tagRemove: [{
      type: Output
    }],
    _hasInput: [{
      type: HostBinding,
      args: ["class.nb-tag-list-with-input"]
    }],
    _isFocused: [{
      type: HostBinding,
      args: ["class.focus"]
    }],
    _isFullWidth: [{
      type: HostBinding,
      args: ["class.input-full-width"]
    }],
    _inputClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    _onKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    _onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var NbTagModule = class _NbTagModule {
  static {
    this.ɵfac = function NbTagModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTagModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbTagModule,
      declarations: [NbTagComponent, NbTagListComponent, NbTagInputDirective],
      imports: [CommonModule, NbIconModule],
      exports: [NbTagComponent, NbTagListComponent, NbTagInputDirective]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CommonModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      declarations: [NbTagComponent, NbTagListComponent, NbTagInputDirective],
      exports: [NbTagComponent, NbTagListComponent, NbTagInputDirective]
    }]
  }], null, null);
})();
var NB_DEFAULT_ROW_LEVEL = 0;
var NbTreeGridPresentationNode = class {
  constructor(data, children, expanded, level) {
    this.data = data;
    this.children = children;
    this.expanded = expanded;
    this.level = level;
  }
  /**
   * True if row has child rows
   */
  hasChildren() {
    return !!this.children && !!this.children.length;
  }
};
var NbTreeGridFilterService = class _NbTreeGridFilterService {
  filter(query2, data) {
    if (!query2) {
      return data;
    }
    return data.reduce((filtered, node) => {
      let filteredChildren;
      if (node.children) {
        filteredChildren = this.filter(query2, node.children);
        node.children = filteredChildren;
      }
      node.expanded = false;
      if (filteredChildren && filteredChildren.length) {
        node.expanded = true;
        filtered.push(node);
      } else if (this.filterPredicate(node.data, query2)) {
        filtered.push(node);
      }
      return filtered;
    }, []);
  }
  filterPredicate(data, searchQuery) {
    const preparedQuery = searchQuery.trim().toLocaleLowerCase();
    for (const val of Object.values(data)) {
      const preparedVal = `${val}`.trim().toLocaleLowerCase();
      if (preparedVal.includes(preparedQuery)) {
        return true;
      }
    }
    return false;
  }
  static {
    this.ɵfac = function NbTreeGridFilterService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridFilterService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbTreeGridFilterService,
      factory: _NbTreeGridFilterService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFilterService, [{
    type: Injectable
  }], null, null);
})();
var NbSortDirection;
(function(NbSortDirection2) {
  NbSortDirection2["ASCENDING"] = "asc";
  NbSortDirection2["DESCENDING"] = "desc";
  NbSortDirection2["NONE"] = "";
})(NbSortDirection || (NbSortDirection = {}));
var sortDirections = [NbSortDirection.ASCENDING, NbSortDirection.DESCENDING, NbSortDirection.NONE];
var NbSortDirective = class _NbSortDirective {
  constructor() {
    this.sort = new EventEmitter();
  }
  emitSort(sortRequest) {
    if (this.sortable && this.sortable.sort) {
      this.sortable.sort(sortRequest);
    }
    this.sort.emit(sortRequest);
  }
  static {
    this.ɵfac = function NbSortDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSortDirective)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbSortDirective,
      selectors: [["", "nbSort", ""]],
      inputs: {
        sortable: [0, "nbSort", "sortable"]
      },
      outputs: {
        sort: "sort"
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSort]",
      standalone: false
    }]
  }], null, {
    sortable: [{
      type: Input,
      args: ["nbSort"]
    }],
    sort: [{
      type: Output
    }]
  });
})();
var NbSortHeaderIconDirective = class _NbSortHeaderIconDirective {
  static {
    this.ɵfac = function NbSortHeaderIconDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSortHeaderIconDirective)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbSortHeaderIconDirective,
      selectors: [["", "nbSortHeaderIcon", ""]],
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortHeaderIconDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSortHeaderIcon]",
      standalone: false
    }]
  }], null, null);
})();
var NbSortIconComponent = class _NbSortIconComponent {
  constructor() {
    this.direction = NbSortDirection.NONE;
  }
  isAscending() {
    return this.direction === NbSortDirection.ASCENDING;
  }
  isDescending() {
    return this.direction === NbSortDirection.DESCENDING;
  }
  isDirectionSet() {
    return this.isAscending() || this.isDescending();
  }
  static {
    this.ɵfac = function NbSortIconComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSortIconComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbSortIconComponent,
      selectors: [["nb-sort-icon"]],
      inputs: {
        direction: "direction"
      },
      standalone: false,
      decls: 1,
      vars: 1,
      consts: [[4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
      template: function NbSortIconComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, NbSortIconComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", ctx.isDirectionSet());
        }
      },
      dependencies: [NgIf, NbIconComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortIconComponent, [{
    type: Component,
    args: [{
      selector: "nb-sort-icon",
      template: `
    <ng-container *ngIf="isDirectionSet()">
      <nb-icon *ngIf="isAscending()" icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
      <nb-icon *ngIf="isDescending()" icon="chevron-up-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </ng-container>
  `,
      standalone: false
    }]
  }], null, {
    direction: [{
      type: Input
    }]
  });
})();
var NbSortHeaderComponent = class _NbSortHeaderComponent {
  /**
   * Disable sort header
   */
  set disabled(value) {
    this.disabledValue = convertToBoolProperty(value);
  }
  get disabled() {
    return this.disabledValue;
  }
  sortIfEnabled() {
    if (!this.disabled) {
      this.sortData();
    }
  }
  constructor(sort, columnDef) {
    this.sort = sort;
    this.columnDef = columnDef;
    this.disabledValue = false;
  }
  isAscending() {
    return this.direction === NbSortDirection.ASCENDING;
  }
  isDescending() {
    return this.direction === NbSortDirection.DESCENDING;
  }
  sortData() {
    const sortRequest = this.createSortRequest();
    this.sort.emitSort(sortRequest);
  }
  getIconContext() {
    return {
      $implicit: this.direction,
      isAscending: this.isAscending(),
      isDescending: this.isDescending(),
      isNone: !this.isAscending() && !this.isDescending()
    };
  }
  getDisabledAttributeValue() {
    return this.disabled ? "" : null;
  }
  createSortRequest() {
    this.direction = this.getNextDirection();
    return {
      direction: this.direction,
      column: this.columnDef.name
    };
  }
  getNextDirection() {
    const sortDirectionCycle = sortDirections;
    let nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
    if (nextDirectionIndex >= sortDirectionCycle.length) {
      nextDirectionIndex = 0;
    }
    return sortDirectionCycle[nextDirectionIndex];
  }
  static {
    this.ɵfac = function NbSortHeaderComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbSortHeaderComponent)(ɵɵdirectiveInject(NbSortDirective), ɵɵdirectiveInject(NB_SORT_HEADER_COLUMN_DEF));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbSortHeaderComponent,
      selectors: [["", "nbSortHeader", ""]],
      contentQueries: function NbSortHeaderComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, NbSortHeaderIconDirective, 5, TemplateRef);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sortIcon = _t.first);
        }
      },
      hostVars: 2,
      hostBindings: function NbSortHeaderComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbSortHeaderComponent_click_HostBindingHandler() {
            return ctx.sortIfEnabled();
          });
        }
        if (rf & 2) {
          ɵɵclassProp("disabled", ctx.disabled);
        }
      },
      inputs: {
        direction: [0, "nbSortHeader", "direction"],
        disabled: "disabled"
      },
      standalone: false,
      attrs: _c56,
      ngContentSelectors: _c03,
      decls: 5,
      vars: 5,
      consts: [["customIcon", ""], ["type", "button", 1, "nb-tree-grid-header-change-sort-button", 3, "click"], [3, "direction", 4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "direction"]],
      template: function NbSortHeaderComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵprojectionDef();
          ɵɵelementStart(0, "button", 1);
          ɵɵlistener("click", function NbSortHeaderComponent_Template_button_click_0_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.sortData());
          });
          ɵɵprojection(1);
          ɵɵelementEnd();
          ɵɵtemplate(2, NbSortHeaderComponent_nb_sort_icon_2_Template, 1, 1, "nb-sort-icon", 2)(3, NbSortHeaderComponent_ng_template_3_Template, 0, 0, "ng-template", 3, 0, ɵɵtemplateRefExtractor);
        }
        if (rf & 2) {
          const customIcon_r3 = ɵɵreference(4);
          ɵɵattribute("disabled", ctx.getDisabledAttributeValue());
          ɵɵadvance(2);
          ɵɵproperty("ngIf", !ctx.sortIcon)("ngIfElse", customIcon_r3);
          ɵɵadvance();
          ɵɵproperty("ngTemplateOutlet", ctx.sortIcon)("ngTemplateOutletContext", ctx.getIconContext());
        }
      },
      dependencies: [NgIf, NgTemplateOutlet, NbSortIconComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortHeaderComponent, [{
    type: Component,
    args: [{
      selector: "[nbSortHeader]",
      template: `
    <button
      class="nb-tree-grid-header-change-sort-button"
      type="button"
      [attr.disabled]="getDisabledAttributeValue()"
      (click)="sortData()">
      <ng-content></ng-content>
    </button>
    <nb-sort-icon *ngIf="!sortIcon; else customIcon" [direction]="direction"></nb-sort-icon>
    <ng-template #customIcon [ngTemplateOutlet]="sortIcon" [ngTemplateOutletContext]="getIconContext()"></ng-template>
  `,
      standalone: false
    }]
  }], () => [{
    type: NbSortDirective
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_SORT_HEADER_COLUMN_DEF]
    }]
  }], {
    sortIcon: [{
      type: ContentChild,
      args: [NbSortHeaderIconDirective, {
        read: TemplateRef
      }]
    }],
    direction: [{
      type: Input,
      args: ["nbSortHeader"]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    sortIfEnabled: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var NbTreeGridSortService = class _NbTreeGridSortService {
  sort(request, data) {
    if (!request) {
      return data;
    }
    const sorted = data.sort((na, nb) => this.comparator(request, na, nb));
    for (const node of data) {
      if (node.children) {
        node.children = this.sort(request, node.children);
      }
    }
    return sorted;
  }
  comparator(request, na, nb) {
    const key = request.column;
    const dir = request.direction;
    const a = na.data[key];
    const b = nb.data[key];
    let res = 0;
    if (a > b) {
      res = 1;
    }
    if (a < b) {
      res = -1;
    }
    return dir === NbSortDirection.ASCENDING ? res : res * -1;
  }
  static {
    this.ɵfac = function NbTreeGridSortService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridSortService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbTreeGridSortService,
      factory: _NbTreeGridSortService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridSortService, [{
    type: Injectable
  }], null, null);
})();
var NbTreeGridService = class _NbTreeGridService {
  expand(data, row, options = {}) {
    const node = this.find(data, row);
    node.expanded = true;
    if (options.deep && node.hasChildren()) {
      node.children.forEach((n) => this.expand(data, n.data, options));
    }
  }
  collapse(data, row, options = {}) {
    const node = this.find(data, row);
    node.expanded = false;
    if (options.deep && node.hasChildren()) {
      node.children.forEach((n) => this.collapse(data, n.data, options));
    }
  }
  toggle(data, row, options = {}) {
    const node = this.find(data, row);
    if (node.expanded) {
      this.collapse(data, row, options);
    } else {
      this.expand(data, row, options);
    }
  }
  find(data, row) {
    const toCheck = [...data];
    for (const node of toCheck) {
      if (node.data === row) {
        return node;
      }
      if (node.hasChildren()) {
        toCheck.push(...node.children);
      }
    }
    return void 0;
  }
  static {
    this.ɵfac = function NbTreeGridService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbTreeGridService,
      factory: _NbTreeGridService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridService, [{
    type: Injectable
  }], null, null);
})();
var NbTreeGridDataService = class _NbTreeGridDataService {
  constructor() {
    this.defaultGetters = {
      dataGetter: (node) => node.data,
      childrenGetter: (d) => d.children || void 0,
      expandedGetter: (d) => !!d.expanded
    };
  }
  toPresentationNodes(nodes, customGetters, level = NB_DEFAULT_ROW_LEVEL) {
    const getters = __spreadValues(__spreadValues({}, this.defaultGetters), customGetters);
    return this.mapNodes(nodes, getters, level);
  }
  mapNodes(nodes, getters, level) {
    const {
      dataGetter,
      childrenGetter,
      expandedGetter
    } = getters;
    return nodes.map((node) => {
      const childrenNodes = childrenGetter(node);
      let children;
      if (childrenNodes) {
        children = this.toPresentationNodes(childrenNodes, getters, level + 1);
      }
      return new NbTreeGridPresentationNode(dataGetter(node), children, expandedGetter(node), level);
    });
  }
  flattenExpanded(nodes) {
    return nodes.reduce((res, node) => {
      res.push(node);
      if (node.expanded && node.hasChildren()) {
        res.push(...this.flattenExpanded(node.children));
      }
      return res;
    }, []);
  }
  copy(nodes) {
    return nodes.map((node) => {
      let children;
      if (node.hasChildren()) {
        children = this.copy(node.children);
      }
      return new NbTreeGridPresentationNode(node.data, children, node.expanded, node.level);
    });
  }
  static {
    this.ɵfac = function NbTreeGridDataService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridDataService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbTreeGridDataService,
      factory: _NbTreeGridDataService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridDataService, [{
    type: Injectable
  }], null, null);
})();
var NbTreeGridDataSource = class extends NbDataSource {
  constructor(sortService, filterService, treeGridService, treeGridDataService) {
    super();
    this.sortService = sortService;
    this.filterService = filterService;
    this.treeGridService = treeGridService;
    this.treeGridDataService = treeGridDataService;
    this.renderData = new BehaviorSubject([]);
    this.filterRequest = new BehaviorSubject("");
    this.sortRequest = new BehaviorSubject(null);
  }
  setData(data, customGetters) {
    let presentationData = [];
    if (data) {
      presentationData = this.treeGridDataService.toPresentationNodes(data, customGetters);
    }
    this.data = new BehaviorSubject(presentationData);
    this.updateChangeSubscription();
  }
  connect(collectionViewer) {
    return this.renderData;
  }
  disconnect(collectionViewer) {
  }
  expand(row) {
    this.treeGridService.expand(this.data.value, row);
    this.data.next(this.data.value);
  }
  collapse(row) {
    this.treeGridService.collapse(this.data.value, row);
    this.data.next(this.data.value);
  }
  toggle(row, options) {
    this.treeGridService.toggle(this.data.value, row, options);
    this.data.next(this.data.value);
  }
  toggleByIndex(dataIndex, options) {
    const node = this.renderData.value && this.renderData.value[dataIndex];
    if (node) {
      this.toggle(node.data, options);
    }
  }
  getLevel(rowIndex) {
    const row = this.renderData.value[rowIndex];
    return row ? row.level : NB_DEFAULT_ROW_LEVEL;
  }
  sort(sortRequest) {
    this.sortRequest.next(sortRequest);
  }
  filter(searchQuery) {
    this.filterRequest.next(searchQuery);
  }
  updateChangeSubscription() {
    const dataStream = this.data;
    const filteredData = combineLatest([dataStream, this.filterRequest]).pipe(map(([data]) => this.treeGridDataService.copy(data)), map((data) => this.filterData(data)));
    const sortedData = combineLatest([filteredData, this.sortRequest]).pipe(map(([data]) => this.sortData(data)));
    sortedData.pipe(map((data) => this.treeGridDataService.flattenExpanded(data))).subscribe((data) => this.renderData.next(data));
  }
  filterData(data) {
    return this.filterService.filter(this.filterRequest.value, data);
  }
  sortData(data) {
    return this.sortService.sort(this.sortRequest.value, data);
  }
};
var NbTreeGridDataSourceBuilder = class _NbTreeGridDataSourceBuilder {
  constructor(filterService, sortService, treeGridService, treeGridDataService) {
    this.filterService = filterService;
    this.sortService = sortService;
    this.treeGridService = treeGridService;
    this.treeGridDataService = treeGridDataService;
  }
  create(data, customGetters) {
    const dataSource = new NbTreeGridDataSource(this.sortService, this.filterService, this.treeGridService, this.treeGridDataService);
    dataSource.setData(data, customGetters);
    return dataSource;
  }
  static {
    this.ɵfac = function NbTreeGridDataSourceBuilder_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridDataSourceBuilder)(ɵɵinject(NbTreeGridFilterService), ɵɵinject(NbTreeGridSortService), ɵɵinject(NbTreeGridService), ɵɵinject(NbTreeGridDataService));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbTreeGridDataSourceBuilder,
      factory: _NbTreeGridDataSourceBuilder.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridDataSourceBuilder, [{
    type: Injectable
  }], () => [{
    type: NbTreeGridFilterService
  }, {
    type: NbTreeGridSortService
  }, {
    type: NbTreeGridService
  }, {
    type: NbTreeGridDataService
  }], null);
})();
var NB_TREE_GRID = new InjectionToken("NB_TREE_GRID");
var NbColumnsService = class _NbColumnsService {
  constructor(differs) {
    this.differs = differs;
    this.columnHide$ = new Subject();
    this.columnShow$ = new Subject();
  }
  setColumns(columns) {
    if (!this.changesDiffer) {
      this.changesDiffer = this.differs.find(columns || []).create();
    }
    if (this.changesDiffer.diff(columns)) {
      this.allColumns = Array.from(columns);
      this.visibleColumns = Array.from(columns);
    }
  }
  getVisibleColumns() {
    return this.visibleColumns;
  }
  hideColumn(column) {
    const toRemove = this.visibleColumns.indexOf(column);
    if (toRemove > -1) {
      this.visibleColumns.splice(toRemove, 1);
      this.columnHide$.next();
    }
  }
  showColumn(column) {
    if (this.visibleColumns.includes(column)) {
      return;
    }
    this.visibleColumns.splice(this.findInsertIndex(column), 0, column);
    this.columnShow$.next();
  }
  onColumnsChange() {
    return merge(this.columnShow$, this.columnHide$);
  }
  findInsertIndex(column) {
    const initialIndex = this.allColumns.indexOf(column);
    if (initialIndex === 0 || !this.visibleColumns.length) {
      return 0;
    }
    if (initialIndex === this.allColumns.length - 1) {
      return this.visibleColumns.length;
    }
    const leftSiblingIndex = initialIndex - 1;
    for (let i = leftSiblingIndex; i >= 0; i--) {
      const leftSibling = this.allColumns[i];
      const index = this.visibleColumns.indexOf(leftSibling);
      if (index !== -1) {
        return index + 1;
      }
    }
    const rightSiblingIndex = initialIndex + 1;
    for (let i = rightSiblingIndex; i < this.allColumns.length; i++) {
      const rightSibling = this.allColumns[i];
      const index = this.visibleColumns.indexOf(rightSibling);
      if (index !== -1) {
        return index;
      }
    }
    throw new Error(`Can't restore column position.`);
  }
  static {
    this.ɵfac = function NbColumnsService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbColumnsService)(ɵɵinject(IterableDiffers));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NbColumnsService,
      factory: _NbColumnsService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbColumnsService, [{
    type: Injectable
  }], () => [{
    type: IterableDiffers
  }], null);
})();
var NbTreeGridComponent = class _NbTreeGridComponent extends NbTable {
  constructor(dataSourceBuilder, differs, changeDetectorRef, elementRef, role, dir, document2, platform, window2, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener) {
    super(differs, changeDetectorRef, elementRef, role, dir, document2, platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener);
    this.dataSourceBuilder = dataSourceBuilder;
    this.window = window2;
    this._viewRepeater = _viewRepeater;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._stickyPositioningListener = _stickyPositioningListener;
    this.destroy$ = new Subject();
    this.levelPadding = "";
    this.equalColumnsWidthValue = false;
    this.treeClass = true;
    this.platform = platform;
  }
  /**
   * The table's data
   * @param data
   * @type {<T>[] | NbTreeGridDataSource}
   */
  set source(data) {
    if (!data) {
      return;
    }
    if (data instanceof NbTreeGridDataSource) {
      this._source = data;
    } else {
      this._source = this.dataSourceBuilder.create(data);
    }
    this.dataSource = this._source;
  }
  /**
   * Make all columns equal width. False by default.
   */
  set equalColumnsWidth(value) {
    this.equalColumnsWidthValue = convertToBoolProperty(value);
  }
  get equalColumnsWidth() {
    return this.equalColumnsWidthValue;
  }
  ngAfterViewInit() {
    this.checkDefsCount();
    const rowsChange$ = merge(this._contentRowDefs.changes, this._contentHeaderRowDefs.changes, this._contentFooterRowDefs.changes);
    rowsChange$.pipe(takeUntil(this.destroy$)).subscribe(() => this.checkDefsCount());
    if (this.platform.isBrowser) {
      this.updateVisibleColumns();
      const windowResize$ = fromEvent(this.window, "resize").pipe(debounceTime(50));
      merge(rowsChange$, this._contentColumnDefs.changes, windowResize$).pipe(takeUntil(this.destroy$)).subscribe(() => this.updateVisibleColumns());
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  toggleRow(row, options) {
    const context = this.getRowContext(row);
    this._source.toggle(context.$implicit.data, options);
  }
  toggleCellRow(cell) {
    const context = this.getCellContext(cell);
    this._source.toggle(context.$implicit.data);
  }
  getColumnWidth() {
    if (this.equalColumnsWidth) {
      return `${100 / this.getColumnsCount()}%`;
    }
    return "";
  }
  getCellLevel(cell, columnName) {
    if (this.isFirstColumn(columnName)) {
      return this.getCellContext(cell).$implicit.level;
    }
    return NB_DEFAULT_ROW_LEVEL;
  }
  getRowContext(row) {
    return this.getContextByRowEl(row.elementRef.nativeElement);
  }
  getCellContext(cell) {
    return this.getContextByCellEl(cell.elementRef.nativeElement);
  }
  getContextByCellEl(cellEl) {
    return this.getContextByRowEl(cellEl.parentElement);
  }
  getContextByRowEl(rowEl) {
    const rowsContainer = this._rowOutlet.viewContainer;
    for (let i = 0; i < rowsContainer.length; i++) {
      const rowViewRef = rowsContainer.get(i);
      if (rowViewRef.rootNodes.includes(rowEl)) {
        return rowViewRef.context;
      }
    }
    return void 0;
  }
  getColumns() {
    let rowDef;
    if (this._contentHeaderRowDefs.length) {
      rowDef = this._contentHeaderRowDefs.first;
    } else {
      rowDef = this._contentRowDefs.first;
    }
    return Array.from(rowDef.getVisibleColumns() || []);
  }
  getColumnsCount() {
    return this.getColumns().length;
  }
  isFirstColumn(columnName) {
    return this.getColumns()[0] === columnName;
  }
  checkDefsCount() {
    if (this._contentRowDefs.length > 1) {
      throw new Error(`Found multiple row definitions`);
    }
    if (this._contentHeaderRowDefs.length > 1) {
      throw new Error(`Found multiple header row definitions`);
    }
    if (this._contentFooterRowDefs.length > 1) {
      throw new Error(`Found multiple footer row definitions`);
    }
  }
  updateVisibleColumns() {
    const width = this.window.innerWidth;
    const columnDefs = this._contentColumnDefs;
    const columnsToHide = columnDefs.filter((col) => col.shouldHide(width)).map((col) => col.name);
    const columnsToShow = columnDefs.filter((col) => col.shouldShow(width)).map((col) => col.name);
    if (!columnsToHide.length && !columnsToShow.length) {
      return;
    }
    const rowDefs = [this._contentHeaderRowDefs.first, this._contentRowDefs.first, this._contentFooterRowDefs.first].filter((d) => !!d);
    for (const rowDef of rowDefs) {
      for (const column of columnsToHide) {
        rowDef.hideColumn(column);
      }
      for (const column of columnsToShow) {
        rowDef.showColumn(column);
      }
    }
  }
  static {
    this.ɵfac = function NbTreeGridComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridComponent)(ɵɵdirectiveInject(NbTreeGridDataSourceBuilder), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵinjectAttribute("role"), ɵɵdirectiveInject(NbDirectionality), ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPlatform), ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(NB_VIEW_REPEATER_STRATEGY), ɵɵdirectiveInject(NB_COALESCED_STYLE_SCHEDULER), ɵɵdirectiveInject(NbViewportRulerAdapter), ɵɵdirectiveInject(NB_STICKY_POSITIONING_LISTENER, 12));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTreeGridComponent,
      selectors: [["table", "nbTreeGrid", ""]],
      hostVars: 2,
      hostBindings: function NbTreeGridComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassProp("nb-tree-grid", ctx.treeClass);
        }
      },
      inputs: {
        source: [0, "nbTreeGrid", "source"],
        levelPadding: "levelPadding",
        equalColumnsWidth: "equalColumnsWidth"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NB_TREE_GRID,
        useExisting: _NbTreeGridComponent
      }, {
        provide: CDK_TABLE,
        useExisting: _NbTreeGridComponent
      }, NbColumnsService, ...NB_TABLE_PROVIDERS]), ɵɵInheritDefinitionFeature],
      attrs: _c57,
      decls: 4,
      vars: 0,
      consts: [["nbHeaderRowOutlet", ""], ["nbRowOutlet", ""], ["nbNoDataRowOutlet", ""], ["nbFooterRowOutlet", ""]],
      template: function NbTreeGridComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementContainer(0, 0)(1, 1)(2, 2)(3, 3);
        }
      },
      dependencies: [NbDataRowOutletDirective, NbHeaderRowOutletDirective, NbFooterRowOutletDirective, NbNoDataRowOutletDirective],
      styles: ["[_nghost-%COMP%]{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}  .nb-tree-grid-cell,   .nb-tree-grid-header-cell,   .nb-tree-grid-footer-cell{overflow:hidden}\n\n\n\n\n\n"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridComponent, [{
    type: Component,
    args: [{
      selector: "table[nbTreeGrid]",
      template: NB_TABLE_TEMPLATE,
      providers: [{
        provide: NB_TREE_GRID,
        useExisting: NbTreeGridComponent
      }, {
        provide: CDK_TABLE,
        useExisting: NbTreeGridComponent
      }, NbColumnsService, ...NB_TABLE_PROVIDERS],
      standalone: false,
      styles: [":host{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}::ng-deep .nb-tree-grid-cell,::ng-deep .nb-tree-grid-header-cell,::ng-deep .nb-tree-grid-footer-cell{overflow:hidden}\n/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: NbTreeGridDataSourceBuilder
  }, {
    type: IterableDiffers
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["role"]
    }]
  }, {
    type: NbDirectionality
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [NB_STICKY_POSITIONING_LISTENER]
    }]
  }], {
    source: [{
      type: Input,
      args: ["nbTreeGrid"]
    }],
    levelPadding: [{
      type: Input
    }],
    equalColumnsWidth: [{
      type: Input
    }],
    treeClass: [{
      type: HostBinding,
      args: ["class.nb-tree-grid"]
    }]
  });
})();
var NbTreeGridRowDefDirective = class _NbTreeGridRowDefDirective extends NbRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
  static {
    this.ɵfac = function NbTreeGridRowDefDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridRowDefDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(NbColumnsService));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTreeGridRowDefDirective,
      selectors: [["", "nbTreeGridRowDef", ""]],
      inputs: {
        columns: [0, "nbTreeGridRowDefColumns", "columns"]
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkRowDef,
        useExisting: _NbTreeGridRowDefDirective
      }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridRowDef]",
      providers: [{
        provide: NbCdkRowDef,
        useExisting: NbTreeGridRowDefDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridRowDefColumns"]
    }]
  });
})();
var NbTreeGridHeaderRowDefDirective = class _NbTreeGridHeaderRowDefDirective extends NbHeaderRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
  static {
    this.ɵfac = function NbTreeGridHeaderRowDefDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridHeaderRowDefDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(NbColumnsService));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTreeGridHeaderRowDefDirective,
      selectors: [["", "nbTreeGridHeaderRowDef", ""]],
      inputs: {
        columns: [0, "nbTreeGridHeaderRowDef", "columns"]
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkHeaderRowDef,
        useExisting: _NbTreeGridHeaderRowDefDirective
      }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridHeaderRowDef]",
      providers: [{
        provide: NbCdkHeaderRowDef,
        useExisting: NbTreeGridHeaderRowDefDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridHeaderRowDef"]
    }]
  });
})();
var NbTreeGridFooterRowDefDirective = class _NbTreeGridFooterRowDefDirective extends NbFooterRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
  static {
    this.ɵfac = function NbTreeGridFooterRowDefDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridFooterRowDefDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(NbColumnsService));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTreeGridFooterRowDefDirective,
      selectors: [["", "nbTreeGridFooterRowDef", ""]],
      inputs: {
        columns: [0, "nbTreeGridFooterRowDef", "columns"]
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkFooterRowDef,
        useExisting: _NbTreeGridFooterRowDefDirective
      }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridFooterRowDef]",
      providers: [{
        provide: NbCdkFooterRowDef,
        useExisting: NbTreeGridFooterRowDefDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridFooterRowDef"]
    }]
  });
})();
var NbTreeGridCellDefDirective = class _NbTreeGridCellDefDirective extends NbCellDefDirective {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbTreeGridCellDefDirective_BaseFactory;
      return function NbTreeGridCellDefDirective_Factory(__ngFactoryType__) {
        return (ɵNbTreeGridCellDefDirective_BaseFactory || (ɵNbTreeGridCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridCellDefDirective)))(__ngFactoryType__ || _NbTreeGridCellDefDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTreeGridCellDefDirective,
      selectors: [["", "nbTreeGridCellDef", ""]],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkCellDef,
        useExisting: _NbTreeGridCellDefDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridCellDef]",
      providers: [{
        provide: NbCdkCellDef,
        useExisting: NbTreeGridCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbTreeGridHeaderCellDefDirective = class _NbTreeGridHeaderCellDefDirective extends NbHeaderCellDefDirective {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbTreeGridHeaderCellDefDirective_BaseFactory;
      return function NbTreeGridHeaderCellDefDirective_Factory(__ngFactoryType__) {
        return (ɵNbTreeGridHeaderCellDefDirective_BaseFactory || (ɵNbTreeGridHeaderCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridHeaderCellDefDirective)))(__ngFactoryType__ || _NbTreeGridHeaderCellDefDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTreeGridHeaderCellDefDirective,
      selectors: [["", "nbTreeGridHeaderCellDef", ""]],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkHeaderCellDef,
        useExisting: _NbTreeGridHeaderCellDefDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridHeaderCellDef]",
      providers: [{
        provide: NbCdkHeaderCellDef,
        useExisting: NbTreeGridHeaderCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbTreeGridFooterCellDefDirective = class _NbTreeGridFooterCellDefDirective extends NbFooterCellDefDirective {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbTreeGridFooterCellDefDirective_BaseFactory;
      return function NbTreeGridFooterCellDefDirective_Factory(__ngFactoryType__) {
        return (ɵNbTreeGridFooterCellDefDirective_BaseFactory || (ɵNbTreeGridFooterCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridFooterCellDefDirective)))(__ngFactoryType__ || _NbTreeGridFooterCellDefDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTreeGridFooterCellDefDirective,
      selectors: [["", "nbTreeGridFooterCellDef", ""]],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkFooterCellDef,
        useExisting: _NbTreeGridFooterCellDefDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridFooterCellDef]",
      providers: [{
        provide: NbCdkFooterCellDef,
        useExisting: NbTreeGridFooterCellDefDirective
      }],
      standalone: false
    }]
  }], null, null);
})();
var NB_ROW_DOUBLE_CLICK_DELAY = 200;
var NbTreeGridRowComponent = class _NbTreeGridRowComponent extends NbRowComponent {
  toggleIfEnabledNode() {
    if (!this.clickToToggle) {
      return;
    }
    timer(NB_ROW_DOUBLE_CLICK_DELAY).pipe(take(1), takeUntil(this.doubleClick$)).subscribe(() => this.tree.toggleRow(this));
  }
  toggleIfEnabledNodeDeep() {
    if (!this.clickToToggle) {
      return;
    }
    this.doubleClick$.next();
    this.tree.toggleRow(this, {
      deep: true
    });
  }
  constructor(tree, elementRef) {
    super();
    this.elementRef = elementRef;
    this.doubleClick$ = new Subject();
    this.doubleClickDelay = NB_ROW_DOUBLE_CLICK_DELAY;
    this.clickToToggle = true;
    this.tree = tree;
  }
  ngOnDestroy() {
    this.doubleClick$.complete();
  }
  static {
    this.ɵfac = function NbTreeGridRowComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridRowComponent)(ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(ElementRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTreeGridRowComponent,
      selectors: [["tr", "nbTreeGridRow", ""]],
      hostAttrs: ["role", "row", 1, "nb-tree-grid-row"],
      hostBindings: function NbTreeGridRowComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbTreeGridRowComponent_click_HostBindingHandler() {
            return ctx.toggleIfEnabledNode();
          })("dblclick", function NbTreeGridRowComponent_dblclick_HostBindingHandler() {
            return ctx.toggleIfEnabledNodeDeep();
          });
        }
      },
      inputs: {
        doubleClickDelay: "doubleClickDelay",
        clickToToggle: "clickToToggle"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkRow,
        useExisting: _NbTreeGridRowComponent
      }]), ɵɵInheritDefinitionFeature],
      attrs: _c58,
      decls: 1,
      vars: 0,
      consts: [["nbCellOutlet", ""]],
      template: function NbTreeGridRowComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementContainer(0, 0);
        }
      },
      dependencies: [NbCellOutletDirective],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridRow]",
      template: `<ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkRow,
        useExisting: NbTreeGridRowComponent
      }],
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: ElementRef
  }], {
    doubleClickDelay: [{
      type: Input
    }],
    clickToToggle: [{
      type: Input
    }],
    toggleIfEnabledNode: [{
      type: HostListener,
      args: ["click"]
    }],
    toggleIfEnabledNodeDeep: [{
      type: HostListener,
      args: ["dblclick"]
    }]
  });
})();
var NbTreeGridHeaderRowComponent = class _NbTreeGridHeaderRowComponent extends NbHeaderRowComponent {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbTreeGridHeaderRowComponent_BaseFactory;
      return function NbTreeGridHeaderRowComponent_Factory(__ngFactoryType__) {
        return (ɵNbTreeGridHeaderRowComponent_BaseFactory || (ɵNbTreeGridHeaderRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridHeaderRowComponent)))(__ngFactoryType__ || _NbTreeGridHeaderRowComponent);
      };
    })();
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTreeGridHeaderRowComponent,
      selectors: [["tr", "nbTreeGridHeaderRow", ""]],
      hostAttrs: ["role", "row", 1, "nb-tree-grid-header-row"],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkHeaderRow,
        useExisting: _NbTreeGridHeaderRowComponent
      }]), ɵɵInheritDefinitionFeature],
      attrs: _c59,
      decls: 1,
      vars: 0,
      consts: [["nbCellOutlet", ""]],
      template: function NbTreeGridHeaderRowComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementContainer(0, 0);
        }
      },
      dependencies: [NbCellOutletDirective],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridHeaderRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-header-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkHeaderRow,
        useExisting: NbTreeGridHeaderRowComponent
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbTreeGridFooterRowComponent = class _NbTreeGridFooterRowComponent extends NbFooterRowComponent {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbTreeGridFooterRowComponent_BaseFactory;
      return function NbTreeGridFooterRowComponent_Factory(__ngFactoryType__) {
        return (ɵNbTreeGridFooterRowComponent_BaseFactory || (ɵNbTreeGridFooterRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridFooterRowComponent)))(__ngFactoryType__ || _NbTreeGridFooterRowComponent);
      };
    })();
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTreeGridFooterRowComponent,
      selectors: [["tr", "nbTreeGridFooterRow", ""]],
      hostAttrs: ["role", "row", 1, "nb-tree-grid-footer-row"],
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkFooterRow,
        useExisting: _NbTreeGridFooterRowComponent
      }]), ɵɵInheritDefinitionFeature],
      attrs: _c60,
      decls: 1,
      vars: 0,
      consts: [["nbCellOutlet", ""]],
      template: function NbTreeGridFooterRowComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementContainer(0, 0);
        }
      },
      dependencies: [NbCellOutletDirective],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridFooterRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-footer-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkFooterRow,
        useExisting: NbTreeGridFooterRowComponent
      }],
      standalone: false
    }]
  }], null, null);
})();
var NbTreeGridColumnDefDirective = class _NbTreeGridColumnDefDirective extends NbColumnDefDirective {
  constructor() {
    super(...arguments);
    this.hideOnValue = null;
    this.showOnValue = null;
  }
  /**
   * Column name
   */
  get name() {
    return this._name;
  }
  set name(value) {
    this._setNameInput(value);
  }
  /**
   * Amount of pixels of viewport at which column should be hidden.
   * type number
   */
  get hideOn() {
    return this.hideOnValue;
  }
  set hideOn(value) {
    this.hideOnValue = !value && value !== 0 ? null : parseInt(value, 10);
  }
  /**
   * Amount of pixels of viewport at which column should be shown.
   * type number
   */
  get showOn() {
    return this.showOnValue;
  }
  set showOn(value) {
    this.showOnValue = !value && value !== 0 ? null : parseInt(value, 10);
  }
  ngOnChanges() {
    if (this.hideOn != null && this.showOn != null) {
      throw new Error(`hideOn and showOn are mutually exclusive and can't be used simultaneously.`);
    }
  }
  shouldHide(width) {
    return !this.shouldShow(width);
  }
  shouldShow(width) {
    if (this.hideOn == null && this.showOn == null) {
      return true;
    }
    if (this.hideOn != null) {
      return width > this.hideOn;
    }
    return width >= this.showOn;
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbTreeGridColumnDefDirective_BaseFactory;
      return function NbTreeGridColumnDefDirective_Factory(__ngFactoryType__) {
        return (ɵNbTreeGridColumnDefDirective_BaseFactory || (ɵNbTreeGridColumnDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridColumnDefDirective)))(__ngFactoryType__ || _NbTreeGridColumnDefDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTreeGridColumnDefDirective,
      selectors: [["", "nbTreeGridColumnDef", ""]],
      inputs: {
        name: [0, "nbTreeGridColumnDef", "name"],
        hideOn: "hideOn",
        showOn: "showOn"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkColumnDef,
        useExisting: _NbTreeGridColumnDefDirective
      }, {
        provide: NB_SORT_HEADER_COLUMN_DEF,
        useExisting: _NbTreeGridColumnDefDirective
      }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridColumnDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridColumnDef]",
      providers: [{
        provide: NbCdkColumnDef,
        useExisting: NbTreeGridColumnDefDirective
      }, {
        provide: NB_SORT_HEADER_COLUMN_DEF,
        useExisting: NbTreeGridColumnDefDirective
      }],
      standalone: false
    }]
  }], null, {
    name: [{
      type: Input,
      args: ["nbTreeGridColumnDef"]
    }],
    hideOn: [{
      type: Input
    }],
    showOn: [{
      type: Input
    }]
  });
})();
var NbTreeGridCellDirective = class _NbTreeGridCellDirective extends NbCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    if (this.latestWidth) {
      return this.latestWidth;
    }
    return null;
  }
  get leftPadding() {
    if (this.directionService.isLtr()) {
      return this.getStartPadding();
    }
    return null;
  }
  get rightPadding() {
    if (this.directionService.isRtl()) {
      return this.getStartPadding();
    }
    return null;
  }
  constructor(columnDef, elementRef, tree, platformId, window2, sanitizer, directionService, columnService, cd) {
    super(columnDef, elementRef);
    this.platformId = platformId;
    this.window = window2;
    this.sanitizer = sanitizer;
    this.directionService = directionService;
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.initialLeftPadding = "";
    this.initialRightPadding = "";
    this.tree = tree;
    this.columnDef = columnDef;
    this.elementRef = elementRef;
  }
  ngOnInit() {
    if (isPlatformBrowser(this.platformId)) {
      const style2 = this.window.getComputedStyle(this.elementRef.nativeElement);
      this.initialLeftPadding = style2.paddingLeft;
      this.initialRightPadding = style2.paddingRight;
    }
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  toggleRow() {
    this.tree.toggleCellRow(this);
  }
  get initialStartPadding() {
    return this.directionService.isLtr() ? this.initialLeftPadding : this.initialRightPadding;
  }
  getStartPadding() {
    const rowLevel = this.tree.getCellLevel(this, this.columnDef.name);
    if (rowLevel === NB_DEFAULT_ROW_LEVEL) {
      return null;
    }
    const nestingLevel = rowLevel + 1;
    let padding = "";
    if (this.tree.levelPadding) {
      padding = `calc(${this.tree.levelPadding} * ${nestingLevel})`;
    } else if (this.initialStartPadding) {
      padding = `calc(${this.initialStartPadding} * ${nestingLevel})`;
    }
    if (!padding) {
      return null;
    }
    return this.sanitizer.bypassSecurityTrustStyle(padding);
  }
  static {
    this.ɵfac = function NbTreeGridCellDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridCellDirective)(ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbColumnsService), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTreeGridCellDirective,
      selectors: [["td", "nbTreeGridCell", ""]],
      hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-cell"],
      hostVars: 6,
      hostBindings: function NbTreeGridCellDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵstyleProp("width", ctx.columnWidth)("padding-left", ctx.leftPadding)("padding-right", ctx.rightPadding);
        }
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkCell,
        useExisting: _NbTreeGridCellDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridCellDirective, [{
    type: Directive,
    args: [{
      selector: "td[nbTreeGridCell]",
      host: {
        "class": "nb-tree-grid-cell",
        "role": "gridcell"
      },
      providers: [{
        provide: NbCdkCell,
        useExisting: NbTreeGridCellDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: DomSanitizer
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }],
    leftPadding: [{
      type: HostBinding,
      args: ["style.padding-left"]
    }],
    rightPadding: [{
      type: HostBinding,
      args: ["style.padding-right"]
    }]
  });
})();
var NbTreeGridHeaderCellDirective = class _NbTreeGridHeaderCellDirective extends NbHeaderCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    return this.latestWidth || null;
  }
  constructor(columnDef, elementRef, tree, columnService, cd) {
    super(columnDef, elementRef);
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.tree = tree;
  }
  ngOnInit() {
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  static {
    this.ɵfac = function NbTreeGridHeaderCellDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridHeaderCellDirective)(ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(NbColumnsService), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTreeGridHeaderCellDirective,
      selectors: [["th", "nbTreeGridHeaderCell", ""]],
      hostAttrs: ["role", "columnheader", 1, "nb-tree-grid-header-cell"],
      hostVars: 2,
      hostBindings: function NbTreeGridHeaderCellDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵstyleProp("width", ctx.columnWidth);
        }
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkHeaderCell,
        useExisting: _NbTreeGridHeaderCellDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderCellDirective, [{
    type: Directive,
    args: [{
      selector: "th[nbTreeGridHeaderCell]",
      host: {
        "class": "nb-tree-grid-header-cell",
        "role": "columnheader"
      },
      providers: [{
        provide: NbCdkHeaderCell,
        useExisting: NbTreeGridHeaderCellDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }]
  });
})();
var NbTreeGridFooterCellDirective = class _NbTreeGridFooterCellDirective extends NbFooterCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    return this.latestWidth || null;
  }
  constructor(columnDef, elementRef, tree, columnService, cd) {
    super(columnDef, elementRef);
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.tree = tree;
  }
  ngOnInit() {
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  static {
    this.ɵfac = function NbTreeGridFooterCellDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridFooterCellDirective)(ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(NbColumnsService), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTreeGridFooterCellDirective,
      selectors: [["td", "nbTreeGridFooterCell", ""]],
      hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-footer-cell"],
      hostVars: 2,
      hostBindings: function NbTreeGridFooterCellDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵstyleProp("width", ctx.columnWidth);
        }
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbCdkFooterCell,
        useExisting: _NbTreeGridFooterCellDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterCellDirective, [{
    type: Directive,
    args: [{
      selector: "td[nbTreeGridFooterCell]",
      host: {
        "class": "nb-tree-grid-footer-cell",
        "role": "gridcell"
      },
      providers: [{
        provide: NbCdkFooterCell,
        useExisting: NbTreeGridFooterCellDirective
      }],
      standalone: false
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }]
  });
})();
var NbFilterDirective = class _NbFilterDirective {
  filter(filterRequest) {
    this.filterable.filter(filterRequest);
  }
  static {
    this.ɵfac = function NbFilterDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbFilterDirective)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbFilterDirective,
      selectors: [["", "nbFilter", ""]],
      inputs: {
        filterable: [0, "nbFilter", "filterable"]
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFilterDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFilter]",
      standalone: false
    }]
  }], null, {
    filterable: [{
      type: Input,
      args: ["nbFilter"]
    }]
  });
})();
var NbFilterInputDirective = class _NbFilterInputDirective extends NbFilterDirective {
  constructor() {
    super(...arguments);
    this.search$ = new Subject();
    this.destroy$ = new Subject();
    this.debounceTime = 200;
  }
  ngOnInit() {
    this.search$.pipe(debounceTime(this.debounceTime), takeUntil(this.destroy$)).subscribe((query2) => {
      super.filter(query2);
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.search$.complete();
  }
  filter(event) {
    this.search$.next(event.target.value);
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵNbFilterInputDirective_BaseFactory;
      return function NbFilterInputDirective_Factory(__ngFactoryType__) {
        return (ɵNbFilterInputDirective_BaseFactory || (ɵNbFilterInputDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFilterInputDirective)))(__ngFactoryType__ || _NbFilterInputDirective);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbFilterInputDirective,
      selectors: [["", "nbFilterInput", ""]],
      hostBindings: function NbFilterInputDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("input", function NbFilterInputDirective_input_HostBindingHandler($event) {
            return ctx.filter($event);
          });
        }
      },
      inputs: {
        filterable: [0, "nbFilterInput", "filterable"],
        debounceTime: "debounceTime"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NbFilterDirective,
        useExisting: _NbFilterInputDirective
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFilterInputDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFilterInput]",
      providers: [{
        provide: NbFilterDirective,
        useExisting: NbFilterInputDirective
      }],
      standalone: false
    }]
  }], null, {
    filterable: [{
      type: Input,
      args: ["nbFilterInput"]
    }],
    debounceTime: [{
      type: Input
    }],
    filter: [{
      type: HostListener,
      args: ["input", ["$event"]]
    }]
  });
})();
var NbTreeGridRowToggleDirective = class _NbTreeGridRowToggleDirective {
  toggleRow($event) {
    this.cell.toggleRow();
    $event.stopPropagation();
  }
  constructor(cell) {
    this.cell = cell;
  }
  static {
    this.ɵfac = function NbTreeGridRowToggleDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridRowToggleDirective)(ɵɵdirectiveInject(NbTreeGridCellDirective));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NbTreeGridRowToggleDirective,
      selectors: [["", "nbTreeGridRowToggle", ""]],
      hostBindings: function NbTreeGridRowToggleDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbTreeGridRowToggleDirective_click_HostBindingHandler($event) {
            return ctx.toggleRow($event);
          });
        }
      },
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowToggleDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridRowToggle]",
      standalone: false
    }]
  }], () => [{
    type: NbTreeGridCellDirective
  }], {
    toggleRow: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var NbTreeGridRowToggleComponent = class _NbTreeGridRowToggleComponent {
  set expanded(value) {
    this.expandedValue = value;
  }
  get expanded() {
    return this.expandedValue;
  }
  toggleRow($event) {
    this.cell.toggleRow();
    $event.stopPropagation();
  }
  constructor(cell) {
    this.cell = cell;
  }
  static {
    this.ɵfac = function NbTreeGridRowToggleComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridRowToggleComponent)(ɵɵdirectiveInject(NbTreeGridCellDirective));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbTreeGridRowToggleComponent,
      selectors: [["nb-tree-grid-row-toggle"]],
      hostBindings: function NbTreeGridRowToggleComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function NbTreeGridRowToggleComponent_click_HostBindingHandler($event) {
            return ctx.toggleRow($event);
          });
        }
      },
      inputs: {
        expanded: "expanded"
      },
      standalone: false,
      decls: 2,
      vars: 2,
      consts: [[1, "row-toggle-button"], ["pack", "nebular-essentials", "aria-hidden", "true", 3, "icon"]],
      template: function NbTreeGridRowToggleComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "button", 0);
          ɵɵelement(1, "nb-icon", 1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵattribute("aria-label", ctx.expanded ? "collapse" : "expand");
          ɵɵadvance();
          ɵɵproperty("icon", ctx.expanded ? "chevron-down-outline" : "chevron-right-outline");
        }
      },
      dependencies: [NbIconComponent],
      styles: ["button[_ngcontent-%COMP%]{background:transparent;border:none;padding:0}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowToggleComponent, [{
    type: Component,
    args: [{
      selector: "nb-tree-grid-row-toggle",
      template: `
    <button class="row-toggle-button" [attr.aria-label]="expanded ? 'collapse' : 'expand'">
      <nb-icon [icon]="expanded ? 'chevron-down-outline' : 'chevron-right-outline'"
               pack="nebular-essentials"
               aria-hidden="true">
      </nb-icon>
    </button>
  `,
      standalone: false,
      styles: ["button{background:transparent;border:none;padding:0}\n"]
    }]
  }], () => [{
    type: NbTreeGridCellDirective
  }], {
    expanded: [{
      type: Input
    }],
    toggleRow: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var COMPONENTS = [
  // Tree Grid
  NbTreeGridComponent,
  NbTreeGridRowDefDirective,
  NbTreeGridRowComponent,
  NbTreeGridCellDefDirective,
  NbTreeGridCellDirective,
  NbTreeGridHeaderRowDefDirective,
  NbTreeGridHeaderRowComponent,
  NbTreeGridHeaderCellDefDirective,
  NbTreeGridHeaderCellDirective,
  NbTreeGridFooterRowDefDirective,
  NbTreeGridFooterRowComponent,
  NbTreeGridFooterCellDefDirective,
  NbTreeGridFooterCellDirective,
  NbTreeGridColumnDefDirective,
  // Sort directives
  NbSortDirective,
  NbSortHeaderComponent,
  NbSortIconComponent,
  // Filter directives
  NbFilterDirective,
  NbFilterInputDirective,
  NbTreeGridRowToggleDirective,
  NbTreeGridRowToggleComponent,
  NbSortHeaderIconDirective
];
var NbTreeGridModule = class _NbTreeGridModule {
  static {
    this.ɵfac = function NbTreeGridModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbTreeGridModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbTreeGridModule,
      declarations: [
        // Tree Grid
        NbTreeGridComponent,
        NbTreeGridRowDefDirective,
        NbTreeGridRowComponent,
        NbTreeGridCellDefDirective,
        NbTreeGridCellDirective,
        NbTreeGridHeaderRowDefDirective,
        NbTreeGridHeaderRowComponent,
        NbTreeGridHeaderCellDefDirective,
        NbTreeGridHeaderCellDirective,
        NbTreeGridFooterRowDefDirective,
        NbTreeGridFooterRowComponent,
        NbTreeGridFooterCellDefDirective,
        NbTreeGridFooterCellDirective,
        NbTreeGridColumnDefDirective,
        // Sort directives
        NbSortDirective,
        NbSortHeaderComponent,
        NbSortIconComponent,
        // Filter directives
        NbFilterDirective,
        NbFilterInputDirective,
        NbTreeGridRowToggleDirective,
        NbTreeGridRowToggleComponent,
        NbSortHeaderIconDirective
      ],
      imports: [CommonModule, NbTableModule, NbIconModule],
      exports: [
        NbTableModule,
        // Tree Grid
        NbTreeGridComponent,
        NbTreeGridRowDefDirective,
        NbTreeGridRowComponent,
        NbTreeGridCellDefDirective,
        NbTreeGridCellDirective,
        NbTreeGridHeaderRowDefDirective,
        NbTreeGridHeaderRowComponent,
        NbTreeGridHeaderCellDefDirective,
        NbTreeGridHeaderCellDirective,
        NbTreeGridFooterRowDefDirective,
        NbTreeGridFooterRowComponent,
        NbTreeGridFooterCellDefDirective,
        NbTreeGridFooterCellDirective,
        NbTreeGridColumnDefDirective,
        // Sort directives
        NbSortDirective,
        NbSortHeaderComponent,
        NbSortIconComponent,
        // Filter directives
        NbFilterDirective,
        NbFilterInputDirective,
        NbTreeGridRowToggleDirective,
        NbTreeGridRowToggleComponent,
        NbSortHeaderIconDirective
      ]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [NbTreeGridSortService, NbTreeGridFilterService, NbTreeGridService, NbTreeGridDataService, NbTreeGridDataSourceBuilder],
      imports: [CommonModule, NbTableModule, NbIconModule, NbTableModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbTableModule, NbIconModule],
      declarations: [...COMPONENTS],
      exports: [NbTableModule, ...COMPONENTS],
      providers: [NbTreeGridSortService, NbTreeGridFilterService, NbTreeGridService, NbTreeGridDataService, NbTreeGridDataSourceBuilder]
    }]
  }], null, null);
})();
var NbToggleComponent = class _NbToggleComponent {
  /**
   * Toggle checked
   * @type {boolean}
   */
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._checked = convertToBoolProperty(value);
  }
  /**
   * Controls input disabled state
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get info() {
    return this.status === "info";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  get labelLeft() {
    return this.labelPosition === "left";
  }
  get labelRight() {
    return this.labelPosition === "right";
  }
  get labelStart() {
    return this.labelPosition === "start";
  }
  get labelEnd() {
    return this.labelPosition === "end";
  }
  constructor(changeDetector, layoutDirection, renderer, hostElement, zone, statusService) {
    this.changeDetector = changeDetector;
    this.layoutDirection = layoutDirection;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.zone = zone;
    this.statusService = statusService;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.destroy$ = new Subject();
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this.labelPosition = "end";
    this.checkedChange = new EventEmitter();
  }
  ngOnInit() {
    this.layoutDirection.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe(() => this.changeDetector.detectChanges());
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  checkState() {
    if (this.checked) {
      return this.layoutDirection.isLtr() ? "right" : "left";
    }
    return this.layoutDirection.isLtr() ? "left" : "right";
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(val) {
    this.checked = val;
    this.changeDetector.markForCheck();
  }
  setDisabledState(val) {
    this.disabled = convertToBoolProperty(val);
    this.changeDetector.markForCheck();
  }
  updateValue(event) {
    const input = event.target;
    this.checked = input.checked;
    this.checkedChange.emit(this.checked);
    this.onChange(this.checked);
  }
  onInputClick(event) {
    event.stopPropagation();
  }
  static {
    this.ɵfac = function NbToggleComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbToggleComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NbToggleComponent,
      selectors: [["nb-toggle"]],
      hostVars: 24,
      hostBindings: function NbToggleComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap(ctx.additionalClasses);
          ɵɵclassProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control)("toggle-label-left", ctx.labelLeft)("toggle-label-right", ctx.labelRight)("toggle-label-start", ctx.labelStart)("toggle-label-end", ctx.labelEnd);
        }
      },
      inputs: {
        checked: "checked",
        disabled: "disabled",
        status: "status",
        labelPosition: "labelPosition"
      },
      outputs: {
        checkedChange: "checkedChange"
      },
      standalone: false,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _NbToggleComponent),
        multi: true
      }])],
      ngContentSelectors: _c03,
      decls: 7,
      vars: 7,
      consts: [[1, "toggle-label"], ["type", "checkbox", "role", "switch", 1, "native-input", "visually-hidden", 3, "change", "blur", "click", "disabled", "checked"], [1, "toggle"], [1, "toggle-switcher"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "text"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials"]],
      template: function NbToggleComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵelementStart(0, "label", 0)(1, "input", 1);
          ɵɵlistener("change", function NbToggleComponent_Template_input_change_1_listener($event) {
            return ctx.updateValue($event);
          })("blur", function NbToggleComponent_Template_input_blur_1_listener() {
            return ctx.onTouched();
          })("click", function NbToggleComponent_Template_input_click_1_listener($event) {
            return ctx.onInputClick($event);
          });
          ɵɵelementEnd();
          ɵɵelementStart(2, "div", 2)(3, "span", 3);
          ɵɵtemplate(4, NbToggleComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
          ɵɵelementEnd()();
          ɵɵelementStart(5, "span", 5);
          ɵɵprojection(6);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("disabled", ctx.disabled)("checked", ctx.checked);
          ɵɵattribute("aria-checked", ctx.checked);
          ɵɵadvance();
          ɵɵclassProp("checked", ctx.checked);
          ɵɵadvance();
          ɵɵproperty("@position", ctx.checkState());
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.checked);
        }
      },
      dependencies: [NgIf, NbIconComponent],
      styles: ["[_nghost-%COMP%]{display:inline-flex;outline:none}.toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}[dir=ltr]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}[dir=rtl]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}.toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=ltr]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}[dir=rtl]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}.toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]{flex-direction:row-reverse}[dir=ltr]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}[dir=rtl]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=ltr]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=rtl]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}.nb-transition[_nghost-%COMP%]   .toggle[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center}.toggle[_ngcontent-%COMP%]{position:relative;display:inline-flex;box-sizing:content-box}.toggle-switcher[_ngcontent-%COMP%]{position:absolute;border-radius:50%;margin:1px}.toggle-switcher[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}\n\n\n\n\n\n"],
      data: {
        animation: [trigger("position", [state("right", style({
          right: 0,
          left: "*"
        })), state("left", style({
          left: 0,
          right: "*"
        })), transition(":enter", [animate(0)]), transition("right <=> left", [animate("0.15s")])])]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToggleComponent, [{
    type: Component,
    args: [{
      selector: "nb-toggle",
      animations: [trigger("position", [state("right", style({
        right: 0,
        left: "*"
      })), state("left", style({
        left: 0,
        right: "*"
      })), transition(":enter", [animate(0)]), transition("right <=> left", [animate("0.15s")])])],
      template: `
    <label class="toggle-label">
      <input type="checkbox"
             class="native-input visually-hidden"
             role="switch"
             [attr.aria-checked]="checked"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValue($event)"
             (blur)="onTouched()"
             (click)="onInputClick($event)">
      <div class="toggle" [class.checked]="checked">
        <span [@position]="checkState()" class="toggle-switcher">
          <nb-icon *ngIf="checked" icon="checkmark-bold-outline" pack="nebular-essentials"></nb-icon>
        </span>
      </div>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbToggleComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      styles: [":host{display:inline-flex;outline:none}:host(.toggle-label-left) .text:not(:empty){padding-right:.6875rem}[dir=ltr] :host(.toggle-label-left) .text:not(:empty){order:-1}[dir=rtl] :host(.toggle-label-left) .text:not(:empty){order:1}:host(.toggle-label-right) .text:not(:empty){padding-left:.6875rem}[dir=ltr] :host(.toggle-label-right) .text:not(:empty){order:1}[dir=rtl] :host(.toggle-label-right) .text:not(:empty){order:-1}:host(.toggle-label-start) .toggle-label{flex-direction:row-reverse}[dir=ltr] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-right:.6875rem}[dir=rtl] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-left:.6875rem}[dir=ltr] :host(.toggle-label-end) .text:not(:empty){padding-left:.6875rem}[dir=rtl] :host(.toggle-label-end) .text:not(:empty){padding-right:.6875rem}:host(.nb-transition) .toggle{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-label{position:relative;display:inline-flex;align-items:center}.toggle{position:relative;display:inline-flex;box-sizing:content-box}.toggle-switcher{position:absolute;border-radius:50%;margin:1px}.toggle-switcher nb-icon{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    checked: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    labelPosition: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    labelLeft: [{
      type: HostBinding,
      args: ["class.toggle-label-left"]
    }],
    labelRight: [{
      type: HostBinding,
      args: ["class.toggle-label-right"]
    }],
    labelStart: [{
      type: HostBinding,
      args: ["class.toggle-label-start"]
    }],
    labelEnd: [{
      type: HostBinding,
      args: ["class.toggle-label-end"]
    }]
  });
})();
var NbToggleModule = class _NbToggleModule {
  static {
    this.ɵfac = function NbToggleModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NbToggleModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _NbToggleModule,
      declarations: [NbToggleComponent],
      imports: [CommonModule, NbIconModule],
      exports: [NbToggleComponent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CommonModule, NbIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToggleModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      declarations: [NbToggleComponent],
      exports: [NbToggleComponent]
    }]
  }], null, null);
})();

export {
  NB_THEME_OPTIONS,
  NB_MEDIA_BREAKPOINTS,
  NB_BUILT_IN_JS_THEMES,
  NB_JS_THEMES,
  NB_WINDOW,
  NB_DOCUMENT,
  DEFAULT_MEDIA_BREAKPOINTS,
  NbMediaBreakpointsService,
  DEFAULT_THEME,
  COSMIC_THEME,
  CORPORATE_THEME,
  DARK_THEME,
  BUILT_IN_THEMES,
  NbJSThemesRegistry,
  NbThemeService,
  NbSpinnerService,
  NbLayoutDirection,
  NB_LAYOUT_DIRECTION,
  NbLayoutDirectionService,
  NbLayoutScrollService,
  NbLayoutRulerService,
  NbFocusTrap,
  NbFocusTrapFactoryService,
  NbFocusKeyManager,
  NbFocusKeyManagerFactoryService,
  NbFocusMonitor,
  NbA11yModule,
  NbPortalDirective,
  NbPortalOutletDirective,
  NbComponentPortal,
  NbOverlay,
  NbOverlayPositionBuilder,
  NbTemplatePortal,
  NbOverlayContainer,
  NbFlexibleConnectedPositionStrategy,
  NbPortalInjector,
  NbCdkMappingModule,
  NbGlobalLogicalPosition,
  NbGlobalPhysicalPosition,
  NbPositionHelper,
  NbPlatform,
  NbViewportRulerAdapter,
  NbOverlayContainerAdapter,
  NbAdjustment,
  NbPosition,
  NbAdjustableConnectedPositionStrategy,
  NbGlobalPositionStrategy,
  NbPositionBuilderService,
  NbPositionedContainerComponent,
  NbOverlayContainerComponent,
  patch,
  createContainer,
  NbOverlayService,
  NbScrollDispatcherAdapter,
  NbBlockScrollStrategyAdapter,
  NbScrollStrategyOptions,
  NbCdkAdapterModule,
  NbTrigger,
  NbTriggerStrategyBase,
  NbClickTriggerStrategy,
  NbHoverTriggerStrategy,
  NbHintTriggerStrategy,
  NbFocusTriggerStrategy,
  NbNoopTriggerStrategy,
  NbTriggerStrategyBuilderService,
  NbOverlayModule,
  NbStatusService,
  windowFactory,
  NbThemeModule,
  NbColorHelper,
  NbIconPackType,
  NbFontIcon,
  NbSvgIcon,
  NbIconDefinition,
  NbIconLibraries,
  NbIconComponent,
  NbIconModule,
  NbCardHeaderComponent,
  NbCardBodyComponent,
  NbCardFooterComponent,
  NbCardComponent,
  NbRevealCardComponent,
  NbFlipCardComponent,
  NbCardFrontComponent,
  NbCardBackComponent,
  NbCardModule,
  NbCalendarViewMode,
  NbCalendarSize,
  NbDateService,
  NbCalendarYearModelService,
  NbButton,
  NbButtonComponent,
  NbCalendarViewModeComponent,
  NbCalendarPageableNavigationComponent,
  NbCalendarYearCellComponent,
  NbCalendarPickerRowComponent,
  NbCalendarPickerComponent,
  NbCalendarYearPickerComponent,
  NbCalendarMonthCellComponent,
  MONTHS_IN_VIEW,
  MONTHS_IN_COLUMN,
  NbCalendarMonthPickerComponent,
  NbCalendarDayCellComponent,
  NbCalendarMonthModelService,
  NbCalendarDaysNamesComponent,
  NbCalendarWeekNumberComponent,
  NbCalendarDayPickerComponent,
  NbBaseCalendarComponent,
  NbCalendarComponent,
  NbButtonModule,
  NbNativeDateService,
  NbCalendarTimeModelService,
  NbCalendarActionsComponent,
  NbCalendarKitModule,
  NbBaseCalendarModule,
  NbCalendarModule,
  NbBaseCalendarRangeCell,
  NbCalendarRangeDayCellComponent,
  NbCalendarRangeYearCellComponent,
  NbCalendarRangeMonthCellComponent,
  NbCalendarRangeComponent,
  NbCalendarRangeModule,
  NB_TIME_PICKER_CONFIG,
  NB_DEFAULT_TIMEPICKER_LOCALIZATION_CONFIG,
  NbListComponent,
  NbListItemComponent,
  NbTimePickerCellComponent,
  NbTimePickerComponent,
  NbCalendarWithTimeComponent,
  NbDatepickerContainerComponent,
  NbDatepickerAdapter,
  NbDatepicker,
  NB_DATE_ADAPTER,
  NB_DATE_SERVICE_OPTIONS,
  NbDatepickerDirective,
  NbBasePicker,
  NbBasePickerComponent,
  NbDatepickerComponent,
  NbRangepickerComponent,
  NbDateTimePickerComponent,
  NbRestoreScrollTopHelper,
  NbLayoutComponent,
  NbLayoutColumnComponent,
  NbLayoutHeaderComponent,
  NbLayoutFooterComponent,
  NbLtrDirective,
  NbRtlDirective,
  NbLayoutModule,
  NbMenuItem,
  NbMenuService,
  NbBadgeComponent,
  NbToggleStates,
  NbMenuItemComponent,
  NbMenuComponent,
  NbBadgeModule,
  NbMenuModule,
  NbRouteTabsetComponent,
  NbRouteTabsetModule,
  NbSidebarService,
  NbSidebarHeaderComponent,
  NbSidebarFooterComponent,
  NbSidebarComponent,
  NbSidebarModule,
  NbTabContentDirective,
  NbTabTitleDirective,
  NbTabComponent,
  NbTabsetComponent,
  NbTabsetModule,
  NbUserComponent,
  NbUserModule,
  NbActionComponent,
  NbActionsComponent,
  NbActionsModule,
  NbSearchService,
  NbSearchFieldComponent,
  NbSearchComponent,
  NbSearchModule,
  NbCheckboxComponent,
  NbCheckboxModule,
  NbDynamicOverlay,
  NbDynamicOverlayChange,
  NbDynamicOverlayHandler,
  NbPopoverComponent,
  NbPopoverDirective,
  NbPopoverModule,
  NbContextMenuComponent,
  NbContextMenuDirective,
  NbContextMenuModule,
  NbProgressBarComponent,
  NbProgressBarModule,
  NbAlertComponent,
  NbAlertModule,
  NbFormFieldControl,
  NbFormFieldControlConfig,
  NbInputDirective,
  NbChatFormComponent,
  NbChatCustomMessageService,
  NbChatMessageTextComponent,
  NbChatMessageFileComponent,
  NbChatMessageQuoteComponent,
  NbChatOptions,
  NbChatMessageMapComponent,
  NbChatAvatarComponent,
  NbChatMessageComponent,
  NbChatTitleDirective,
  NbChatComponent,
  NbInputModule,
  NbChatCustomMessageDirective,
  NbChatModule,
  NbSpinnerComponent,
  NbSpinnerDirective,
  NbSpinnerModule,
  NB_STEPPER,
  NbStepComponent,
  NbStepperComponent,
  NbStepperNextDirective,
  NbStepperPreviousDirective,
  NbStepperModule,
  NbAccordionComponent,
  NbAccordionItemComponent,
  NbAccordionItemBodyComponent,
  NbAccordionItemHeaderComponent,
  NbAccordionModule,
  NB_BUTTON_GROUP,
  NbButtonToggleDirective,
  NbButtonGroupComponent,
  NbButtonGroupModule,
  NbListPageTrackerDirective,
  NbScrollableContainerDimensions,
  NbInfiniteListDirective,
  NbListModule,
  NbDirectionality,
  NbBidiModule,
  NbCellDefDirective,
  NbHeaderCellDefDirective,
  NbFooterCellDefDirective,
  NB_SORT_HEADER_COLUMN_DEF,
  NbColumnDefDirective,
  NbHeaderCellDirective,
  NbFooterCellDirective,
  NbCellDirective,
  NbDataSource,
  NbDataRowOutletDirective,
  NbHeaderRowOutletDirective,
  NbFooterRowOutletDirective,
  NbNoDataRowOutletDirective,
  NbCellOutletDirective,
  NbHeaderRowDefDirective,
  NbFooterRowDefDirective,
  NbRowDefDirective,
  NbHeaderRowComponent,
  NbFooterRowComponent,
  NbRowComponent,
  NB_TABLE_TEMPLATE,
  NB_VIEW_REPEATER_STRATEGY,
  NB_COALESCED_STYLE_SCHEDULER,
  NB_TABLE_PROVIDERS,
  NbTable,
  NbTableModule,
  NB_DIALOG_CONFIG,
  NbDialogConfig,
  NbDialogRef,
  NbDialogContainerComponent,
  NbDialogService,
  NbDialogModule,
  NbToastComponent,
  NbToastrContainerComponent,
  NB_TOASTR_CONFIG,
  NbToastrConfig,
  NbToastRef,
  NbToastContainer,
  NbToastrContainerRegistry,
  NbToastrService,
  NbToastrModule,
  NbToast,
  NbTooltipComponent,
  NbTooltipDirective,
  NbTooltipModule,
  NB_SELECT_INJECTION_TOKEN,
  NbOptionComponent,
  NbOptionListComponent,
  NbSelectLabelComponent,
  nbSelectFormFieldControlConfigFactory,
  NbSelectComponent,
  NbOptionGroupComponent,
  NbOptionModule,
  NbSelectModule,
  NbPrefixDirective,
  NbSuffixDirective,
  NbFormFieldComponent,
  NbSelectWithAutocompleteComponent,
  NbFormFieldModule,
  NbSelectWithAutocompleteModule,
  NbAutocompleteComponent,
  NbAutocompleteDirective,
  NbAutocompleteModule,
  NbWindowState,
  NB_WINDOW_DEFAULT_BUTTONS_CONFIG,
  NbWindowConfig,
  NB_WINDOW_CONTENT,
  NB_WINDOW_CONFIG,
  NB_WINDOW_CONTEXT,
  NbWindowRef,
  NbWindowsContainerComponent,
  NbWindowComponent,
  NbWindowService,
  NbWindowModule,
  NbTimePickerDirective,
  NbTimepickerModule,
  NbDateAdapterService,
  NbRangeAdapterService,
  NbDateTimeAdapterService,
  NbDatepickerModule,
  NbRadioComponent,
  NbRadioGroupComponent,
  NbRadioModule,
  NbTagComponent,
  NbTagInputDirective,
  NbTagListComponent,
  NbTagModule,
  NB_DEFAULT_ROW_LEVEL,
  NbTreeGridPresentationNode,
  NbTreeGridFilterService,
  NbSortDirection,
  NbSortDirective,
  NbSortHeaderIconDirective,
  NbSortIconComponent,
  NbSortHeaderComponent,
  NbTreeGridSortService,
  NbTreeGridService,
  NbTreeGridDataService,
  NbTreeGridDataSource,
  NbTreeGridDataSourceBuilder,
  NB_TREE_GRID,
  NbColumnsService,
  NbTreeGridComponent,
  NbTreeGridRowDefDirective,
  NbTreeGridHeaderRowDefDirective,
  NbTreeGridFooterRowDefDirective,
  NbTreeGridCellDefDirective,
  NbTreeGridHeaderCellDefDirective,
  NbTreeGridFooterCellDefDirective,
  NB_ROW_DOUBLE_CLICK_DELAY,
  NbTreeGridRowComponent,
  NbTreeGridHeaderRowComponent,
  NbTreeGridFooterRowComponent,
  NbTreeGridColumnDefDirective,
  NbTreeGridCellDirective,
  NbTreeGridHeaderCellDirective,
  NbTreeGridFooterCellDirective,
  NbFilterDirective,
  NbFilterInputDirective,
  NbTreeGridRowToggleDirective,
  NbTreeGridRowToggleComponent,
  NbTreeGridModule,
  NbToggleComponent,
  NbToggleModule
};
/*! Bundled license information:

@angular/forms/fesm2022/forms.mjs:
  (**
   * @license Angular v19.2.7
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/animations/fesm2022/animations.mjs:
  (**
   * @license Angular v19.2.7
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)

@nebular/theme/fesm2022/nebular-theme.mjs:
  (**
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)

@nebular/theme/fesm2022/nebular-theme.mjs:
  (*
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)
  (**
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)
  (*
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license infornbion.
   *)
*/
//# sourceMappingURL=chunk-F6HLTWD2.js.map
